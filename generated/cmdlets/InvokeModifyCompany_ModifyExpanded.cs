// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.0.6365, generator: {generator})
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Commvault.Powershell.Cmdlets
{
    using static Commvault.Powershell.Runtime.Extensions;

    /// <summary>Modify the properties of an existing company</summary>
    /// <remarks>
    /// [OpenAPI] ModifyCompany=>PUT:"/V4/company/{companyId}"
    /// </remarks>
    [global::System.Management.Automation.Cmdlet(global::System.Management.Automation.VerbsLifecycle.Invoke, @"ModifyCompany_ModifyExpanded", SupportsShouldProcess = true)]
    [global::System.Management.Automation.OutputType(typeof(Commvault.Powershell.Models.IGenericResp))]
    [global::Commvault.Powershell.Description(@"Modify the properties of an existing company")]
    [global::Commvault.Powershell.Generated]
    public partial class InvokeModifyCompany_ModifyExpanded : global::System.Management.Automation.PSCmdlet,
        Commvault.Powershell.Runtime.IEventListener
    {
        /// <summary>A copy of the Invocation Info (necessary to allow asJob to clone this cmdlet)</summary>
        private global::System.Management.Automation.InvocationInfo __invocationInfo;

        /// <summary>
        /// The <see cref="global::System.Threading.CancellationTokenSource" /> for this operation.
        /// </summary>
        private global::System.Threading.CancellationTokenSource _cancellationTokenSource = new global::System.Threading.CancellationTokenSource();

        /// <summary>Backing field for <see cref="Body" /> property.</summary>
        private Commvault.Powershell.Models.IUpdateCompany _body= new Commvault.Powershell.Models.UpdateCompany();

        /// <summary>Used to update the properties of an existing company</summary>
        private Commvault.Powershell.Models.IUpdateCompany Body { get => this._body; set => this._body = value; }

        /// <summary>Wait for .NET debugger to attach</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Wait for .NET debugger to attach")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter Break { get; set; }

        /// <summary>The reference to the client API class.</summary>
        public Commvault.Powershell.CommvaultPowerShell Client => Commvault.Powershell.Module.Instance.ClientAPI;

        /// <summary>Backing field for <see cref="CompanyId" /> property.</summary>
        private int _companyId;

        /// <summary>Id of the company to update</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "Id of the company to update")]
        [Commvault.Powershell.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"Id of the company to update",
        SerializedName = @"companyId",
        PossibleTypes = new [] { typeof(int) })]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Path)]
        public int CompanyId { get => this._companyId; set => this._companyId = value; }

        /// <summary>Refers to default data protection plans to use for the company.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Refers to default data protection plans to use for the company.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Refers to default data protection plans to use for the company.",
        SerializedName = @"defaultPlans",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IDefaultPlan) })]
        public Commvault.Powershell.Models.IDefaultPlan[] DefaultPlans { get => Body.DefaultPlans ?? null /* arrayOf */; set => Body.DefaultPlans = value; }

        /// <summary>Email id of the sender</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Email id of the sender")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Email id of the sender",
        SerializedName = @"senderEmail",
        PossibleTypes = new [] { typeof(string) })]
        public string EmailSettingSenderEmail { get => Body.EmailSettingSenderEmail ?? null; set => Body.EmailSettingSenderEmail = value; }

        /// <summary>Name of the sender sending the email</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Name of the sender sending the email")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Name of the sender sending the email",
        SerializedName = @"senderName",
        PossibleTypes = new [] { typeof(string) })]
        public string EmailSettingSenderName { get => Body.EmailSettingSenderName ?? null; set => Body.EmailSettingSenderName = value; }

        /// <summary>Unix file paths to be excluded.Comma separated string.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Unix file paths to be excluded.Comma separated string.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Unix file paths to be excluded.Comma separated string.",
        SerializedName = @"unix",
        PossibleTypes = new [] { typeof(string) })]
        public string FileExceptionUnix { get => Body.FileExceptionUnix ?? null; set => Body.FileExceptionUnix = value; }

        /// <summary>
        /// Enable or disable the use of the file path filters on all subclients. By default, it is enabled when filters are added
        /// for either Windows or Unix or both.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or disable the use of the file path filters on all subclients. By default, it is enabled when filters are added for either Windows or Unix or both.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or disable the use of the file path filters on all subclients. By default, it is enabled when filters are added for either Windows or Unix or both.",
        SerializedName = @"useCompanyGlobalFilter",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter FileExceptionUseCompanyGlobalFilter { get => Body.FileExceptionUseCompanyGlobalFilter ?? default(global::System.Management.Automation.SwitchParameter); set => Body.FileExceptionUseCompanyGlobalFilter = value; }

        /// <summary>Window file paths to be excluded.Comma separated string.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Window file paths to be excluded.Comma separated string.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Window file paths to be excluded.Comma separated string.",
        SerializedName = @"windows",
        PossibleTypes = new [] { typeof(string) })]
        public string FileExceptionWindows { get => Body.FileExceptionWindows ?? null; set => Body.FileExceptionWindows = value; }

        /// <summary>
        /// Used to assign owners to laptops automatically after installation. The owners can be all the logged in active directory
        /// users, the first user to login into the laptop after installation or the users belonging to the laptop's local user group
        /// list. The option to assign automatically can also be disabled.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Used to assign owners to laptops automatically after installation. The owners can be all the logged in active directory users, the first user to login into the laptop after installation or the users belonging to the laptop's local user group list. The option to assign automatically can also be disabled.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Used to assign owners to laptops automatically after installation. The owners can be all the logged in active directory users, the first user to login into the laptop after installation or the users belonging to the laptop's local user group list. The option to assign automatically can also be disabled.",
        SerializedName = @"assignLaptopOwners",
        PossibleTypes = new [] { typeof(string) })]
        public string GeneralAssignLaptopOwners { get => Body.GeneralAssignLaptopOwners ?? null; set => Body.GeneralAssignLaptopOwners = value; }

        /// <summary>Enable or disable authcode for installation.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or disable authcode for installation.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or disable authcode for installation.",
        SerializedName = @"authcodeForInstallation",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter GeneralAuthcodeForInstallation { get => Body.GeneralAuthcodeForInstallation ?? default(global::System.Management.Automation.SwitchParameter); set => Body.GeneralAuthcodeForInstallation = value; }

        /// <summary>
        /// Enable or Disable Auto Discover Applications.When Auto discover applications is enabled, each member server of this company
        /// is searched once every 24 hours to discover any applications that need to be backed up. For any newly-discovered and unprotected
        /// applications, the agent software is automatically installed on the server.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or Disable Auto Discover Applications.When Auto discover applications is enabled, each member server of this company is searched once every 24 hours to discover any applications that need to be backed up. For any newly-discovered and unprotected applications, the agent software is automatically installed on the server.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or Disable Auto Discover Applications.When Auto discover applications is enabled, each member server of this company is searched once every 24 hours to discover any applications that need to be backed up. For any newly-discovered and unprotected applications, the agent software is automatically installed on the server.",
        SerializedName = @"autoDiscoverApp",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter GeneralAutoDiscoverApp { get => Body.GeneralAutoDiscoverApp ?? default(global::System.Management.Automation.SwitchParameter); set => Body.GeneralAutoDiscoverApp = value; }

        /// <summary>Supported domains for the company</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Supported domains for the company")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Supported domains for the company",
        SerializedName = @"emailSuffix",
        PossibleTypes = new [] { typeof(string) })]
        public string GeneralEmailSuffix { get => Body.GeneralEmailSuffix ?? null; set => Body.GeneralEmailSuffix = value; }

        /// <summary>Enable or disable data encryption</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or disable data encryption")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or disable data encryption",
        SerializedName = @"enableDataEncryption",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter GeneralEnableDataEncryption { get => Body.GeneralEnableDataEncryption ?? default(global::System.Management.Automation.SwitchParameter); set => Body.GeneralEnableDataEncryption = value; }

        /// <summary>
        /// These are different types of infrastructure provided for storage in companies. It can be rented from the provider, owned
        /// or can be a hybrid. Cannot move back to rented storage from owned storage and cannot move back to rented storage/owned
        /// storage from rented and owned storage.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "These are different types of infrastructure provided for storage in companies. It can be rented from the provider, owned or can be a hybrid. Cannot move back to rented storage from owned storage and cannot move back to rented storage/owned storage from rented and owned storage.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"These are different types of infrastructure provided for storage in companies. It can be rented from the provider, owned or can be a hybrid. Cannot move back to rented storage from owned storage and cannot move back to rented storage/owned storage from rented and owned storage.",
        SerializedName = @"infrastructureType",
        PossibleTypes = new [] { typeof(string) })]
        public string GeneralInfrastructureType { get => Body.GeneralInfrastructureType ?? null; set => Body.GeneralInfrastructureType = value; }

        /// <summary>The company domain or NetBIOS name</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The company domain or NetBIOS name")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The company domain or NetBIOS name",
        SerializedName = @"newAlias",
        PossibleTypes = new [] { typeof(string) })]
        public string GeneralNewAlias { get => Body.GeneralNewAlias ?? null; set => Body.GeneralNewAlias = value; }

        /// <summary>
        /// Enable reseller mode. A reseller is a user or user groups who can operate multiple tenant environments. The service provider
        /// can assign one or more resellers as the tenant operator for a company. The reseller can switch to any of their assigned
        /// tenant environment and operate on the company as a tenant user. Once enabled, the reseller mode cannot be disabled.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable reseller mode. A reseller is a user or user groups who can operate multiple tenant environments. The service provider can assign one or more resellers as the tenant operator for a company. The reseller can switch to any of their assigned tenant environment and operate on the company as a tenant user. Once enabled, the reseller mode cannot be disabled.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable reseller mode. A reseller is a user or user groups who can operate multiple tenant environments. The service provider can assign one or more resellers as the tenant operator for a company. The reseller can switch to any of their assigned tenant environment and operate on the company as a tenant user. Once enabled, the reseller mode cannot be disabled.",
        SerializedName = @"resellerMode",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter GeneralResellerMode { get => Body.GeneralResellerMode ?? default(global::System.Management.Automation.SwitchParameter); set => Body.GeneralResellerMode = value; }

        /// <summary>Service commcells associated with the master commcell.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Service commcells associated with the master commcell.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Service commcells associated with the master commcell.",
        SerializedName = @"serviceCommcells",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IIdName) })]
        public Commvault.Powershell.Models.IIdName[] GeneralServiceCommcells { get => Body.GeneralServiceCommcells ?? null /* arrayOf */; set => Body.GeneralServiceCommcells = value; }

        /// <summary>.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = ".")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @".",
        SerializedName = @"supportedSolutions",
        PossibleTypes = new [] { typeof(string) })]
        public string[] GeneralSupportedSolutions { get => Body.GeneralSupportedSolutions ?? null /* arrayOf */; set => Body.GeneralSupportedSolutions = value; }

        /// <summary>Enable or disable the use of User Pricipal Name in place of an email address.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or disable the use of User Pricipal Name in place of an email address.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or disable the use of User Pricipal Name in place of an email address.",
        SerializedName = @"upnInsteadOfEmail",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter GeneralUpnInsteadOfEmail { get => Body.GeneralUpnInsteadOfEmail ?? default(global::System.Management.Automation.SwitchParameter); set => Body.GeneralUpnInsteadOfEmail = value; }

        /// <summary>SendAsync Pipeline Steps to be appended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be appended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Runtime)]
        public Commvault.Powershell.Runtime.SendAsyncStep[] HttpPipelineAppend { get; set; }

        /// <summary>SendAsync Pipeline Steps to be prepended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be prepended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Runtime)]
        public Commvault.Powershell.Runtime.SendAsyncStep[] HttpPipelinePrepend { get; set; }

        /// <summary>Accessor for our copy of the InvocationInfo.</summary>
        public global::System.Management.Automation.InvocationInfo InvocationInformation { get => __invocationInfo = __invocationInfo ?? this.MyInvocation ; set { __invocationInfo = value; } }

        /// <summary>
        /// <see cref="IEventListener" /> cancellation delegate. Stops the cmdlet when called.
        /// </summary>
        global::System.Action Commvault.Powershell.Runtime.IEventListener.Cancel => _cancellationTokenSource.Cancel;

        /// <summary><see cref="IEventListener" /> cancellation token.</summary>
        global::System.Threading.CancellationToken Commvault.Powershell.Runtime.IEventListener.Token => _cancellationTokenSource.Token;

        /// <summary>Used to change the name of a company</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Used to change the name of a company")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Used to change the name of a company",
        SerializedName = @"newName",
        PossibleTypes = new [] { typeof(string) })]
        public string NewName { get => Body.NewName ?? null; set => Body.NewName = value; }

        /// <summary>
        /// Enable or disable backup. This option can only be set or unset for a deactivated company.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or disable backup. This option can only be set or unset for a deactivated company.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or disable backup. This option can only be set or unset for a deactivated company.",
        SerializedName = @"disableBackup",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter OptionDisableBackup { get => Body.OptionDisableBackup ?? default(global::System.Management.Automation.SwitchParameter); set => Body.OptionDisableBackup = value; }

        /// <summary>
        /// Enable or disable login. This option can only be set or unset for a deactivated company.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or disable login. This option can only be set or unset for a deactivated company.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or disable login. This option can only be set or unset for a deactivated company.",
        SerializedName = @"disableLogin",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter OptionDisableLogin { get => Body.OptionDisableLogin ?? default(global::System.Management.Automation.SwitchParameter); set => Body.OptionDisableLogin = value; }

        /// <summary>
        /// Enable or disable restore. This option can only be set or unset for a deactivated company.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enable or disable restore. This option can only be set or unset for a deactivated company.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable or disable restore. This option can only be set or unset for a deactivated company.",
        SerializedName = @"disableRestore",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter OptionDisableRestore { get => Body.OptionDisableRestore ?? default(global::System.Management.Automation.SwitchParameter); set => Body.OptionDisableRestore = value; }

        /// <summary>
        /// When specified, forces the cmdlet return a 'bool' given that there isn't a return type by default.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Returns true when the command succeeds")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter PassThru { get; set; }

        /// <summary>
        /// The instance of the <see cref="Commvault.Powershell.Runtime.HttpPipeline" /> that the remote call will use.
        /// </summary>
        private Commvault.Powershell.Runtime.HttpPipeline Pipeline { get; set; }

        /// <summary>
        /// Provide a list of data protection plans to use for the company. The plans that are provided are the plans that the tenant
        /// administrator can choose from.
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Provide a list of data protection plans to use for the company. The plans that are provided are the plans that the tenant administrator can choose from.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Provide a list of data protection plans to use for the company. The plans that are provided are the plans that the tenant administrator can choose from.",
        SerializedName = @"plans",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IIdName) })]
        public Commvault.Powershell.Models.IIdName[] Plans { get => Body.Plans ?? null /* arrayOf */; set => Body.Plans = value; }

        /// <summary>The URI for the proxy server to use</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "The URI for the proxy server to use")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Runtime)]
        public global::System.Uri Proxy { get; set; }

        /// <summary>Credentials for a proxy server to use for the remote call</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Credentials for a proxy server to use for the remote call")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Runtime)]
        public global::System.Management.Automation.PSCredential ProxyCredential { get; set; }

        /// <summary>Use the default credentials for the proxy</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Use the default credentials for the proxy")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter ProxyUseDefaultCredentials { get; set; }

        /// <summary>.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = ".")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @".",
        SerializedName = @"security",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IUpdateSecurityAssoc) })]
        public Commvault.Powershell.Models.IUpdateSecurityAssoc[] Security { get => Body.Security ?? null /* arrayOf */; set => Body.Security = value; }

        /// <summary>Primary site name</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Primary site name")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Primary site name",
        SerializedName = @"primarySiteName",
        PossibleTypes = new [] { typeof(string) })]
        public string SitePrimarySiteName { get => Body.SitePrimarySiteName ?? null; set => Body.SitePrimarySiteName = value; }

        /// <summary>Secondary site names</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Secondary site names")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Secondary site names",
        SerializedName = @"secondarySiteNames",
        PossibleTypes = new [] { typeof(string) })]
        public string[] SiteSecondarySiteNames { get => Body.SiteSecondarySiteNames ?? null /* arrayOf */; set => Body.SiteSecondarySiteNames = value; }

        /// <summary>Used to activate or deactivate the company.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Used to activate or deactivate the company.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Used to activate or deactivate the company.",
        SerializedName = @"deactivate",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter StatusDeactivate { get => Body.StatusDeactivate ?? default(global::System.Management.Automation.SwitchParameter); set => Body.StatusDeactivate = value; }

        /// <summary>.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = ".")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @".",
        SerializedName = @"tenantOperators",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.ITenantOperator) })]
        public Commvault.Powershell.Models.ITenantOperator[] TenantOperators { get => Body.TenantOperators ?? null /* arrayOf */; set => Body.TenantOperators = value; }

        /// <summary>
        /// enable two factor authentication for every entity. if set to false when Two factor authentication is enabled, provide
        /// userGroupId or userGroupName. If both are provided, userGroupId is taken
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "enable two factor authentication for every entity. if set to false when Two factor authentication is enabled, provide userGroupId or userGroupName. If both are provided, userGroupId is taken")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"enable two factor authentication for every entity. if set to false when Two factor authentication is enabled, provide userGroupId or userGroupName. If both are provided, userGroupId is taken",
        SerializedName = @"all",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter TwoFactorAuthAll { get => Body.TwoFactorAuthAll ?? default(global::System.Management.Automation.SwitchParameter); set => Body.TwoFactorAuthAll = value; }

        /// <summary>
        /// enable or disable two factor authentication. if enabled, all or userGroups value should be provided.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "enable or disable two factor authentication. if enabled, all or userGroups value should be provided.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"enable or disable two factor authentication. if enabled, all or userGroups value should be provided.",
        SerializedName = @"enable",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter TwoFactorAuthEnable { get => Body.TwoFactorAuthEnable ?? default(global::System.Management.Automation.SwitchParameter); set => Body.TwoFactorAuthEnable = value; }

        /// <summary>.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = ".")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @".",
        SerializedName = @"userGroups",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IIdName) })]
        public Commvault.Powershell.Models.IIdName[] TwoFactorAuthUserGroups { get => Body.TwoFactorAuthUserGroups ?? null /* arrayOf */; set => Body.TwoFactorAuthUserGroups = value; }

        /// <summary>
        /// <c>overrideOnBadRequest</c> will be called before the regular onBadRequest has been processed, allowing customization
        /// of what happens on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="returnNow">/// Determines if the rest of the onBadRequest method should be processed, or if the method should
        /// return immediately (set to true to skip further processing )</param>

        partial void overrideOnBadRequest(global::System.Net.Http.HttpResponseMessage responseMessage, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// <c>overrideOnNotFound</c> will be called before the regular onNotFound has been processed, allowing customization of what
        /// happens on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="returnNow">/// Determines if the rest of the onNotFound method should be processed, or if the method should
        /// return immediately (set to true to skip further processing )</param>

        partial void overrideOnNotFound(global::System.Net.Http.HttpResponseMessage responseMessage, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// <c>overrideOnOk</c> will be called before the regular onOk has been processed, allowing customization of what happens
        /// on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Commvault.Powershell.Models.IGenericResp" /> from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onOk method should be processed, or if the method should return
        /// immediately (set to true to skip further processing )</param>

        partial void overrideOnOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// (overrides the default BeginProcessing method in global::System.Management.Automation.PSCmdlet)
        /// </summary>
        protected override void BeginProcessing()
        {
            Module.Instance.SetProxyConfiguration(Proxy, ProxyCredential, ProxyUseDefaultCredentials);
            if (Break)
            {
                Commvault.Powershell.Runtime.AttachDebugger.Break();
            }
            ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletBeginProcessing).Wait(); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
        }

        /// <summary>Performs clean-up after the command execution</summary>
        protected override void EndProcessing()
        {
            ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletEndProcessing).Wait(); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
        }

        /// <summary>
        /// Intializes a new instance of the <see cref="InvokeModifyCompany_ModifyExpanded" /> cmdlet class.
        /// </summary>
        public InvokeModifyCompany_ModifyExpanded()
        {

        }

        /// <summary>Handles/Dispatches events during the call to the REST service.</summary>
        /// <param name="id">The message id</param>
        /// <param name="token">The message cancellation token. When this call is cancelled, this should be <c>true</c></param>
        /// <param name="messageData">Detailed message data for the message event.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the message is completed.
        /// </returns>
         async global::System.Threading.Tasks.Task Commvault.Powershell.Runtime.IEventListener.Signal(string id, global::System.Threading.CancellationToken token, global::System.Func<Commvault.Powershell.Runtime.EventData> messageData)
        {
            using( NoSynchronizationContext )
            {
                if (token.IsCancellationRequested)
                {
                    return ;
                }

                switch ( id )
                {
                    case Commvault.Powershell.Runtime.Events.Verbose:
                    {
                        WriteVerbose($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Commvault.Powershell.Runtime.Events.Warning:
                    {
                        WriteWarning($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Commvault.Powershell.Runtime.Events.Information:
                    {
                        var data = messageData();
                        WriteInformation(data, new[] { data.Message });
                        return ;
                    }
                    case Commvault.Powershell.Runtime.Events.Debug:
                    {
                        WriteDebug($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Commvault.Powershell.Runtime.Events.Error:
                    {
                        WriteError(new global::System.Management.Automation.ErrorRecord( new global::System.Exception(messageData().Message), string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null ) );
                        return ;
                    }
                }
                await Commvault.Powershell.Module.Instance.Signal(id, token, messageData, (i,t,m) => ((Commvault.Powershell.Runtime.IEventListener)this).Signal(i,t,()=> Commvault.Powershell.Runtime.EventDataConverter.ConvertFrom( m() ) as Commvault.Powershell.Runtime.EventData ), InvocationInformation, this.ParameterSetName, null );
                if (token.IsCancellationRequested)
                {
                    return ;
                }
                WriteDebug($"{id}: {(messageData().Message ?? global::System.String.Empty)}");
            }
        }

        /// <summary>Performs execution of the command.</summary>
        protected override void ProcessRecord()
        {
            ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletProcessRecordStart).Wait(); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
            try
            {
                // work
                if (ShouldProcess($"Call remote 'ModifyCompany' operation"))
                {
                    using( var asyncCommandRuntime = new Commvault.Powershell.Runtime.PowerShell.AsyncCommandRuntime(this, ((Commvault.Powershell.Runtime.IEventListener)this).Token) )
                    {
                        asyncCommandRuntime.Wait( ProcessRecordAsync(),((Commvault.Powershell.Runtime.IEventListener)this).Token);
                    }
                }
            }
            catch (global::System.AggregateException aggregateException)
            {
                // unroll the inner exceptions to get the root cause
                foreach( var innerException in aggregateException.Flatten().InnerExceptions )
                {
                    ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletException, $"{innerException.GetType().Name} - {innerException.Message} : {innerException.StackTrace}").Wait(); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    // Write exception out to error channel.
                    WriteError( new global::System.Management.Automation.ErrorRecord(innerException,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
                }
            }
            catch (global::System.Exception exception) when ((exception as System.Management.Automation.PipelineStoppedException)== null || (exception as System.Management.Automation.PipelineStoppedException).InnerException != null)
            {
                ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletException, $"{exception.GetType().Name} - {exception.Message} : {exception.StackTrace}").Wait(); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                // Write exception out to error channel.
                WriteError( new global::System.Management.Automation.ErrorRecord(exception,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
            }
            finally
            {
                ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletProcessRecordEnd).Wait();
            }
        }

        /// <summary>Performs execution of the command, working asynchronously if required.</summary>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        protected async global::System.Threading.Tasks.Task ProcessRecordAsync()
        {
            using( NoSynchronizationContext )
            {
                await ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletProcessRecordAsyncStart); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                await ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletGetPipeline); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                Pipeline = Commvault.Powershell.Module.Instance.CreatePipeline(InvocationInformation, this.ParameterSetName);
                if (null != HttpPipelinePrepend)
                {
                    Pipeline.Prepend((this.CommandRuntime as Commvault.Powershell.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelinePrepend) ?? HttpPipelinePrepend);
                }
                if (null != HttpPipelineAppend)
                {
                    Pipeline.Append((this.CommandRuntime as Commvault.Powershell.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelineAppend) ?? HttpPipelineAppend);
                }
                // get the client instance
                try
                {
                    await ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletBeforeAPICall); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    await this.Client.ModifyCompany(CompanyId, Body, onOk, onBadRequest, onNotFound, this, Pipeline);
                    await ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletAfterAPICall); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                }
                catch (Commvault.Powershell.Runtime.UndeclaredResponseException urexception)
                {
                    WriteError(new global::System.Management.Automation.ErrorRecord(urexception, urexception.StatusCode.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new {  CompanyId=CompanyId,body=Body})
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(urexception.Message) { RecommendedAction = urexception.Action }
                    });
                }
                finally
                {
                    await ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletProcessRecordAsyncEnd);
                }
            }
        }

        /// <summary>Interrupts currently running code within the command.</summary>
        protected override void StopProcessing()
        {
            ((Commvault.Powershell.Runtime.IEventListener)this).Cancel();
            base.StopProcessing();
        }

        /// <summary>a delegate that is called when the remote service returns 400 (BadRequest).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onBadRequest(global::System.Net.Http.HttpResponseMessage responseMessage)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnBadRequest(responseMessage, ref _returnNow);
                // if overrideOnBadRequest has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // onBadRequest - response for 400 /
                if (true == MyInvocation?.BoundParameters?.ContainsKey("PassThru"))
                {
                    WriteObject(true);
                }
            }
        }

        /// <summary>a delegate that is called when the remote service returns 404 (NotFound).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onNotFound(global::System.Net.Http.HttpResponseMessage responseMessage)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnNotFound(responseMessage, ref _returnNow);
                // if overrideOnNotFound has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // onNotFound - response for 404 /
                if (true == MyInvocation?.BoundParameters?.ContainsKey("PassThru"))
                {
                    WriteObject(true);
                }
            }
        }

        /// <summary>a delegate that is called when the remote service returns 200 (OK).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Commvault.Powershell.Models.IGenericResp" /> from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnOk(responseMessage, response, ref _returnNow);
                // if overrideOnOk has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // onOk - response for 200 / application/json
                // (await response) // should be Commvault.Powershell.Models.IGenericResp
                WriteObject((await response));
            }
        }
    }
}