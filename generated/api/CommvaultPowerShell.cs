// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.0.6365, generator: {generator})
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Commvault.Powershell
{
    using static Commvault.Powershell.Runtime.Extensions;

    /// <summary>
    /// Low-level API implementation for the CommvaultPowerShell service.
    /// Commvault APIs
    /// </summary>
    public partial class CommvaultPowerShell
    {

        /// <summary>Used to add a media agent to a disk access path</summary>
        /// <param name="storagePoolId">Id of the disk storage pool whose details have to be fetched to add a new access path</param>
        /// <param name="backupLocationId">Id of the backup location whose details have to be fetched to add a new access path</param>
        /// <param name="body">Used to add a new access path to a backup location</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task AddMediaAgent(int storagePoolId, int backupLocationId, Commvault.Powershell.Models.IAddDiskAccessPath body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + (storagePoolId.ToString())
                        + "/BackupLocation/"
                        + (backupLocationId.ToString())
                        + "/AccessPath"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.AddMediaAgent_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Used to add a media agent to a disk access path</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">Used to add a new access path to a backup location</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task AddMediaAgentViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IAddDiskAccessPath body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Disk/(?<storagePoolId>[^/]+)/BackupLocation/(?<backupLocationId>[^/]+)/AccessPath$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Disk/{storagePoolId}/BackupLocation/{backupLocationId}/AccessPath'");
                }

                // replace URI parameters with values from identity
                var storagePoolId = _match.Groups["storagePoolId"].Value;
                var backupLocationId = _match.Groups["backupLocationId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + storagePoolId
                        + "/BackupLocation/"
                        + backupLocationId
                        + "/AccessPath"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.AddMediaAgent_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="AddMediaAgent" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task AddMediaAgent_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="AddMediaAgent" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="storagePoolId">Id of the disk storage pool whose details have to be fetched to add a new access path</param>
        /// <param name="backupLocationId">Id of the backup location whose details have to be fetched to add a new access path</param>
        /// <param name="body">Used to add a new access path to a backup location</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task AddMediaAgent_Validate(int storagePoolId, int backupLocationId, Commvault.Powershell.Models.IAddDiskAccessPath body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>To Backup the virtual machines in vmgroup</summary>
        /// <param name="vmUuid">Id of the Virtual Machine to backup</param>
        /// <param name="backupLevel">Backup level , Default :Incremental</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task BackupVirtualMachine(string vmUuid, string backupLevel, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateTaskRespforBackup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VirtualMachines/"
                        + global::System.Uri.EscapeDataString(vmUuid)
                        + "/backup"
                        + "?"
                        + (string.IsNullOrEmpty(backupLevel) ? global::System.String.Empty : "backupLevel=" + global::System.Uri.EscapeDataString(backupLevel))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.BackupVirtualMachine_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>To Backup the virtual machines in vmgroup</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="backupLevel">Backup level , Default :Incremental</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task BackupVirtualMachineViaIdentity(global::System.String viaIdentity, string backupLevel, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateTaskRespforBackup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/VirtualMachines/(?<vmUUID>[^/]+)/backup$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/VirtualMachines/{vmUUID}/backup'");
                }

                // replace URI parameters with values from identity
                var vmUuid = _match.Groups["vmUUID"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VirtualMachines/"
                        + vmUuid
                        + "/backup"
                        + "?"
                        + (string.IsNullOrEmpty(backupLevel) ? global::System.String.Empty : "backupLevel=" + global::System.Uri.EscapeDataString(backupLevel))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.BackupVirtualMachine_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="BackupVirtualMachine" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task BackupVirtualMachine_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateTaskRespforBackup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.CreateTaskRespforBackup.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="BackupVirtualMachine" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="vmUuid">Id of the Virtual Machine to backup</param>
        /// <param name="backupLevel">Backup level , Default :Incremental</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task BackupVirtualMachine_Validate(string vmUuid, string backupLevel, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(vmUuid),vmUuid);
                await eventListener.AssertNotNull(nameof(backupLevel),backupLevel);
            }
        }

        /// <summary>This endpoint configures a syslog server.</summary>
        /// <param name="body">This operation configures a syslog server.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ConfigureSyslogStatus(Commvault.Powershell.Models.ISyslogConfigure body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/SyslogServer"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ConfigureSyslogStatus_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ConfigureSyslogStatus" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ConfigureSyslogStatus_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ConfigureSyslogStatus" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">This operation configures a syslog server.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ConfigureSyslogStatus_Validate(Commvault.Powershell.Models.ISyslogConfigure body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// Add a new Access path (mediaAgent) to a specific bucket of a specific cloud storage
        /// </summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="bucketId">Id of Bucket</param>
        /// <param name="body">Used to add a new access path to a bucket</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateAccessPathForBucketOfCloudStorage(int cloudStorageId, int bucketId, Commvault.Powershell.Models.IPaths4Yo4LoV4StorageCloudCloudstorageidBucketBucketidAccesspathPostRequestbodyContentApplicationJsonSchema body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + (cloudStorageId.ToString())
                        + "/Bucket/"
                        + (bucketId.ToString())
                        + "/AccessPath"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateAccessPathForBucketOfCloudStorage_Call(request,onOk,onBadRequest,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>
        /// Add a new Access path (mediaAgent) to a specific bucket of a specific cloud storage
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">Used to add a new access path to a bucket</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateAccessPathForBucketOfCloudStorageViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IPaths4Yo4LoV4StorageCloudCloudstorageidBucketBucketidAccesspathPostRequestbodyContentApplicationJsonSchema body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Cloud/(?<cloudStorageId>[^/]+)/Bucket/(?<bucketId>[^/]+)/AccessPath$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Cloud/{cloudStorageId}/Bucket/{bucketId}/AccessPath'");
                }

                // replace URI parameters with values from identity
                var cloudStorageId = _match.Groups["cloudStorageId"].Value;
                var bucketId = _match.Groups["bucketId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + cloudStorageId
                        + "/Bucket/"
                        + bucketId
                        + "/AccessPath"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateAccessPathForBucketOfCloudStorage_Call(request,onOk,onBadRequest,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref="CreateAccessPathForBucketOfCloudStorage" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateAccessPathForBucketOfCloudStorage_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateAccessPathForBucketOfCloudStorage" /> method. Call this like the actual call, but
        /// you will get validation events back.
        /// </summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="bucketId">Id of Bucket</param>
        /// <param name="body">Used to add a new access path to a bucket</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateAccessPathForBucketOfCloudStorage_Validate(int cloudStorageId, int bucketId, Commvault.Powershell.Models.IPaths4Yo4LoV4StorageCloudCloudstorageidBucketBucketidAccesspathPostRequestbodyContentApplicationJsonSchema body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create Alert Definitions</summary>
        /// <param name="body">AlertDefinitonsCreate</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateAlertDefinitions(Commvault.Powershell.Models.IAlertDefinitonsCreate body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AlertDefinitions"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateAlertDefinitions_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateAlertDefinitions" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateAlertDefinitions_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.IdName.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateAlertDefinitions" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">AlertDefinitonsCreate</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateAlertDefinitions_Validate(Commvault.Powershell.Models.IAlertDefinitonsCreate body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a Kubernetes application group</summary>
        /// <param name="body">CreatevmGroupReq</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateApplicationGroup(Commvault.Powershell.Models.ICreatevmGroupReq body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IApplicationGroupResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Kubernetes/ApplicationGroups"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateApplicationGroup_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateApplicationGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateApplicationGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IApplicationGroupResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.ApplicationGroupResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateApplicationGroup" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">CreatevmGroupReq</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateApplicationGroup_Validate(Commvault.Powershell.Models.ICreatevmGroupReq body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a Backup Destination for a Plan</summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateArchiveBackupDestination(int planId, Commvault.Powershell.Models.ICreateArchivePlanBackupDestinations body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + (planId.ToString())
                        + "/BackupDestination"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateArchiveBackupDestination_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Create a Backup Destination for a Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateArchiveBackupDestinationViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.ICreateArchivePlanBackupDestinations body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ArchivePlan/(?<planId>[^/]+)/BackupDestination$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ArchivePlan/{planId}/BackupDestination'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + planId
                        + "/BackupDestination"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateArchiveBackupDestination_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateArchiveBackupDestination" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateArchiveBackupDestination_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanBackupDestinationResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateArchiveBackupDestination" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateArchiveBackupDestination_Validate(int planId, Commvault.Powershell.Models.ICreateArchivePlanBackupDestinations body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create Archive Plan</summary>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateArchivePlan(Commvault.Powershell.Models.IArchivePlan body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateArchivePlan_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateArchivePlan" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateArchivePlan_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateArchivePlan" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateArchivePlan_Validate(Commvault.Powershell.Models.IArchivePlan body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a Backup Destination for a Plan</summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateBackupDestination(int planId, Commvault.Powershell.Models.ICreatePlanBackupDestinations body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + (planId.ToString())
                        + "/BackupDestination"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateBackupDestination_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Create a Backup Destination for a Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateBackupDestinationViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.ICreatePlanBackupDestinations body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerPlan/(?<planId>[^/]+)/BackupDestination$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerPlan/{planId}/BackupDestination'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + planId
                        + "/BackupDestination"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateBackupDestination_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateBackupDestination" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateBackupDestination_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanBackupDestinationResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateBackupDestination" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateBackupDestination_Validate(int planId, Commvault.Powershell.Models.ICreatePlanBackupDestinations body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a new backup location</summary>
        /// <param name="storagePoolId">Id of the disk storage to update</param>
        /// <param name="body">If adding a network access path, Please add credentials or saved credentials. If both are provided,
        /// credentials will be taken into consideration.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateBackupLocation(int storagePoolId, Commvault.Powershell.Models.ICreateBackupLocation body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + (storagePoolId.ToString())
                        + "/BackupLocation"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateBackupLocation_Call(request,onOk,onBadRequest,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Create a new backup location</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">If adding a network access path, Please add credentials or saved credentials. If both are provided,
        /// credentials will be taken into consideration.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateBackupLocationViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.ICreateBackupLocation body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Disk/(?<storagePoolId>[^/]+)/BackupLocation$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Disk/{storagePoolId}/BackupLocation'");
                }

                // replace URI parameters with values from identity
                var storagePoolId = _match.Groups["storagePoolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + storagePoolId
                        + "/BackupLocation"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateBackupLocation_Call(request,onOk,onBadRequest,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateBackupLocation" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateBackupLocation_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.IdName.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateBackupLocation" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="storagePoolId">Id of the disk storage to update</param>
        /// <param name="body">If adding a network access path, Please add credentials or saved credentials. If both are provided,
        /// credentials will be taken into consideration.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateBackupLocation_Validate(int storagePoolId, Commvault.Powershell.Models.ICreateBackupLocation body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a Blackout Window</summary>
        /// <param name="body">betweenDates refers to the dates where the blackout window will be in effect. Dates have to be given
        /// in unix time format. time has to be provided in seconds. company refers to company to which the blackout window is associated.Id
        /// is given first preference if both are id and name are provided.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateBlackoutWindow(Commvault.Powershell.Models.ICreateBlackoutWindow body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/BlackoutWindow"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateBlackoutWindow_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateBlackoutWindow" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateBlackoutWindow_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.IdName.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateBlackoutWindow" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">betweenDates refers to the dates where the blackout window will be in effect. Dates have to be given
        /// in unix time format. time has to be provided in seconds. company refers to company to which the blackout window is associated.Id
        /// is given first preference if both are id and name are provided.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateBlackoutWindow_Validate(Commvault.Powershell.Models.ICreateBlackoutWindow body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a CDM Plan</summary>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateCdmPlan(Commvault.Powershell.Models.ICreateCdmPlan body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/CDMPlan"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateCdmPlan_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateCdmPlan" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateCdmPlan_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateCdmPlan" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateCdmPlan_Validate(Commvault.Powershell.Models.ICreateCdmPlan body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Add metadata cache paths to storage</summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="body">If adding a network access path, Please add credentials or saved credentials. If both are provided,
        /// credentials will be taken into consideration.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateCloudStorageMetaDataCache(int cloudStorageId, Commvault.Powershell.Models.ICreateMetadataCacheConfigurations body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + (cloudStorageId.ToString())
                        + "/MetadataCache"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateCloudStorageMetaDataCache_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Add metadata cache paths to storage</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">If adding a network access path, Please add credentials or saved credentials. If both are provided,
        /// credentials will be taken into consideration.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateCloudStorageMetaDataCacheViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.ICreateMetadataCacheConfigurations body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Cloud/(?<cloudStorageId>[^/]+)/MetadataCache$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Cloud/{cloudStorageId}/MetadataCache'");
                }

                // replace URI parameters with values from identity
                var cloudStorageId = _match.Groups["cloudStorageId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + cloudStorageId
                        + "/MetadataCache"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateCloudStorageMetaDataCache_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateCloudStorageMetaDataCache" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateCloudStorageMetaDataCache_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateCloudStorageMetaDataCache" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="body">If adding a network access path, Please add credentials or saved credentials. If both are provided,
        /// credentials will be taken into consideration.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateCloudStorageMetaDataCache_Validate(int cloudStorageId, Commvault.Powershell.Models.ICreateMetadataCacheConfigurations body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a Company</summary>
        /// <param name="body">Used to create a new company</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateCompany(Commvault.Powershell.Models.ICreateCompany body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/company"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateCompany_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateCompany" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateCompany_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.IdName.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateCompany" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">Used to create a new company</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateCompany_Validate(Commvault.Powershell.Models.ICreateCompany body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a new disk storage pool</summary>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateDiskStorage(Commvault.Powershell.Models.ICreateDiskStorage body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateDiskStorage_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateDiskStorage" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateDiskStorage_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.IdName.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateDiskStorage" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateDiskStorage_Validate(Commvault.Powershell.Models.ICreateDiskStorage body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a HyperScale Storage</summary>
        /// <param name="body">HyperScaleStorage</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateHyperScaleStorage(Commvault.Powershell.Models.IHyperScaleStorage body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHyperScaleStorageResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/HyperScale"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateHyperScaleStorage_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateHyperScaleStorage" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateHyperScaleStorage_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHyperScaleStorageResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.HyperScaleStorageResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateHyperScaleStorage" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="body">HyperScaleStorage</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateHyperScaleStorage_Validate(Commvault.Powershell.Models.IHyperScaleStorage body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create Kubernetes cluster</summary>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateKubernetescluster(Commvault.Powershell.Models.ICreateKubernetesCluster body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateClusterResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Kubernetes/cluster"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateKubernetescluster_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateKubernetescluster" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateKubernetescluster_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateClusterResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.CreateClusterResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateKubernetescluster" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateKubernetescluster_Validate(Commvault.Powershell.Models.ICreateKubernetesCluster body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a Backup Destination for a Plan</summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateLaptopBackupDestination(int planId, Commvault.Powershell.Models.ICreatePlanBackupDestinations body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + (planId.ToString())
                        + "/BackupDestination"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateLaptopBackupDestination_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Create a Backup Destination for a Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateLaptopBackupDestinationViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.ICreatePlanBackupDestinations body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/LaptopPlan/(?<planId>[^/]+)/BackupDestination$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/LaptopPlan/{planId}/BackupDestination'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + planId
                        + "/BackupDestination"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateLaptopBackupDestination_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateLaptopBackupDestination" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateLaptopBackupDestination_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanBackupDestinationResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateLaptopBackupDestination" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateLaptopBackupDestination_Validate(int planId, Commvault.Powershell.Models.ICreatePlanBackupDestinations body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create Laptop Plan</summary>
        /// <param name="body">Create a new Laptop Plan</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateLaptopPlan(Commvault.Powershell.Models.ILaptopPlan body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateLaptopPlan_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateLaptopPlan" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateLaptopPlan_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateLaptopPlan" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">Create a new Laptop Plan</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateLaptopPlan_Validate(Commvault.Powershell.Models.ILaptopPlan body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a new role</summary>
        /// <param name="body">Create a new role.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateNewRole(Commvault.Powershell.Models.ICreateRole body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Role"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateNewRole_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateNewRole" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateNewRole_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.IdName.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateNewRole" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">Create a new role.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateNewRole_Validate(Commvault.Powershell.Models.ICreateRole body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Add nodes for a specific hyperscale storage</summary>
        /// <param name="hyperScaleStorageId">Id of hyperscale storage</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateNodeforHyperScaleStorage(int hyperScaleStorageId, Commvault.Powershell.Models.IPaths1PkfazfV4StorageHyperscaleHyperscalestorageidNodesPostRequestbodyContentApplicationJsonSchema body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/HyperScale/"
                        + (hyperScaleStorageId.ToString())
                        + "/Nodes"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateNodeforHyperScaleStorage_Call(request,onOk,onBadRequest,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Add nodes for a specific hyperscale storage</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateNodeforHyperScaleStorageViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IPaths1PkfazfV4StorageHyperscaleHyperscalestorageidNodesPostRequestbodyContentApplicationJsonSchema body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/HyperScale/(?<hyperScaleStorageId>[^/]+)/Nodes$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/HyperScale/{hyperScaleStorageId}/Nodes'");
                }

                // replace URI parameters with values from identity
                var hyperScaleStorageId = _match.Groups["hyperScaleStorageId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/HyperScale/"
                        + hyperScaleStorageId
                        + "/Nodes"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateNodeforHyperScaleStorage_Call(request,onOk,onBadRequest,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateNodeforHyperScaleStorage" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateNodeforHyperScaleStorage_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateNodeforHyperScaleStorage" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="hyperScaleStorageId">Id of hyperscale storage</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateNodeforHyperScaleStorage_Validate(int hyperScaleStorageId, Commvault.Powershell.Models.IPaths1PkfazfV4StorageHyperscaleHyperscalestorageidNodesPostRequestbodyContentApplicationJsonSchema body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// Api to create plan rules. Request body will suggest plan against which rule need to be created and type of entities(workloads
        /// type, server groups, regions and all) that need to be referenced for applying that rule against a workload.
        /// </summary>
        /// <param name="body">This object will send details to create new plan rule. User can provide all rule options or can specify
        /// a specific rule group. Be default, for rule to be applicable for association to a workload, ALL specified rules in that
        /// Rule need to be matched.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreatePlanRule(Commvault.Powershell.Models.ICreatePlanEntityRule body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreatePlanRule_Call(request,onOk,onForbidden,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreatePlanRule" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreatePlanRule_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.IdName.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Forbidden:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onForbidden(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreatePlanRule" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">This object will send details to create new plan rule. User can provide all rule options or can specify
        /// a specific rule group. Be default, for rule to be applicable for association to a workload, ALL specified rules in that
        /// Rule need to be matched.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreatePlanRule_Validate(Commvault.Powershell.Models.ICreatePlanEntityRule body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a region</summary>
        /// <param name="body">Details of the new region</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onConflict">a delegate that is called when the remote service returns 409 (Conflict).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateRegion(Commvault.Powershell.Models.ICreateRegion body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onConflict, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Regions"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateRegion_Call(request,onOk,onBadRequest,onConflict,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateRegion" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onConflict">a delegate that is called when the remote service returns 409 (Conflict).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateRegion_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onConflict, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.IdName.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Conflict:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onConflict(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateRegion" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">Details of the new region</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateRegion_Validate(Commvault.Powershell.Models.ICreateRegion body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Creates SAML app</summary>
        /// <param name="body">Create SAML request</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateSamlApp(Commvault.Powershell.Models.ISamlReq body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/SAML"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateSamlApp_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateSamlApp" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateSamlApp_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateSamlApp" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">Create SAML request</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateSamlApp_Validate(Commvault.Powershell.Models.ISamlReq body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a Server Plan</summary>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateServerPlan(Commvault.Powershell.Models.ICreateServerPlan body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateServerPlan_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>API to create backup content on server plan</summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateServerPlanBackupContent(int planId, Commvault.Powershell.Models.ICreateServerPlanBackupContent body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateServerPlanBackupContentResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + (planId.ToString())
                        + "/BackupContent"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateServerPlanBackupContent_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>API to create backup content on server plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateServerPlanBackupContentViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.ICreateServerPlanBackupContent body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateServerPlanBackupContentResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerPlan/(?<planId>[^/]+)/BackupContent$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerPlan/{planId}/BackupContent'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + planId
                        + "/BackupContent"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateServerPlanBackupContent_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateServerPlanBackupContent" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateServerPlanBackupContent_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateServerPlanBackupContentResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.CreateServerPlanBackupContentResponse.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateServerPlanBackupContent" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateServerPlanBackupContent_Validate(int planId, Commvault.Powershell.Models.ICreateServerPlanBackupContent body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>API to create RPO schedules on server plan</summary>
        /// <param name="planId">Id of the Server Plan</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateServerPlanRpo(int planId, Commvault.Powershell.Models.ICreateServerPlanRpo body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateServerPlanRpoResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + (planId.ToString())
                        + "/RPO"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateServerPlanRpo_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>API to create RPO schedules on server plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateServerPlanRpoViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.ICreateServerPlanRpo body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateServerPlanRpoResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerPlan/(?<planId>[^/]+)/RPO$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerPlan/{planId}/RPO'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + planId
                        + "/RPO"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateServerPlanRpo_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateServerPlanRpo" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateServerPlanRpo_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateServerPlanRpoResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.CreateServerPlanRpoResponse.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateServerPlanRpo" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="planId">Id of the Server Plan</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateServerPlanRpo_Validate(int planId, Commvault.Powershell.Models.ICreateServerPlanRpo body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateServerPlan" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateServerPlan_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateServerPlan" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateServerPlan_Validate(Commvault.Powershell.Models.ICreateServerPlan body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a User</summary>
        /// <param name="body">Used to create single or multiple users.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateUser(Commvault.Powershell.Models.ICreateUsers body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateUserResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/user"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateUser_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Create a new user-group</summary>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateUserGroup(Commvault.Powershell.Models.ICreateUserGroup body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/UserGroup"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateUserGroup_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateUserGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateUserGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.IdName.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateUserGroup" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateUserGroup_Validate(Commvault.Powershell.Models.ICreateUserGroup body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateUser" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateUser_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateUserResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.CreateUserResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateUser" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="body">Used to create single or multiple users.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateUser_Validate(Commvault.Powershell.Models.ICreateUsers body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Create a VM Group</summary>
        /// <param name="body">CreatevmGroupReq</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CreateVMGroup(Commvault.Powershell.Models.ICreatevmGroupReq body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateVMGroupResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VMGroup"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CreateVMGroup_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="CreateVMGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateVMGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateVMGroupResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.CreateVMGroupResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CreateVMGroup" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">CreatevmGroupReq</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CreateVMGroup_Validate(Commvault.Powershell.Models.ICreatevmGroupReq body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Disassociate a MediaAgent (cloud Access Path) from a bucket of a cloud storage</summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="bucketId">Id of Bucket</param>
        /// <param name="accessPathId">Id of access path (can be fetched from GET Bucket Details API)</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteAccessPathForBucketOfCloudStorage(int cloudStorageId, int bucketId, int accessPathId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + (cloudStorageId.ToString())
                        + "/Bucket/"
                        + (bucketId.ToString())
                        + "/AccessPath/"
                        + (accessPathId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteAccessPathForBucketOfCloudStorage_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Disassociate a MediaAgent (cloud Access Path) from a bucket of a cloud storage</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteAccessPathForBucketOfCloudStorageViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Cloud/(?<cloudStorageId>[^/]+)/Bucket/(?<bucketId>[^/]+)/AccessPath/(?<accessPathId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Cloud/{cloudStorageId}/Bucket/{bucketId}/AccessPath/{accessPathId}'");
                }

                // replace URI parameters with values from identity
                var cloudStorageId = _match.Groups["cloudStorageId"].Value;
                var bucketId = _match.Groups["bucketId"].Value;
                var accessPathId = _match.Groups["accessPathId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + cloudStorageId
                        + "/Bucket/"
                        + bucketId
                        + "/AccessPath/"
                        + accessPathId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteAccessPathForBucketOfCloudStorage_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref="DeleteAccessPathForBucketOfCloudStorage" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteAccessPathForBucketOfCloudStorage_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteAccessPathForBucketOfCloudStorage" /> method. Call this like the actual call, but
        /// you will get validation events back.
        /// </summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="bucketId">Id of Bucket</param>
        /// <param name="accessPathId">Id of access path (can be fetched from GET Bucket Details API)</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteAccessPathForBucketOfCloudStorage_Validate(int cloudStorageId, int bucketId, int accessPathId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Delete an AD/LDAP domain</summary>
        /// <param name="domainId">ID of the AD/LDAP domain</param>
        /// <param name="transferToUserId">Optionally transfer the ownership to user</param>
        /// <param name="transferToUserGroupId">Optionally transfer the ownership to user group</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteAdldap(int domainId, int? transferToUserId, int? transferToUserGroupId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LDAP/"
                        + (domainId.ToString())
                        + "?"
                        + (null == transferToUserId ? global::System.String.Empty : "transferToUserId=" + global::System.Uri.EscapeDataString(transferToUserId.ToString()))
                        + "&"
                        + (null == transferToUserGroupId ? global::System.String.Empty : "transferToUserGroupId=" + global::System.Uri.EscapeDataString(transferToUserGroupId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteAdldap_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Delete an AD/LDAP domain</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="transferToUserId">Optionally transfer the ownership to user</param>
        /// <param name="transferToUserGroupId">Optionally transfer the ownership to user group</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteAdldapViaIdentity(global::System.String viaIdentity, int? transferToUserId, int? transferToUserGroupId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/LDAP/(?<domainId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/LDAP/{domainId}'");
                }

                // replace URI parameters with values from identity
                var domainId = _match.Groups["domainId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LDAP/"
                        + domainId
                        + "?"
                        + (null == transferToUserId ? global::System.String.Empty : "transferToUserId=" + global::System.Uri.EscapeDataString(transferToUserId.ToString()))
                        + "&"
                        + (null == transferToUserGroupId ? global::System.String.Empty : "transferToUserGroupId=" + global::System.Uri.EscapeDataString(transferToUserGroupId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteAdldap_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteAdldap" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteAdldap_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteAdldap" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="domainId">ID of the AD/LDAP domain</param>
        /// <param name="transferToUserId">Optionally transfer the ownership to user</param>
        /// <param name="transferToUserGroupId">Optionally transfer the ownership to user group</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteAdldap_Validate(int domainId, int? transferToUserId, int? transferToUserGroupId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Delete alert definitions</summary>
        /// <param name="id"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteAlertDefinitions(int id, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AlertDefinitions/"
                        + (id.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteAlertDefinitions_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Delete alert definitions</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteAlertDefinitionsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/AlertDefinitions/(?<id>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/AlertDefinitions/{id}'");
                }

                // replace URI parameters with values from identity
                var id = _match.Groups["id"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AlertDefinitions/"
                        + id

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteAlertDefinitions_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteAlertDefinitions" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteAlertDefinitions_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteAlertDefinitions" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteAlertDefinitions_Validate(int id, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Delete Backup Destination for a Plan</summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="backupDestinationId">Id of the backupDestination to be deleted</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onPreconditionFailed">a delegate that is called when the remote service returns 412 (PreconditionFailed).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteArchiveBackupDestination(int planId, int backupDestinationId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onPreconditionFailed, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + (planId.ToString())
                        + "/BackupDestination/"
                        + (backupDestinationId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteArchiveBackupDestination_Call(request,onOk,onNotFound,onPreconditionFailed,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Delete Backup Destination for a Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onPreconditionFailed">a delegate that is called when the remote service returns 412 (PreconditionFailed).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteArchiveBackupDestinationViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onPreconditionFailed, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ArchivePlan/(?<planId>[^/]+)/BackupDestination/(?<BackupDestinationId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ArchivePlan/{planId}/BackupDestination/{BackupDestinationId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                var backupDestinationId = _match.Groups["BackupDestinationId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + planId
                        + "/BackupDestination/"
                        + backupDestinationId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteArchiveBackupDestination_Call(request,onOk,onNotFound,onPreconditionFailed,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteArchiveBackupDestination" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onPreconditionFailed">a delegate that is called when the remote service returns 412 (PreconditionFailed).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteArchiveBackupDestination_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onPreconditionFailed, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.PreconditionFailed:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onPreconditionFailed(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteArchiveBackupDestination" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="backupDestinationId">Id of the backupDestination to be deleted</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteArchiveBackupDestination_Validate(int planId, int backupDestinationId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Delete existing archive plan</summary>
        /// <param name="planId">Id of the plan</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteArchivePlanById(int planId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + (planId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteArchivePlanById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Delete existing archive plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteArchivePlanByIdViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ArchivePlan/(?<planId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ArchivePlan/{planId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + planId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteArchivePlanById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteArchivePlanById" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteArchivePlanById_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteArchivePlanById" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="planId">Id of the plan</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteArchivePlanById_Validate(int planId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Delete Backup Destination for a Plan</summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="backupDestinationId">Id of the backupDestination to be deleted</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onPreconditionFailed">a delegate that is called when the remote service returns 412 (PreconditionFailed).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteBackupDestination(int planId, int backupDestinationId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onPreconditionFailed, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + (planId.ToString())
                        + "/BackupDestination/"
                        + (backupDestinationId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteBackupDestination_Call(request,onOk,onNotFound,onPreconditionFailed,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Delete Backup Destination for a Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onPreconditionFailed">a delegate that is called when the remote service returns 412 (PreconditionFailed).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteBackupDestinationViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onPreconditionFailed, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerPlan/(?<planId>[^/]+)/BackupDestination/(?<BackupDestinationId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerPlan/{planId}/BackupDestination/{BackupDestinationId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                var backupDestinationId = _match.Groups["BackupDestinationId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + planId
                        + "/BackupDestination/"
                        + backupDestinationId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteBackupDestination_Call(request,onOk,onNotFound,onPreconditionFailed,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteBackupDestination" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onPreconditionFailed">a delegate that is called when the remote service returns 412 (PreconditionFailed).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteBackupDestination_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onPreconditionFailed, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.PreconditionFailed:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onPreconditionFailed(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteBackupDestination" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="backupDestinationId">Id of the backupDestination to be deleted</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteBackupDestination_Validate(int planId, int backupDestinationId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Modify the properties of an existing mount path</summary>
        /// <param name="storagePoolId">Id of the disk storage to whose backup location has to be deleted</param>
        /// <param name="backupLocationId">Id of the backup location to delete</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteBackupLocation(int storagePoolId, int backupLocationId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + (storagePoolId.ToString())
                        + "/BackupLocation/"
                        + (backupLocationId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteBackupLocation_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Modify the properties of an existing mount path</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteBackupLocationViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Disk/(?<storagePoolId>[^/]+)/BackupLocation/(?<backupLocationId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Disk/{storagePoolId}/BackupLocation/{backupLocationId}'");
                }

                // replace URI parameters with values from identity
                var storagePoolId = _match.Groups["storagePoolId"].Value;
                var backupLocationId = _match.Groups["backupLocationId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + storagePoolId
                        + "/BackupLocation/"
                        + backupLocationId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteBackupLocation_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteBackupLocation" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteBackupLocation_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteBackupLocation" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="storagePoolId">Id of the disk storage to whose backup location has to be deleted</param>
        /// <param name="backupLocationId">Id of the backup location to delete</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteBackupLocation_Validate(int storagePoolId, int backupLocationId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to delete a Blackout Window</summary>
        /// <param name="blackoutWindowId">Id of the Blackout Window to delete</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteBlackoutWindow(int blackoutWindowId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/BlackoutWindow/"
                        + (blackoutWindowId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteBlackoutWindow_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Used to delete a Blackout Window</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteBlackoutWindowViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/BlackoutWindow/(?<blackoutWindowId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/BlackoutWindow/{blackoutWindowId}'");
                }

                // replace URI parameters with values from identity
                var blackoutWindowId = _match.Groups["blackoutWindowId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/BlackoutWindow/"
                        + blackoutWindowId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteBlackoutWindow_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteBlackoutWindow" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteBlackoutWindow_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteBlackoutWindow" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="blackoutWindowId">Id of the Blackout Window to delete</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteBlackoutWindow_Validate(int blackoutWindowId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Delete the specified bucket of the cloud storage</summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="bucketId">Id of Bucket</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteBucketOfCloudStorage(int cloudStorageId, int bucketId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + (cloudStorageId.ToString())
                        + "/Bucket/"
                        + (bucketId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteBucketOfCloudStorage_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Delete the specified bucket of the cloud storage</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteBucketOfCloudStorageViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Cloud/(?<cloudStorageId>[^/]+)/Bucket/(?<bucketId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Cloud/{cloudStorageId}/Bucket/{bucketId}'");
                }

                // replace URI parameters with values from identity
                var cloudStorageId = _match.Groups["cloudStorageId"].Value;
                var bucketId = _match.Groups["bucketId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + cloudStorageId
                        + "/Bucket/"
                        + bucketId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteBucketOfCloudStorage_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteBucketOfCloudStorage" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteBucketOfCloudStorage_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteBucketOfCloudStorage" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="bucketId">Id of Bucket</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteBucketOfCloudStorage_Validate(int cloudStorageId, int bucketId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>API is used to delete multiple laptopowner mappings</summary>
        /// <param name="body">List of laptop owner mappings ids which needs to be deleted</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteBulkLaptopOwnerMappingActionDelete(Commvault.Powershell.Models.IDeleteLaptopOwnerMapping body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopOwnerMapping/action/delete"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteBulkLaptopOwnerMappingActionDelete_Call(request,onOk,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref="DeleteBulkLaptopOwnerMappingActionDelete" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteBulkLaptopOwnerMappingActionDelete_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.ServiceUnavailable:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onServiceUnavailable(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteBulkLaptopOwnerMappingActionDelete" /> method. Call this like the actual call,
        /// but you will get validation events back.
        /// </summary>
        /// <param name="body">List of laptop owner mappings ids which needs to be deleted</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteBulkLaptopOwnerMappingActionDelete_Validate(Commvault.Powershell.Models.IDeleteLaptopOwnerMapping body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Delete metadata cache of an existing cloud storage</summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="metadataCacheId">Id of metadata cache</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteCloudStorageMetadataCacheById(int cloudStorageId, int metadataCacheId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + (cloudStorageId.ToString())
                        + "/MetadataCache/"
                        + (metadataCacheId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteCloudStorageMetadataCacheById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Delete metadata cache of an existing cloud storage</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteCloudStorageMetadataCacheByIdViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Cloud/(?<cloudStorageId>[^/]+)/MetadataCache/(?<metadataCacheId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Cloud/{cloudStorageId}/MetadataCache/{metadataCacheId}'");
                }

                // replace URI parameters with values from identity
                var cloudStorageId = _match.Groups["cloudStorageId"].Value;
                var metadataCacheId = _match.Groups["metadataCacheId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + cloudStorageId
                        + "/MetadataCache/"
                        + metadataCacheId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteCloudStorageMetadataCacheById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteCloudStorageMetadataCacheById" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteCloudStorageMetadataCacheById_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteCloudStorageMetadataCacheById" /> method. Call this like the actual call, but you
        /// will get validation events back.
        /// </summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="metadataCacheId">Id of metadata cache</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteCloudStorageMetadataCacheById_Validate(int cloudStorageId, int metadataCacheId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to delete a company which has been deactivated</summary>
        /// <param name="companyId">Id of the company to delete</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteCompany(int companyId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/company/"
                        + (companyId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteCompany_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Used to delete a company which has been deactivated</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteCompanyViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/company/(?<companyId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/company/{companyId}'");
                }

                // replace URI parameters with values from identity
                var companyId = _match.Groups["companyId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/company/"
                        + companyId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteCompany_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteCompany" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteCompany_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteCompany" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="companyId">Id of the company to delete</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteCompany_Validate(int companyId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Delete Credential whose name has been provided</summary>
        /// <param name="credentialName"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteCredential(string credentialName, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Credential/"
                        + global::System.Uri.EscapeDataString(credentialName)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteCredential_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Delete Credential whose name has been provided</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteCredentialViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Credential/(?<credentialName>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Credential/{credentialName}'");
                }

                // replace URI parameters with values from identity
                var credentialName = _match.Groups["credentialName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Credential/"
                        + credentialName

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteCredential_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteCredential" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteCredential_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteCredential" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="credentialName"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteCredential_Validate(string credentialName, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(credentialName),credentialName);
            }
        }

        /// <summary>Used to delete a media agent to a disk access path</summary>
        /// <param name="storagePoolId">Id of the disk storage pool whose access path has to be deleted</param>
        /// <param name="backupLocationId">Id of the mount path whose access path has to be deleted</param>
        /// <param name="accessPathId">Id of the mount path whose access path has to be deleted</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteDiskAccessPath(int storagePoolId, int backupLocationId, int accessPathId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + (storagePoolId.ToString())
                        + "/BackupLocation/"
                        + (backupLocationId.ToString())
                        + "/AccessPath/"
                        + (accessPathId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteDiskAccessPath_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Used to delete a media agent to a disk access path</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteDiskAccessPathViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Disk/(?<storagePoolId>[^/]+)/BackupLocation/(?<backupLocationId>[^/]+)/AccessPath/(?<accessPathId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Disk/{storagePoolId}/BackupLocation/{backupLocationId}/AccessPath/{accessPathId}'");
                }

                // replace URI parameters with values from identity
                var storagePoolId = _match.Groups["storagePoolId"].Value;
                var backupLocationId = _match.Groups["backupLocationId"].Value;
                var accessPathId = _match.Groups["accessPathId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + storagePoolId
                        + "/BackupLocation/"
                        + backupLocationId
                        + "/AccessPath/"
                        + accessPathId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteDiskAccessPath_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteDiskAccessPath" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteDiskAccessPath_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteDiskAccessPath" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="storagePoolId">Id of the disk storage pool whose access path has to be deleted</param>
        /// <param name="backupLocationId">Id of the mount path whose access path has to be deleted</param>
        /// <param name="accessPathId">Id of the mount path whose access path has to be deleted</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteDiskAccessPath_Validate(int storagePoolId, int backupLocationId, int accessPathId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to delete a disk storage pool</summary>
        /// <param name="storagePoolId">Id of the disk storage pool to delete</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteDiskStorage(int storagePoolId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + (storagePoolId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteDiskStorage_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Used to delete a disk storage pool</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteDiskStorageViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Disk/(?<storagePoolId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Disk/{storagePoolId}'");
                }

                // replace URI parameters with values from identity
                var storagePoolId = _match.Groups["storagePoolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + storagePoolId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteDiskStorage_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteDiskStorage" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteDiskStorage_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteDiskStorage" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="storagePoolId">Id of the disk storage pool to delete</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteDiskStorage_Validate(int storagePoolId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>This endpoint is used to delete network topology.</summary>
        /// <param name="topologyId"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteFirewallTopology(string topologyId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/NetworkTopology/"
                        + global::System.Uri.EscapeDataString(topologyId)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteFirewallTopology_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>This endpoint is used to delete network topology.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteFirewallTopologyViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/NetworkTopology/(?<topologyId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/NetworkTopology/{topologyId}'");
                }

                // replace URI parameters with values from identity
                var topologyId = _match.Groups["topologyId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/NetworkTopology/"
                        + topologyId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteFirewallTopology_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteFirewallTopology" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteFirewallTopology_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteFirewallTopology" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="topologyId"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteFirewallTopology_Validate(string topologyId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(topologyId),topologyId);
            }
        }

        /// <summary>Delete existing hyperscale storage</summary>
        /// <param name="hyperScaleStorageId">Id of hyperscale storage</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteHyperScaleStorageById(int hyperScaleStorageId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/HyperScale/"
                        + (hyperScaleStorageId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteHyperScaleStorageById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Delete existing hyperscale storage</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteHyperScaleStorageByIdViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/HyperScale/(?<hyperScaleStorageId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/HyperScale/{hyperScaleStorageId}'");
                }

                // replace URI parameters with values from identity
                var hyperScaleStorageId = _match.Groups["hyperScaleStorageId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/HyperScale/"
                        + hyperScaleStorageId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteHyperScaleStorageById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteHyperScaleStorageById" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteHyperScaleStorageById_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteHyperScaleStorageById" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="hyperScaleStorageId">Id of hyperscale storage</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteHyperScaleStorageById_Validate(int hyperScaleStorageId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>delete an existing vm group</summary>
        /// <param name="hypervisorId">Id of the Hypervisor to delete</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteHypervisor(int hypervisorId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Hypervisor/"
                        + (hypervisorId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteHypervisor_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>delete an existing vm group</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteHypervisorViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Hypervisor/(?<hypervisorId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Hypervisor/{hypervisorId}'");
                }

                // replace URI parameters with values from identity
                var hypervisorId = _match.Groups["hypervisorId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Hypervisor/"
                        + hypervisorId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteHypervisor_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteHypervisor" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteHypervisor_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteHypervisor" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="hypervisorId">Id of the Hypervisor to delete</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteHypervisor_Validate(int hypervisorId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Delete key management server based on Id</summary>
        /// <param name="kmsId">Id of Key Management Server</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteKeyManagementServers(int kmsId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/KeyManagementServers/"
                        + (kmsId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteKeyManagementServers_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Delete key management server based on Id</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteKeyManagementServersViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/KeyManagementServers/(?<kmsId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/KeyManagementServers/{kmsId}'");
                }

                // replace URI parameters with values from identity
                var kmsId = _match.Groups["kmsId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/KeyManagementServers/"
                        + kmsId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteKeyManagementServers_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteKeyManagementServers" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteKeyManagementServers_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteKeyManagementServers" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="kmsId">Id of Key Management Server</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteKeyManagementServers_Validate(int kmsId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Delete Backup Destination for a Plan</summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="backupDestinationId">Id of the backupDestination to be deleted</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onPreconditionFailed">a delegate that is called when the remote service returns 412 (PreconditionFailed).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteLaptopBackupDestination(int planId, int backupDestinationId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onPreconditionFailed, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + (planId.ToString())
                        + "/BackupDestination/"
                        + (backupDestinationId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteLaptopBackupDestination_Call(request,onOk,onNotFound,onPreconditionFailed,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Delete Backup Destination for a Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onPreconditionFailed">a delegate that is called when the remote service returns 412 (PreconditionFailed).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteLaptopBackupDestinationViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onPreconditionFailed, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/LaptopPlan/(?<planId>[^/]+)/BackupDestination/(?<BackupDestinationId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/LaptopPlan/{planId}/BackupDestination/{BackupDestinationId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                var backupDestinationId = _match.Groups["BackupDestinationId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + planId
                        + "/BackupDestination/"
                        + backupDestinationId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteLaptopBackupDestination_Call(request,onOk,onNotFound,onPreconditionFailed,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteLaptopBackupDestination" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onPreconditionFailed">a delegate that is called when the remote service returns 412 (PreconditionFailed).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteLaptopBackupDestination_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onPreconditionFailed, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.PreconditionFailed:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onPreconditionFailed(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteLaptopBackupDestination" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="backupDestinationId">Id of the backupDestination to be deleted</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteLaptopBackupDestination_Validate(int planId, int backupDestinationId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Delete existing laptop plan</summary>
        /// <param name="planId">Id of the plan</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteLaptopPlanById(int planId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + (planId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteLaptopPlanById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Delete existing laptop plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteLaptopPlanByIdViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/LaptopPlan/(?<planId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/LaptopPlan/{planId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + planId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteLaptopPlanById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteLaptopPlanById" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteLaptopPlanById_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteLaptopPlanById" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="planId">Id of the plan</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteLaptopPlanById_Validate(int planId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to delete a media agent.</summary>
        /// <param name="mediaAgentId">Id of the media agent to delete</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteMediaAgent(int mediaAgentId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/mediaAgent/"
                        + (mediaAgentId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteMediaAgent_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Used to delete a media agent.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteMediaAgentViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/mediaAgent/(?<mediaAgentId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/mediaAgent/{mediaAgentId}'");
                }

                // replace URI parameters with values from identity
                var mediaAgentId = _match.Groups["mediaAgentId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/mediaAgent/"
                        + mediaAgentId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteMediaAgent_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteMediaAgent" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteMediaAgent_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteMediaAgent" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="mediaAgentId">Id of the media agent to delete</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteMediaAgent_Validate(int mediaAgentId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Delete multiple triggered alerts</summary>
        /// <param name="body">Array of ids of an entity</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteMultipleTriggeredalerts(Commvault.Powershell.Models.IAlertIds body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/TriggeredAlerts/Action/Delete"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteMultipleTriggeredalerts_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteMultipleTriggeredalerts" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteMultipleTriggeredalerts_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteMultipleTriggeredalerts" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="body">Array of ids of an entity</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteMultipleTriggeredalerts_Validate(Commvault.Powershell.Models.IAlertIds body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Delete multiple userGroups</summary>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteMultipleUserGroups(Commvault.Powershell.Models.IDeleteMultipleUserGroups body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/UserGroup/action/delete"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteMultipleUserGroups_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteMultipleUserGroups" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteMultipleUserGroups_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteMultipleUserGroups" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteMultipleUserGroups_Validate(Commvault.Powershell.Models.IDeleteMultipleUserGroups body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Delete multiple users</summary>
        /// <param name="body">Used to delete multiple users and carry out property transfership of deleted users</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteMultipleUsers(Commvault.Powershell.Models.IDeleteMultipleUsers body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/user/action/delete"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteMultipleUsers_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteMultipleUsers" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteMultipleUsers_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteMultipleUsers" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">Used to delete multiple users and carry out property transfership of deleted users</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteMultipleUsers_Validate(Commvault.Powershell.Models.IDeleteMultipleUsers body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Used to delete an existing server plan</summary>
        /// <param name="planId">Id of the plan to delete</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeletePlan(int planId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + (planId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeletePlan_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Api to delete selected plan rule</summary>
        /// <param name="ruleId">Id of the rule to update in Plan</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeletePlanRule(int ruleId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule/"
                        + (ruleId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeletePlanRule_Call(request,onOk,onBadRequest,onForbidden,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Api to delete selected plan rule</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeletePlanRuleViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Plan/Rule/(?<ruleId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Plan/Rule/{ruleId}'");
                }

                // replace URI parameters with values from identity
                var ruleId = _match.Groups["ruleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule/"
                        + ruleId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeletePlanRule_Call(request,onOk,onBadRequest,onForbidden,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeletePlanRule" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeletePlanRule_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Forbidden:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onForbidden(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeletePlanRule" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="ruleId">Id of the rule to update in Plan</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeletePlanRule_Validate(int ruleId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to delete an existing server plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeletePlanViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerPlan/(?<planId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerPlan/{planId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + planId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeletePlan_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeletePlan" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeletePlan_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeletePlan" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="planId">Id of the plan to delete</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeletePlan_Validate(int planId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Delete a specific recovery point store</summary>
        /// <param name="rpsId"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteRecoveryPointStores(string rpsId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RecoveryPointStore/"
                        + global::System.Uri.EscapeDataString(rpsId)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteRecoveryPointStores_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Delete a specific recovery point store</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteRecoveryPointStoresViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/RecoveryPointStore/(?<rpsId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/RecoveryPointStore/{rpsId}'");
                }

                // replace URI parameters with values from identity
                var rpsId = _match.Groups["rpsId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RecoveryPointStore/"
                        + rpsId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteRecoveryPointStores_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteRecoveryPointStores" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteRecoveryPointStores_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteRecoveryPointStores" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="rpsId"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteRecoveryPointStores_Validate(string rpsId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(rpsId),rpsId);
            }
        }

        /// <summary>To delete an exisitng recovery target</summary>
        /// <param name="recoveryTargetId">id of recovery target</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteRecoveryTarget(int recoveryTargetId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RecoveryTarget/"
                        + (recoveryTargetId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteRecoveryTarget_Call(request,onOk,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>To delete an exisitng recovery target</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteRecoveryTargetViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/RecoveryTarget/(?<recoveryTargetId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/RecoveryTarget/{recoveryTargetId}'");
                }

                // replace URI parameters with values from identity
                var recoveryTargetId = _match.Groups["recoveryTargetId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RecoveryTarget/"
                        + recoveryTargetId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteRecoveryTarget_Call(request,onOk,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteRecoveryTarget" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteRecoveryTarget_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.ServiceUnavailable:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onServiceUnavailable(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteRecoveryTarget" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="recoveryTargetId">id of recovery target</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteRecoveryTarget_Validate(int recoveryTargetId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Delete the region</summary>
        /// <param name="regionId"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteRegion(string regionId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Regions/"
                        + global::System.Uri.EscapeDataString(regionId)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteRegion_Call(request,onOk,onBadRequest,eventListener,sender);
            }
        }

        /// <summary>Delete the region</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteRegionViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Regions/(?<regionId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Regions/{regionId}'");
                }

                // replace URI parameters with values from identity
                var regionId = _match.Groups["regionId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Regions/"
                        + regionId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteRegion_Call(request,onOk,onBadRequest,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteRegion" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteRegion_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteRegion" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="regionId"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteRegion_Validate(string regionId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(regionId),regionId);
            }
        }

        /// <summary>Used to delete a replication group</summary>
        /// <param name="replicationGroupId"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteReplicationGroup(string replicationGroupId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ReplicationGroup/"
                        + global::System.Uri.EscapeDataString(replicationGroupId)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteReplicationGroup_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Used to delete a replication group</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteReplicationGroupViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ReplicationGroup/(?<replicationGroupId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ReplicationGroup/{replicationGroupId}'");
                }

                // replace URI parameters with values from identity
                var replicationGroupId = _match.Groups["replicationGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ReplicationGroup/"
                        + replicationGroupId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteReplicationGroup_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteReplicationGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteReplicationGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteReplicationGroup" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="replicationGroupId"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteReplicationGroup_Validate(string replicationGroupId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(replicationGroupId),replicationGroupId);
            }
        }

        /// <summary>Deleting an existing request</summary>
        /// <param name="requestId">Unique identifier for the request</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteRequestManagerRequest(int requestId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RequestManager/Request/"
                        + (requestId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteRequestManagerRequest_Call(request,onOk,onBadRequest,onForbidden,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Deleting an existing request</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteRequestManagerRequestViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/RequestManager/Request/(?<requestId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/RequestManager/Request/{requestId}'");
                }

                // replace URI parameters with values from identity
                var requestId = _match.Groups["requestId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RequestManager/Request/"
                        + requestId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteRequestManagerRequest_Call(request,onOk,onBadRequest,onForbidden,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteRequestManagerRequest" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteRequestManagerRequest_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Forbidden:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onForbidden(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteRequestManagerRequest" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="requestId">Unique identifier for the request</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteRequestManagerRequest_Validate(int requestId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertIsGreaterThanOrEqual(nameof(requestId),requestId,1);
            }
        }

        /// <summary>Used to delete a role</summary>
        /// <param name="roleId">Role Id</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteRoles(int roleId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Role/"
                        + (roleId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteRoles_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Used to delete a role</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteRolesViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Role/(?<roleId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Role/{roleId}'");
                }

                // replace URI parameters with values from identity
                var roleId = _match.Groups["roleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Role/"
                        + roleId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteRoles_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteRoles" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteRoles_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteRoles" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="roleId">Role Id</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteRoles_Validate(int roleId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to delete a serverGroup</summary>
        /// <param name="serverGroupId">Id of the serverGroup to delete</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteServerGroup(int serverGroupId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + (serverGroupId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteServerGroup_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Used to delete a serverGroup</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteServerGroupViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerGroup/(?<serverGroupId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerGroup/{serverGroupId}'");
                }

                // replace URI parameters with values from identity
                var serverGroupId = _match.Groups["serverGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + serverGroupId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteServerGroup_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteServerGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteServerGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteServerGroup" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="serverGroupId">Id of the serverGroup to delete</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteServerGroup_Validate(int serverGroupId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Delete Storage Region for an Elastic Plan</summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="regionList">List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true</param>
        /// <param name="isRegionIdList">Is regionList a list of region ids</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteStorageRegion(int planId, string regionList, bool? isRegionIdList, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + (planId.ToString())
                        + "/storageRegion/"
                        + global::System.Uri.EscapeDataString(regionList)
                        + "?"
                        + (null == isRegionIdList ? global::System.String.Empty : "isRegionIdList=" + global::System.Uri.EscapeDataString(isRegionIdList.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteStorageRegion_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Delete Storage Region for a archive Plan</summary>
        /// <param name="planId">Id of the Archive Plan to modify</param>
        /// <param name="regionList">List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true</param>
        /// <param name="isRegionIdList">Is regionList a list of region ids</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteStorageRegionForArchivePlan(int planId, string regionList, bool? isRegionIdList, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + (planId.ToString())
                        + "/storageRegion/"
                        + global::System.Uri.EscapeDataString(regionList)
                        + "?"
                        + (null == isRegionIdList ? global::System.String.Empty : "isRegionIdList=" + global::System.Uri.EscapeDataString(isRegionIdList.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteStorageRegionForArchivePlan_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Delete Storage Region for a archive Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="isRegionIdList">Is regionList a list of region ids</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteStorageRegionForArchivePlanViaIdentity(global::System.String viaIdentity, bool? isRegionIdList, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ArchivePlan/(?<planId>[^/]+)/storageRegion/(?<regionList>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ArchivePlan/{planId}/storageRegion/{regionList}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                var regionList = _match.Groups["regionList"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + planId
                        + "/storageRegion/"
                        + regionList
                        + "?"
                        + (null == isRegionIdList ? global::System.String.Empty : "isRegionIdList=" + global::System.Uri.EscapeDataString(isRegionIdList.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteStorageRegionForArchivePlan_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteStorageRegionForArchivePlan" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteStorageRegionForArchivePlan_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteStorageRegionForArchivePlan" /> method. Call this like the actual call, but you
        /// will get validation events back.
        /// </summary>
        /// <param name="planId">Id of the Archive Plan to modify</param>
        /// <param name="regionList">List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true</param>
        /// <param name="isRegionIdList">Is regionList a list of region ids</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteStorageRegionForArchivePlan_Validate(int planId, string regionList, bool? isRegionIdList, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(regionList),regionList);
            }
        }

        /// <summary>Delete Storage Region for a laptop Plan</summary>
        /// <param name="planId">Id of the Laptop Plan to modify</param>
        /// <param name="regionList">List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true</param>
        /// <param name="isRegionIdList">Is regionList a list of region ids</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteStorageRegionForLaptopPlan(int planId, string regionList, bool? isRegionIdList, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + (planId.ToString())
                        + "/storageRegion/"
                        + global::System.Uri.EscapeDataString(regionList)
                        + "?"
                        + (null == isRegionIdList ? global::System.String.Empty : "isRegionIdList=" + global::System.Uri.EscapeDataString(isRegionIdList.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteStorageRegionForLaptopPlan_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Delete Storage Region for a laptop Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="isRegionIdList">Is regionList a list of region ids</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteStorageRegionForLaptopPlanViaIdentity(global::System.String viaIdentity, bool? isRegionIdList, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/LaptopPlan/(?<planId>[^/]+)/storageRegion/(?<regionList>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/LaptopPlan/{planId}/storageRegion/{regionList}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                var regionList = _match.Groups["regionList"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + planId
                        + "/storageRegion/"
                        + regionList
                        + "?"
                        + (null == isRegionIdList ? global::System.String.Empty : "isRegionIdList=" + global::System.Uri.EscapeDataString(isRegionIdList.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteStorageRegionForLaptopPlan_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteStorageRegionForLaptopPlan" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteStorageRegionForLaptopPlan_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteStorageRegionForLaptopPlan" /> method. Call this like the actual call, but you
        /// will get validation events back.
        /// </summary>
        /// <param name="planId">Id of the Laptop Plan to modify</param>
        /// <param name="regionList">List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true</param>
        /// <param name="isRegionIdList">Is regionList a list of region ids</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteStorageRegionForLaptopPlan_Validate(int planId, string regionList, bool? isRegionIdList, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(regionList),regionList);
            }
        }

        /// <summary>Delete Storage Region for an Elastic Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="isRegionIdList">Is regionList a list of region ids</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteStorageRegionViaIdentity(global::System.String viaIdentity, bool? isRegionIdList, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerPlan/(?<planId>[^/]+)/storageRegion/(?<regionList>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerPlan/{planId}/storageRegion/{regionList}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                var regionList = _match.Groups["regionList"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + planId
                        + "/storageRegion/"
                        + regionList
                        + "?"
                        + (null == isRegionIdList ? global::System.String.Empty : "isRegionIdList=" + global::System.Uri.EscapeDataString(isRegionIdList.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteStorageRegion_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteStorageRegion" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteStorageRegion_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteStorageRegion" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="regionList">List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true</param>
        /// <param name="isRegionIdList">Is regionList a list of region ids</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteStorageRegion_Validate(int planId, string regionList, bool? isRegionIdList, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(regionList),regionList);
            }
        }

        /// <summary>Delete Triggered Alerts</summary>
        /// <param name="id"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteTriggeredAlerts(int id, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/TriggeredAlerts/"
                        + (id.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteTriggeredAlerts_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Delete Triggered Alerts</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteTriggeredAlertsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/TriggeredAlerts/(?<id>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/TriggeredAlerts/{id}'");
                }

                // replace URI parameters with values from identity
                var id = _match.Groups["id"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/TriggeredAlerts/"
                        + id

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteTriggeredAlerts_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteTriggeredAlerts" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteTriggeredAlerts_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteTriggeredAlerts" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteTriggeredAlerts_Validate(int id, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to delete a user</summary>
        /// <param name="userId">Id of the user to delete</param>
        /// <param name="skipOwnerShipTransfer">If user properties needn't be transferred to other user or usergroup</param>
        /// <param name="transferToUser">If user properties needs to be transferred to other user</param>
        /// <param name="transfertoUserGroup">If user properties needs to be transferred to other userGroup</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteUser(int userId, bool? skipOwnerShipTransfer, int? transferToUser, int? transfertoUserGroup, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/user/"
                        + (userId.ToString())
                        + "?"
                        + (null == skipOwnerShipTransfer ? global::System.String.Empty : "skipOwnerShipTransfer=" + global::System.Uri.EscapeDataString(skipOwnerShipTransfer.ToString()))
                        + "&"
                        + (null == transferToUser ? global::System.String.Empty : "transferToUser=" + global::System.Uri.EscapeDataString(transferToUser.ToString()))
                        + "&"
                        + (null == transfertoUserGroup ? global::System.String.Empty : "transfertoUserGroup=" + global::System.Uri.EscapeDataString(transfertoUserGroup.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteUser_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Used to delete a user-group</summary>
        /// <param name="userGroupId">Id of the user-group to delete</param>
        /// <param name="skipOwnerShipTransfer">If user group properties needn't be transferred to other user or usergroup</param>
        /// <param name="transferToUser">If user group properties needs to be transferred to other user</param>
        /// <param name="transfertoUserGroup">If user group properties needs to be transferred to other userGroup</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteUserGroup(int userGroupId, bool? skipOwnerShipTransfer, int? transferToUser, int? transfertoUserGroup, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/UserGroup/"
                        + (userGroupId.ToString())
                        + "?"
                        + (null == skipOwnerShipTransfer ? global::System.String.Empty : "skipOwnerShipTransfer=" + global::System.Uri.EscapeDataString(skipOwnerShipTransfer.ToString()))
                        + "&"
                        + (null == transferToUser ? global::System.String.Empty : "transferToUser=" + global::System.Uri.EscapeDataString(transferToUser.ToString()))
                        + "&"
                        + (null == transfertoUserGroup ? global::System.String.Empty : "transfertoUserGroup=" + global::System.Uri.EscapeDataString(transfertoUserGroup.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteUserGroup_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Used to delete a user-group</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="skipOwnerShipTransfer">If user group properties needn't be transferred to other user or usergroup</param>
        /// <param name="transferToUser">If user group properties needs to be transferred to other user</param>
        /// <param name="transfertoUserGroup">If user group properties needs to be transferred to other userGroup</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteUserGroupViaIdentity(global::System.String viaIdentity, bool? skipOwnerShipTransfer, int? transferToUser, int? transfertoUserGroup, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/UserGroup/(?<userGroupId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/UserGroup/{userGroupId}'");
                }

                // replace URI parameters with values from identity
                var userGroupId = _match.Groups["userGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/UserGroup/"
                        + userGroupId
                        + "?"
                        + (null == skipOwnerShipTransfer ? global::System.String.Empty : "skipOwnerShipTransfer=" + global::System.Uri.EscapeDataString(skipOwnerShipTransfer.ToString()))
                        + "&"
                        + (null == transferToUser ? global::System.String.Empty : "transferToUser=" + global::System.Uri.EscapeDataString(transferToUser.ToString()))
                        + "&"
                        + (null == transfertoUserGroup ? global::System.String.Empty : "transfertoUserGroup=" + global::System.Uri.EscapeDataString(transfertoUserGroup.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteUserGroup_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteUserGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteUserGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteUserGroup" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="userGroupId">Id of the user-group to delete</param>
        /// <param name="skipOwnerShipTransfer">If user group properties needn't be transferred to other user or usergroup</param>
        /// <param name="transferToUser">If user group properties needs to be transferred to other user</param>
        /// <param name="transfertoUserGroup">If user group properties needs to be transferred to other userGroup</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteUserGroup_Validate(int userGroupId, bool? skipOwnerShipTransfer, int? transferToUser, int? transfertoUserGroup, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to delete a user</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="skipOwnerShipTransfer">If user properties needn't be transferred to other user or usergroup</param>
        /// <param name="transferToUser">If user properties needs to be transferred to other user</param>
        /// <param name="transfertoUserGroup">If user properties needs to be transferred to other userGroup</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteUserViaIdentity(global::System.String viaIdentity, bool? skipOwnerShipTransfer, int? transferToUser, int? transfertoUserGroup, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/user/(?<userId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/user/{userId}'");
                }

                // replace URI parameters with values from identity
                var userId = _match.Groups["userId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/user/"
                        + userId
                        + "?"
                        + (null == skipOwnerShipTransfer ? global::System.String.Empty : "skipOwnerShipTransfer=" + global::System.Uri.EscapeDataString(skipOwnerShipTransfer.ToString()))
                        + "&"
                        + (null == transferToUser ? global::System.String.Empty : "transferToUser=" + global::System.Uri.EscapeDataString(transferToUser.ToString()))
                        + "&"
                        + (null == transfertoUserGroup ? global::System.String.Empty : "transfertoUserGroup=" + global::System.Uri.EscapeDataString(transfertoUserGroup.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteUser_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteUser" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteUser_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteUser" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="userId">Id of the user to delete</param>
        /// <param name="skipOwnerShipTransfer">If user properties needn't be transferred to other user or usergroup</param>
        /// <param name="transferToUser">If user properties needs to be transferred to other user</param>
        /// <param name="transfertoUserGroup">If user properties needs to be transferred to other userGroup</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteUser_Validate(int userId, bool? skipOwnerShipTransfer, int? transferToUser, int? transfertoUserGroup, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>delete an existing vm group</summary>
        /// <param name="vmGroupId">Id of the vmgroup to delete</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteVMGroup(int vmGroupId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VmGroup/"
                        + (vmGroupId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteVMGroup_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>delete an existing vm group</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteVMGroupViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/VmGroup/(?<VmGroupId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/VmGroup/{VmGroupId}'");
                }

                // replace URI parameters with values from identity
                var vmGroupId = _match.Groups["VmGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VmGroup/"
                        + vmGroupId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteVMGroup_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteVMGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteVMGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteVMGroup" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="vmGroupId">Id of the vmgroup to delete</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteVMGroup_Validate(int vmGroupId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to delete a virtual machine</summary>
        /// <param name="vmUuid">The vmUUID can be obtained from GET /virtualMachines UUID property</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteVirtualMachine(string vmUuid, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VirtualMachines/"
                        + global::System.Uri.EscapeDataString(vmUuid)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteVirtualMachine_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Used to delete a virtual machine</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DeleteVirtualMachineViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/VirtualMachines/(?<vmUUID>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/VirtualMachines/{vmUUID}'");
                }

                // replace URI parameters with values from identity
                var vmUuid = _match.Groups["vmUUID"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VirtualMachines/"
                        + vmUuid

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Delete, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DeleteVirtualMachine_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DeleteVirtualMachine" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteVirtualMachine_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DeleteVirtualMachine" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="vmUuid">The vmUUID can be obtained from GET /virtualMachines UUID property</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DeleteVirtualMachine_Validate(string vmUuid, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(vmUuid),vmUuid);
            }
        }

        /// <summary>Disable Alert Definition</summary>
        /// <param name="id"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableAlertDefinitions(int id, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AlertDefinitions/"
                        + (id.ToString())
                        + "/Disable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableAlertDefinitions_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Disable Alert Definition</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableAlertDefinitionsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/AlertDefinitions/(?<id>[^/]+)/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/AlertDefinitions/{id}/Disable'");
                }

                // replace URI parameters with values from identity
                var id = _match.Groups["id"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AlertDefinitions/"
                        + id
                        + "/Disable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableAlertDefinitions_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableAlertDefinitions" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableAlertDefinitions_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableAlertDefinitions" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableAlertDefinitions_Validate(int id, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable all job activity property for commcell</summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableAllJobActivityCommcell(int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/AllJobActivity/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableAllJobActivityCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable all job activity property for commcell</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableAllJobActivityCommcellViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Commcell/AllJobActivity/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Commcell/AllJobActivity/Action/Disable'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/AllJobActivity/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableAllJobActivityCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableAllJobActivityCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableAllJobActivityCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableAllJobActivityCommcell" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableAllJobActivityCommcell_Validate(int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable auxillary copy property for commcell</summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableAuxillaryCopyCommcell(int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/AuxillaryCopy/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableAuxillaryCopyCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable auxillary copy property for commcell</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableAuxillaryCopyCommcellViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Commcell/AuxillaryCopy/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Commcell/AuxillaryCopy/Action/Disable'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/AuxillaryCopy/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableAuxillaryCopyCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableAuxillaryCopyCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableAuxillaryCopyCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableAuxillaryCopyCommcell" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableAuxillaryCopyCommcell_Validate(int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>
        /// Used to disable backup property for an agent.
        /// Types of available agentIds are:
        /// 41-Active Directory,
        /// 21-AIX File System,
        /// 64-Big Data Apps,
        /// 134-Cloud Apps,
        /// 37-DB2,
        /// 103-DB2 MultiNode,
        /// 62-DB2 on Unix,
        /// 128-Documentum,
        /// 90-Domino Mailbox Archiver,
        /// 91-DPM,
        /// 67-Exchange Compliance Archiver,
        /// 53-Exchange Database,
        /// 45-Exchange Mailbox,
        /// 54-Exchange Mailbox (Classic),
        /// 56-Exchange Mailbox Archiver,
        /// 82-Exchange PF Archiver,
        /// 35-Exchange Public Folder,
        /// 73-File Share Archiver,
        /// 33-File System,
        /// 74-FreeBSD,
        /// 71-GroupWise DB,
        /// 17-HP-UX Files System,
        /// 65-Image Level,
        /// 75-Image Level On Unix,
        /// 76-Image Level ProxyHost,
        /// 87-Image Level ProxyHost on Unix,
        /// 3-Informix Database,
        /// 29-Linux File System,
        /// 89-MS SharePoint Archiver,
        /// 104-MySQL,
        /// 13-NAS,
        /// 83-Netware File Archiver,
        /// 12-Netware File System,
        /// 10-Novell Directory Services,
        /// 124-Object Link,
        /// 131-Object Store,
        /// 86-OES File System on Linux,
        /// 22-Oracle,
        /// 80-Oracle RAC,
        /// 130-Other External Agent,
        /// 125-PostgreSQL,
        /// 38-Proxy Client File System,
        /// 87-ProxyHost on Unix,
        /// 61-SAP for Oracle,
        /// 135-SAP HANA,
        /// 78-SharePoint Server,
        /// 20-Solaris 64bit File System,
        /// 19-Solaris File System,
        /// 81-SQL Server,
        /// 5-Sybase Database,
        /// 66-Unix File Archiver,
        /// 36-Unix Tru64 64-bit File System,
        /// 106-Virtual Server,
        /// 58- Windows File Archiver
        /// </summary>
        /// <param name="serverId">Id of the server to modify</param>
        /// <param name="agentId">Id of the agent to be modified</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableBackupAgent(int serverId, int agentId, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Server/"
                        + (serverId.ToString())
                        + "/Agent/"
                        + (agentId.ToString())
                        + "/Backup/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableBackupAgent_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>
        /// Used to disable backup property for an agent.
        /// Types of available agentIds are:
        /// 41-Active Directory,
        /// 21-AIX File System,
        /// 64-Big Data Apps,
        /// 134-Cloud Apps,
        /// 37-DB2,
        /// 103-DB2 MultiNode,
        /// 62-DB2 on Unix,
        /// 128-Documentum,
        /// 90-Domino Mailbox Archiver,
        /// 91-DPM,
        /// 67-Exchange Compliance Archiver,
        /// 53-Exchange Database,
        /// 45-Exchange Mailbox,
        /// 54-Exchange Mailbox (Classic),
        /// 56-Exchange Mailbox Archiver,
        /// 82-Exchange PF Archiver,
        /// 35-Exchange Public Folder,
        /// 73-File Share Archiver,
        /// 33-File System,
        /// 74-FreeBSD,
        /// 71-GroupWise DB,
        /// 17-HP-UX Files System,
        /// 65-Image Level,
        /// 75-Image Level On Unix,
        /// 76-Image Level ProxyHost,
        /// 87-Image Level ProxyHost on Unix,
        /// 3-Informix Database,
        /// 29-Linux File System,
        /// 89-MS SharePoint Archiver,
        /// 104-MySQL,
        /// 13-NAS,
        /// 83-Netware File Archiver,
        /// 12-Netware File System,
        /// 10-Novell Directory Services,
        /// 124-Object Link,
        /// 131-Object Store,
        /// 86-OES File System on Linux,
        /// 22-Oracle,
        /// 80-Oracle RAC,
        /// 130-Other External Agent,
        /// 125-PostgreSQL,
        /// 38-Proxy Client File System,
        /// 87-ProxyHost on Unix,
        /// 61-SAP for Oracle,
        /// 135-SAP HANA,
        /// 78-SharePoint Server,
        /// 20-Solaris 64bit File System,
        /// 19-Solaris File System,
        /// 81-SQL Server,
        /// 5-Sybase Database,
        /// 66-Unix File Archiver,
        /// 36-Unix Tru64 64-bit File System,
        /// 106-Virtual Server,
        /// 58- Windows File Archiver
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableBackupAgentViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Server/(?<serverId>[^/]+)/Agent/(?<agentId>[^/]+)/Backup/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Server/{serverId}/Agent/{agentId}/Backup/Action/Disable'");
                }

                // replace URI parameters with values from identity
                var serverId = _match.Groups["serverId"].Value;
                var agentId = _match.Groups["agentId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Server/"
                        + serverId
                        + "/Agent/"
                        + agentId
                        + "/Backup/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableBackupAgent_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableBackupAgent" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableBackupAgent_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableBackupAgent" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="serverId">Id of the server to modify</param>
        /// <param name="agentId">Id of the agent to be modified</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableBackupAgent_Validate(int serverId, int agentId, int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable backup property for commcell</summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableBackupCommcell(int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/Backup/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableBackupCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable backup property for commcell</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableBackupCommcellViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Commcell/Backup/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Commcell/Backup/Action/Disable'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/Backup/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableBackupCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableBackupCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableBackupCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableBackupCommcell" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableBackupCommcell_Validate(int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable backup property for an instance</summary>
        /// <param name="instanceId">Id of the instance to modify</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableBackupInstance(int instanceId, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Instance/"
                        + (instanceId.ToString())
                        + "/Backup/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableBackupInstance_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable backup property for an instance</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableBackupInstanceViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Instance/(?<instanceId>[^/]+)/Backup/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Instance/{instanceId}/Backup/Action/Disable'");
                }

                // replace URI parameters with values from identity
                var instanceId = _match.Groups["instanceId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Instance/"
                        + instanceId
                        + "/Backup/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableBackupInstance_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableBackupInstance" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableBackupInstance_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableBackupInstance" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="instanceId">Id of the instance to modify</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableBackupInstance_Validate(int instanceId, int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable backup property for a server group</summary>
        /// <param name="serverGroupId">Id of the serverGroup to modify</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableBackupServerGroup(int serverGroupId, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + (serverGroupId.ToString())
                        + "/Backup/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableBackupServerGroup_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable backup property for a server group</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableBackupServerGroupViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerGroup/(?<serverGroupId>[^/]+)/Backup/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerGroup/{serverGroupId}/Backup/Action/Disable'");
                }

                // replace URI parameters with values from identity
                var serverGroupId = _match.Groups["serverGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + serverGroupId
                        + "/Backup/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableBackupServerGroup_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableBackupServerGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableBackupServerGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableBackupServerGroup" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="serverGroupId">Id of the serverGroup to modify</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableBackupServerGroup_Validate(int serverGroupId, int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable backup property for a subclient</summary>
        /// <param name="subclientId">Id of the subclient to modify</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableBackupSubclient(int subclientId, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Subclient/"
                        + (subclientId.ToString())
                        + "/Backup/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableBackupSubclient_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable backup property for a subclient</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableBackupSubclientViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Subclient/(?<subclientId>[^/]+)/Backup/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Subclient/{subclientId}/Backup/Action/Disable'");
                }

                // replace URI parameters with values from identity
                var subclientId = _match.Groups["subclientId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Subclient/"
                        + subclientId
                        + "/Backup/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableBackupSubclient_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableBackupSubclient" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableBackupSubclient_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableBackupSubclient" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subclientId">Id of the subclient to modify</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableBackupSubclient_Validate(int subclientId, int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable content indexing property for commcell</summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableContentIndexingCommcell(int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/ContentIndexing/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableContentIndexingCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable content indexing property for commcell</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableContentIndexingCommcellViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Commcell/ContentIndexing/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Commcell/ContentIndexing/Action/Disable'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/ContentIndexing/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableContentIndexingCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableContentIndexingCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableContentIndexingCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableContentIndexingCommcell" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableContentIndexingCommcell_Validate(int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable data aging property for commcell</summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableDataAgingCommcell(int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/DataAging/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableDataAgingCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable data aging property for commcell</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableDataAgingCommcellViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Commcell/DataAging/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Commcell/DataAging/Action/Disable'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/DataAging/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableDataAgingCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableDataAgingCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableDataAgingCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableDataAgingCommcell" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableDataAgingCommcell_Validate(int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable data aging property for a server group</summary>
        /// <param name="serverGroupId">Id of the serverGroup to modify</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableDataAgingServerGroup(int serverGroupId, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + (serverGroupId.ToString())
                        + "/DataAging/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableDataAgingServerGroup_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable data aging property for a server group</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableDataAgingServerGroupViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerGroup/(?<serverGroupId>[^/]+)/DataAging/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerGroup/{serverGroupId}/DataAging/Action/Disable'");
                }

                // replace URI parameters with values from identity
                var serverGroupId = _match.Groups["serverGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + serverGroupId
                        + "/DataAging/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableDataAgingServerGroup_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableDataAgingServerGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableDataAgingServerGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableDataAgingServerGroup" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="serverGroupId">Id of the serverGroup to modify</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableDataAgingServerGroup_Validate(int serverGroupId, int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable data verification property for commcell</summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableDataVerificationCommcell(int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/DataVerification/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableDataVerificationCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable data verification property for commcell</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableDataVerificationCommcellViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Commcell/DataVerification/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Commcell/DataVerification/Action/Disable'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/DataVerification/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableDataVerificationCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableDataVerificationCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableDataVerificationCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableDataVerificationCommcell" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableDataVerificationCommcell_Validate(int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable DDB property for commcell</summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableDdbCommcell(int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/DDB/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableDdbCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable DDB property for commcell</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableDdbCommcellViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Commcell/DDB/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Commcell/DDB/Action/Disable'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/DDB/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableDdbCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableDdbCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableDdbCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableDdbCommcell" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableDdbCommcell_Validate(int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable log scrubbing</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableLogScrubbing(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/scrubLogs/Action/Disable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableLogScrubbing_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableLogScrubbing" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableLogScrubbing_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableLogScrubbing" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableLogScrubbing_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>
        /// Used to disable restore property for an agent
        /// Types of available agentIds are:
        /// 41-Active Directory,
        /// 21-AIX File System,
        /// 64-Big Data Apps,
        /// 134-Cloud Apps,
        /// 37-DB2,
        /// 103-DB2 MultiNode,
        /// 62-DB2 on Unix,
        /// 128-Documentum,
        /// 90-Domino Mailbox Archiver,
        /// 91-DPM,
        /// 67-Exchange Compliance Archiver,
        /// 53-Exchange Database,
        /// 45-Exchange Mailbox,
        /// 54-Exchange Mailbox (Classic),
        /// 56-Exchange Mailbox Archiver,
        /// 82-Exchange PF Archiver,
        /// 35-Exchange Public Folder,
        /// 73-File Share Archiver,
        /// 33-File System,
        /// 74-FreeBSD,
        /// 71-GroupWise DB,
        /// 17-HP-UX Files System,
        /// 65-Image Level,
        /// 75-Image Level On Unix,
        /// 76-Image Level ProxyHost,
        /// 87-Image Level ProxyHost on Unix,
        /// 3-Informix Database,
        /// 29-Linux File System,
        /// 89-MS SharePoint Archiver,
        /// 104-MySQL,
        /// 13-NAS,
        /// 83-Netware File Archiver,
        /// 12-Netware File System,
        /// 10-Novell Directory Services,
        /// 124-Object Link,
        /// 131-Object Store,
        /// 86-OES File System on Linux,
        /// 22-Oracle,
        /// 80-Oracle RAC,
        /// 130-Other External Agent,
        /// 125-PostgreSQL,
        /// 38-Proxy Client File System,
        /// 87-ProxyHost on Unix,
        /// 61-SAP for Oracle,
        /// 135-SAP HANA,
        /// 78-SharePoint Server,
        /// 20-Solaris 64bit File System,
        /// 19-Solaris File System,
        /// 81-SQL Server,
        /// 5-Sybase Database,
        /// 66-Unix File Archiver,
        /// 36-Unix Tru64 64-bit File System,
        /// 106-Virtual Server,
        /// 58- Windows File Archiver
        /// </summary>
        /// <param name="serverId">Id of the server to modify</param>
        /// <param name="agentId">Id of the agent to be modified</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableRestoreAgent(int serverId, int agentId, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Server/"
                        + (serverId.ToString())
                        + "/Agent/"
                        + (agentId.ToString())
                        + "/Restore/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableRestoreAgent_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>
        /// Used to disable restore property for an agent
        /// Types of available agentIds are:
        /// 41-Active Directory,
        /// 21-AIX File System,
        /// 64-Big Data Apps,
        /// 134-Cloud Apps,
        /// 37-DB2,
        /// 103-DB2 MultiNode,
        /// 62-DB2 on Unix,
        /// 128-Documentum,
        /// 90-Domino Mailbox Archiver,
        /// 91-DPM,
        /// 67-Exchange Compliance Archiver,
        /// 53-Exchange Database,
        /// 45-Exchange Mailbox,
        /// 54-Exchange Mailbox (Classic),
        /// 56-Exchange Mailbox Archiver,
        /// 82-Exchange PF Archiver,
        /// 35-Exchange Public Folder,
        /// 73-File Share Archiver,
        /// 33-File System,
        /// 74-FreeBSD,
        /// 71-GroupWise DB,
        /// 17-HP-UX Files System,
        /// 65-Image Level,
        /// 75-Image Level On Unix,
        /// 76-Image Level ProxyHost,
        /// 87-Image Level ProxyHost on Unix,
        /// 3-Informix Database,
        /// 29-Linux File System,
        /// 89-MS SharePoint Archiver,
        /// 104-MySQL,
        /// 13-NAS,
        /// 83-Netware File Archiver,
        /// 12-Netware File System,
        /// 10-Novell Directory Services,
        /// 124-Object Link,
        /// 131-Object Store,
        /// 86-OES File System on Linux,
        /// 22-Oracle,
        /// 80-Oracle RAC,
        /// 130-Other External Agent,
        /// 125-PostgreSQL,
        /// 38-Proxy Client File System,
        /// 87-ProxyHost on Unix,
        /// 61-SAP for Oracle,
        /// 135-SAP HANA,
        /// 78-SharePoint Server,
        /// 20-Solaris 64bit File System,
        /// 19-Solaris File System,
        /// 81-SQL Server,
        /// 5-Sybase Database,
        /// 66-Unix File Archiver,
        /// 36-Unix Tru64 64-bit File System,
        /// 106-Virtual Server,
        /// 58- Windows File Archiver
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableRestoreAgentViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Server/(?<serverId>[^/]+)/Agent/(?<agentId>[^/]+)/Restore/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Server/{serverId}/Agent/{agentId}/Restore/Action/Disable'");
                }

                // replace URI parameters with values from identity
                var serverId = _match.Groups["serverId"].Value;
                var agentId = _match.Groups["agentId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Server/"
                        + serverId
                        + "/Agent/"
                        + agentId
                        + "/Restore/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableRestoreAgent_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableRestoreAgent" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableRestoreAgent_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableRestoreAgent" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="serverId">Id of the server to modify</param>
        /// <param name="agentId">Id of the agent to be modified</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableRestoreAgent_Validate(int serverId, int agentId, int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable restore property for commcell</summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableRestoreCommcell(int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/Restore/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableRestoreCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable restore property for commcell</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableRestoreCommcellViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Commcell/Restore/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Commcell/Restore/Action/Disable'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/Restore/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableRestoreCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableRestoreCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableRestoreCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableRestoreCommcell" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableRestoreCommcell_Validate(int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable restore property for an instance</summary>
        /// <param name="instanceId">Id of the instance to modify</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableRestoreInstance(int instanceId, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Instance/"
                        + (instanceId.ToString())
                        + "/Restore/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableRestoreInstance_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable restore property for an instance</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableRestoreInstanceViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Instance/(?<instanceId>[^/]+)/Restore/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Instance/{instanceId}/Restore/Action/Disable'");
                }

                // replace URI parameters with values from identity
                var instanceId = _match.Groups["instanceId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Instance/"
                        + instanceId
                        + "/Restore/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableRestoreInstance_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableRestoreInstance" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableRestoreInstance_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableRestoreInstance" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="instanceId">Id of the instance to modify</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableRestoreInstance_Validate(int instanceId, int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable restore property for a server group</summary>
        /// <param name="serverGroupId">Id of the serverGroup to modify</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableRestoreServerGroup(int serverGroupId, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + (serverGroupId.ToString())
                        + "/Restore/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableRestoreServerGroup_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable restore property for a server group</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableRestoreServerGroupViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerGroup/(?<serverGroupId>[^/]+)/Restore/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerGroup/{serverGroupId}/Restore/Action/Disable'");
                }

                // replace URI parameters with values from identity
                var serverGroupId = _match.Groups["serverGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + serverGroupId
                        + "/Restore/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableRestoreServerGroup_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableRestoreServerGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableRestoreServerGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableRestoreServerGroup" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="serverGroupId">Id of the serverGroup to modify</param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableRestoreServerGroup_Validate(int serverGroupId, int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to disable scheduler property for commcell</summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableSchedulerCommcell(int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/Scheduler/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableSchedulerCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to disable scheduler property for commcell</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task DisableSchedulerCommcellViaIdentity(global::System.String viaIdentity, int? enableAfterADelay, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Commcell/Scheduler/Action/Disable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Commcell/Scheduler/Action/Disable'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/Scheduler/Action/Disable"
                        + "?"
                        + (null == enableAfterADelay ? global::System.String.Empty : "enableAfterADelay=" + global::System.Uri.EscapeDataString(enableAfterADelay.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.DisableSchedulerCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="DisableSchedulerCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableSchedulerCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="DisableSchedulerCommcell" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="enableAfterADelay">Provide UTC time in unix format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task DisableSchedulerCommcell_Validate(int? enableAfterADelay, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Edit Alert Definition details</summary>
        /// <param name="id"></param>
        /// <param name="body">AlertDefinitionsEdit</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EditAlertDefinitions(int id, Commvault.Powershell.Models.IAlertDefinitionsEdit body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AlertDefinitions/"
                        + (id.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EditAlertDefinitions_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Edit Alert Definition details</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">AlertDefinitionsEdit</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EditAlertDefinitionsViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IAlertDefinitionsEdit body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/AlertDefinitions/(?<id>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/AlertDefinitions/{id}'");
                }

                // replace URI parameters with values from identity
                var id = _match.Groups["id"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AlertDefinitions/"
                        + id

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EditAlertDefinitions_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EditAlertDefinitions" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EditAlertDefinitions_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EditAlertDefinitions" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="body">AlertDefinitionsEdit</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EditAlertDefinitions_Validate(int id, Commvault.Powershell.Models.IAlertDefinitionsEdit body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Enable Alert Definitions</summary>
        /// <param name="id"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableAlertDefinitions(int id, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AlertDefinitions/"
                        + (id.ToString())
                        + "/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableAlertDefinitions_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Enable Alert Definitions</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableAlertDefinitionsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/AlertDefinitions/(?<id>[^/]+)/Enable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/AlertDefinitions/{id}/Enable'");
                }

                // replace URI parameters with values from identity
                var id = _match.Groups["id"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AlertDefinitions/"
                        + id
                        + "/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableAlertDefinitions_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableAlertDefinitions" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableAlertDefinitions_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableAlertDefinitions" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableAlertDefinitions_Validate(int id, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable all job activity property for commcell</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableAllJobActivity(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/AllJobActivity/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableAllJobActivity_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableAllJobActivity" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableAllJobActivity_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableAllJobActivity" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableAllJobActivity_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable auxillary copy property for commcell</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableAuxillaryCopyCommcell(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/AuxillaryCopy/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableAuxillaryCopyCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableAuxillaryCopyCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableAuxillaryCopyCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableAuxillaryCopyCommcell" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableAuxillaryCopyCommcell_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>
        /// Used to enable backup property for an agent
        /// Types of available agentIds are:
        /// 41-Active Directory,
        /// 21-AIX File System,
        /// 64-Big Data Apps,
        /// 134-Cloud Apps,
        /// 37-DB2,
        /// 103-DB2 MultiNode,
        /// 62-DB2 on Unix,
        /// 128-Documentum,
        /// 90-Domino Mailbox Archiver,
        /// 91-DPM,
        /// 67-Exchange Compliance Archiver,
        /// 53-Exchange Database,
        /// 45-Exchange Mailbox,
        /// 54-Exchange Mailbox (Classic),
        /// 56-Exchange Mailbox Archiver,
        /// 82-Exchange PF Archiver,
        /// 35-Exchange Public Folder,
        /// 73-File Share Archiver,
        /// 33-File System,
        /// 74-FreeBSD,
        /// 71-GroupWise DB,
        /// 17-HP-UX Files System,
        /// 65-Image Level,
        /// 75-Image Level On Unix,
        /// 76-Image Level ProxyHost,
        /// 87-Image Level ProxyHost on Unix,
        /// 3-Informix Database,
        /// 29-Linux File System,
        /// 89-MS SharePoint Archiver,
        /// 104-MySQL,
        /// 13-NAS,
        /// 83-Netware File Archiver,
        /// 12-Netware File System,
        /// 10-Novell Directory Services,
        /// 124-Object Link,
        /// 131-Object Store,
        /// 86-OES File System on Linux,
        /// 22-Oracle,
        /// 80-Oracle RAC,
        /// 130-Other External Agent,
        /// 125-PostgreSQL,
        /// 38-Proxy Client File System,
        /// 87-ProxyHost on Unix,
        /// 61-SAP for Oracle,
        /// 135-SAP HANA,
        /// 78-SharePoint Server,
        /// 20-Solaris 64bit File System,
        /// 19-Solaris File System,
        /// 81-SQL Server,
        /// 5-Sybase Database,
        /// 66-Unix File Archiver,
        /// 36-Unix Tru64 64-bit File System,
        /// 106-Virtual Server,
        /// 58- Windows File Archiver
        /// </summary>
        /// <param name="serverId">Id of the server to modify</param>
        /// <param name="agentId">Id of the agent to be modified</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableBackupAgent(int serverId, int agentId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Server/"
                        + (serverId.ToString())
                        + "/Agent/"
                        + (agentId.ToString())
                        + "/Backup/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableBackupAgent_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>
        /// Used to enable backup property for an agent
        /// Types of available agentIds are:
        /// 41-Active Directory,
        /// 21-AIX File System,
        /// 64-Big Data Apps,
        /// 134-Cloud Apps,
        /// 37-DB2,
        /// 103-DB2 MultiNode,
        /// 62-DB2 on Unix,
        /// 128-Documentum,
        /// 90-Domino Mailbox Archiver,
        /// 91-DPM,
        /// 67-Exchange Compliance Archiver,
        /// 53-Exchange Database,
        /// 45-Exchange Mailbox,
        /// 54-Exchange Mailbox (Classic),
        /// 56-Exchange Mailbox Archiver,
        /// 82-Exchange PF Archiver,
        /// 35-Exchange Public Folder,
        /// 73-File Share Archiver,
        /// 33-File System,
        /// 74-FreeBSD,
        /// 71-GroupWise DB,
        /// 17-HP-UX Files System,
        /// 65-Image Level,
        /// 75-Image Level On Unix,
        /// 76-Image Level ProxyHost,
        /// 87-Image Level ProxyHost on Unix,
        /// 3-Informix Database,
        /// 29-Linux File System,
        /// 89-MS SharePoint Archiver,
        /// 104-MySQL,
        /// 13-NAS,
        /// 83-Netware File Archiver,
        /// 12-Netware File System,
        /// 10-Novell Directory Services,
        /// 124-Object Link,
        /// 131-Object Store,
        /// 86-OES File System on Linux,
        /// 22-Oracle,
        /// 80-Oracle RAC,
        /// 130-Other External Agent,
        /// 125-PostgreSQL,
        /// 38-Proxy Client File System,
        /// 87-ProxyHost on Unix,
        /// 61-SAP for Oracle,
        /// 135-SAP HANA,
        /// 78-SharePoint Server,
        /// 20-Solaris 64bit File System,
        /// 19-Solaris File System,
        /// 81-SQL Server,
        /// 5-Sybase Database,
        /// 66-Unix File Archiver,
        /// 36-Unix Tru64 64-bit File System,
        /// 106-Virtual Server,
        /// 58- Windows File Archiver
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableBackupAgentViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Server/(?<serverId>[^/]+)/Agent/(?<agentId>[^/]+)/Backup/Action/Enable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Server/{serverId}/Agent/{agentId}/Backup/Action/Enable'");
                }

                // replace URI parameters with values from identity
                var serverId = _match.Groups["serverId"].Value;
                var agentId = _match.Groups["agentId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Server/"
                        + serverId
                        + "/Agent/"
                        + agentId
                        + "/Backup/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableBackupAgent_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableBackupAgent" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableBackupAgent_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableBackupAgent" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="serverId">Id of the server to modify</param>
        /// <param name="agentId">Id of the agent to be modified</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableBackupAgent_Validate(int serverId, int agentId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable backup property for commcell</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableBackupCommcell(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/Backup/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableBackupCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableBackupCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableBackupCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableBackupCommcell" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableBackupCommcell_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable backup property for an instance</summary>
        /// <param name="instanceId">Id of the instance to modify</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableBackupInstance(int instanceId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Instance/"
                        + (instanceId.ToString())
                        + "/Backup/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableBackupInstance_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to enable backup property for an instance</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableBackupInstanceViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Instance/(?<instanceId>[^/]+)/Backup/Action/Enable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Instance/{instanceId}/Backup/Action/Enable'");
                }

                // replace URI parameters with values from identity
                var instanceId = _match.Groups["instanceId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Instance/"
                        + instanceId
                        + "/Backup/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableBackupInstance_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableBackupInstance" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableBackupInstance_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableBackupInstance" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="instanceId">Id of the instance to modify</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableBackupInstance_Validate(int instanceId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable backup property for a server group</summary>
        /// <param name="serverGroupId">Id of the serverGroup to modify</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableBackupServerGroup(int serverGroupId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + (serverGroupId.ToString())
                        + "/Backup/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableBackupServerGroup_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to enable backup property for a server group</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableBackupServerGroupViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerGroup/(?<serverGroupId>[^/]+)/Backup/Action/Enable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerGroup/{serverGroupId}/Backup/Action/Enable'");
                }

                // replace URI parameters with values from identity
                var serverGroupId = _match.Groups["serverGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + serverGroupId
                        + "/Backup/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableBackupServerGroup_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableBackupServerGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableBackupServerGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableBackupServerGroup" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="serverGroupId">Id of the serverGroup to modify</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableBackupServerGroup_Validate(int serverGroupId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable backup property for an subclient</summary>
        /// <param name="subclientId">Id of the subclient to modify</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableBackupSubclient(int subclientId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Subclient/"
                        + (subclientId.ToString())
                        + "/Backup/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableBackupSubclient_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to enable backup property for an subclient</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableBackupSubclientViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Subclient/(?<subclientId>[^/]+)/Backup/Action/Enable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Subclient/{subclientId}/Backup/Action/Enable'");
                }

                // replace URI parameters with values from identity
                var subclientId = _match.Groups["subclientId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Subclient/"
                        + subclientId
                        + "/Backup/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableBackupSubclient_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableBackupSubclient" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableBackupSubclient_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableBackupSubclient" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="subclientId">Id of the subclient to modify</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableBackupSubclient_Validate(int subclientId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable content indexing property for commcell</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableContentIndexingCommcell(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/ContentIndexing/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableContentIndexingCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableContentIndexingCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableContentIndexingCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableContentIndexingCommcell" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableContentIndexingCommcell_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable data aging property for commcell</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableDataAgingCommcell(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/DataAging/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableDataAgingCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableDataAgingCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableDataAgingCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableDataAgingCommcell" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableDataAgingCommcell_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable data aging property for a server group</summary>
        /// <param name="serverGroupId">Id of the serverGroup to modify</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableDataAgingServerGroup(int serverGroupId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + (serverGroupId.ToString())
                        + "/DataAging/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableDataAgingServerGroup_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to enable data aging property for a server group</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableDataAgingServerGroupViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerGroup/(?<serverGroupId>[^/]+)/DataAging/Action/Enable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerGroup/{serverGroupId}/DataAging/Action/Enable'");
                }

                // replace URI parameters with values from identity
                var serverGroupId = _match.Groups["serverGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + serverGroupId
                        + "/DataAging/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableDataAgingServerGroup_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableDataAgingServerGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableDataAgingServerGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableDataAgingServerGroup" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="serverGroupId">Id of the serverGroup to modify</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableDataAgingServerGroup_Validate(int serverGroupId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable data verification property for commcell</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableDataVerificationCommcell(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/DataVerification/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableDataVerificationCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableDataVerificationCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableDataVerificationCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableDataVerificationCommcell" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableDataVerificationCommcell_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable DDB property for commcell</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableDdbCommcell(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/DDB/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableDdbCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableDdbCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableDdbCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableDdbCommcell" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableDdbCommcell_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable log scrubbing</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableLogScrubbing(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/scrubLogs/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableLogScrubbing_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableLogScrubbing" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableLogScrubbing_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableLogScrubbing" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableLogScrubbing_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>
        /// Used to enable restore property for an agent
        /// Types of available agentIds are:
        /// 41-Active Directory,
        /// 21-AIX File System,
        /// 64-Big Data Apps,
        /// 134-Cloud Apps,
        /// 37-DB2,
        /// 103-DB2 MultiNode,
        /// 62-DB2 on Unix,
        /// 128-Documentum,
        /// 90-Domino Mailbox Archiver,
        /// 91-DPM,
        /// 67-Exchange Compliance Archiver,
        /// 53-Exchange Database,
        /// 45-Exchange Mailbox,
        /// 54-Exchange Mailbox (Classic),
        /// 56-Exchange Mailbox Archiver,
        /// 82-Exchange PF Archiver,
        /// 35-Exchange Public Folder,
        /// 73-File Share Archiver,
        /// 33-File System,
        /// 74-FreeBSD,
        /// 71-GroupWise DB,
        /// 17-HP-UX Files System,
        /// 65-Image Level,
        /// 75-Image Level On Unix,
        /// 76-Image Level ProxyHost,
        /// 87-Image Level ProxyHost on Unix,
        /// 3-Informix Database,
        /// 29-Linux File System,
        /// 89-MS SharePoint Archiver,
        /// 104-MySQL,
        /// 13-NAS,
        /// 83-Netware File Archiver,
        /// 12-Netware File System,
        /// 10-Novell Directory Services,
        /// 124-Object Link,
        /// 131-Object Store,
        /// 86-OES File System on Linux,
        /// 22-Oracle,
        /// 80-Oracle RAC,
        /// 130-Other External Agent,
        /// 125-PostgreSQL,
        /// 38-Proxy Client File System,
        /// 87-ProxyHost on Unix,
        /// 61-SAP for Oracle,
        /// 135-SAP HANA,
        /// 78-SharePoint Server,
        /// 20-Solaris 64bit File System,
        /// 19-Solaris File System,
        /// 81-SQL Server,
        /// 5-Sybase Database,
        /// 66-Unix File Archiver,
        /// 36-Unix Tru64 64-bit File System,
        /// 106-Virtual Server,
        /// 58- Windows File Archiver
        /// </summary>
        /// <param name="serverId">Id of the server to modify</param>
        /// <param name="agentId">Id of the agent to be modified</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableRestoreAgent(int serverId, int agentId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Server/"
                        + (serverId.ToString())
                        + "/Agent/"
                        + (agentId.ToString())
                        + "/Restore/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableRestoreAgent_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>
        /// Used to enable restore property for an agent
        /// Types of available agentIds are:
        /// 41-Active Directory,
        /// 21-AIX File System,
        /// 64-Big Data Apps,
        /// 134-Cloud Apps,
        /// 37-DB2,
        /// 103-DB2 MultiNode,
        /// 62-DB2 on Unix,
        /// 128-Documentum,
        /// 90-Domino Mailbox Archiver,
        /// 91-DPM,
        /// 67-Exchange Compliance Archiver,
        /// 53-Exchange Database,
        /// 45-Exchange Mailbox,
        /// 54-Exchange Mailbox (Classic),
        /// 56-Exchange Mailbox Archiver,
        /// 82-Exchange PF Archiver,
        /// 35-Exchange Public Folder,
        /// 73-File Share Archiver,
        /// 33-File System,
        /// 74-FreeBSD,
        /// 71-GroupWise DB,
        /// 17-HP-UX Files System,
        /// 65-Image Level,
        /// 75-Image Level On Unix,
        /// 76-Image Level ProxyHost,
        /// 87-Image Level ProxyHost on Unix,
        /// 3-Informix Database,
        /// 29-Linux File System,
        /// 89-MS SharePoint Archiver,
        /// 104-MySQL,
        /// 13-NAS,
        /// 83-Netware File Archiver,
        /// 12-Netware File System,
        /// 10-Novell Directory Services,
        /// 124-Object Link,
        /// 131-Object Store,
        /// 86-OES File System on Linux,
        /// 22-Oracle,
        /// 80-Oracle RAC,
        /// 130-Other External Agent,
        /// 125-PostgreSQL,
        /// 38-Proxy Client File System,
        /// 87-ProxyHost on Unix,
        /// 61-SAP for Oracle,
        /// 135-SAP HANA,
        /// 78-SharePoint Server,
        /// 20-Solaris 64bit File System,
        /// 19-Solaris File System,
        /// 81-SQL Server,
        /// 5-Sybase Database,
        /// 66-Unix File Archiver,
        /// 36-Unix Tru64 64-bit File System,
        /// 106-Virtual Server,
        /// 58- Windows File Archiver
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableRestoreAgentViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Server/(?<serverId>[^/]+)/Agent/(?<agentId>[^/]+)/Restore/Action/Enable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Server/{serverId}/Agent/{agentId}/Restore/Action/Enable'");
                }

                // replace URI parameters with values from identity
                var serverId = _match.Groups["serverId"].Value;
                var agentId = _match.Groups["agentId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Server/"
                        + serverId
                        + "/Agent/"
                        + agentId
                        + "/Restore/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableRestoreAgent_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableRestoreAgent" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableRestoreAgent_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableRestoreAgent" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="serverId">Id of the server to modify</param>
        /// <param name="agentId">Id of the agent to be modified</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableRestoreAgent_Validate(int serverId, int agentId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable restore property for commcell</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableRestoreCommcell(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/Restore/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableRestoreCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableRestoreCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableRestoreCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableRestoreCommcell" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableRestoreCommcell_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable restore property for an instance</summary>
        /// <param name="instanceId">Id of the instance to modify</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableRestoreInstance(int instanceId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Instance/"
                        + (instanceId.ToString())
                        + "/Restore/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableRestoreInstance_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to enable restore property for an instance</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableRestoreInstanceViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Instance/(?<instanceId>[^/]+)/Restore/Action/Enable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Instance/{instanceId}/Restore/Action/Enable'");
                }

                // replace URI parameters with values from identity
                var instanceId = _match.Groups["instanceId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Instance/"
                        + instanceId
                        + "/Restore/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableRestoreInstance_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableRestoreInstance" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableRestoreInstance_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableRestoreInstance" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="instanceId">Id of the instance to modify</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableRestoreInstance_Validate(int instanceId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable restore property for a server group</summary>
        /// <param name="serverGroupId">Id of the serverGroup to modify</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableRestoreServerGroup(int serverGroupId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + (serverGroupId.ToString())
                        + "/Restore/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableRestoreServerGroup_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Used to enable restore property for a server group</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableRestoreServerGroupViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerGroup/(?<serverGroupId>[^/]+)/Restore/Action/Enable$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerGroup/{serverGroupId}/Restore/Action/Enable'");
                }

                // replace URI parameters with values from identity
                var serverGroupId = _match.Groups["serverGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + serverGroupId
                        + "/Restore/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableRestoreServerGroup_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableRestoreServerGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableRestoreServerGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableRestoreServerGroup" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="serverGroupId">Id of the serverGroup to modify</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableRestoreServerGroup_Validate(int serverGroupId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to enable scheduler property for commcell</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task EnableSchedulerCommcell(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Commcell/Scheduler/Action/Enable"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.EnableSchedulerCommcell_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="EnableSchedulerCommcell" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableSchedulerCommcell_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="EnableSchedulerCommcell" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task EnableSchedulerCommcell_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Gets owner permissions and laptop ownership details</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAccessControl(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAccessControl>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AccessControl"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAccessControl_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetAccessControl" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAccessControl_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAccessControl>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.AccessControl.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetAccessControl" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAccessControl_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Endpoint to get the list of access nodes</summary>
        /// <param name="vendor">Vendor Name to be filtered</param>
        /// <param name="userId">user id to be filtered</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAccessNodes(string vendor, int? userId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAccessNodesList>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AccessNodes"
                        + "?"
                        + (string.IsNullOrEmpty(vendor) ? global::System.String.Empty : "vendor=" + global::System.Uri.EscapeDataString(vendor))
                        + "&"
                        + (null == userId ? global::System.String.Empty : "userId=" + global::System.Uri.EscapeDataString(userId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAccessNodes_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Endpoint to get the list of access nodes</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="vendor">Vendor Name to be filtered</param>
        /// <param name="userId">user id to be filtered</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAccessNodesViaIdentity(global::System.String viaIdentity, string vendor, int? userId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAccessNodesList>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/AccessNodes$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/AccessNodes'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AccessNodes"
                        + "?"
                        + (string.IsNullOrEmpty(vendor) ? global::System.String.Empty : "vendor=" + global::System.Uri.EscapeDataString(vendor))
                        + "&"
                        + (null == userId ? global::System.String.Empty : "userId=" + global::System.Uri.EscapeDataString(userId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAccessNodes_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetAccessNodes" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAccessNodes_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAccessNodesList>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.AccessNodesList.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetAccessNodes" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="vendor">Vendor Name to be filtered</param>
        /// <param name="userId">user id to be filtered</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAccessNodes_Validate(string vendor, int? userId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(vendor),vendor);
            }
        }

        /// <summary>
        /// Retrieve the audit details for activate entities like clients, data sources, requests.
        /// Available entity types:
        /// 3 - Client
        /// 132 - Data source
        /// 9515 - Request
        /// </summary>
        /// <param name="entityType">Type of the entity</param>
        /// <param name="entityId">Unique id for the entity</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetActivateEntityAuditList(string entityType, int entityId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IEntityAuditList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Activate/Entity/"
                        + global::System.Uri.EscapeDataString(entityType)
                        + "/"
                        + (entityId.ToString())
                        + "/Audit"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetActivateEntityAuditList_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>
        /// Retrieve the audit details for activate entities like clients, data sources, requests.
        /// Available entity types:
        /// 3 - Client
        /// 132 - Data source
        /// 9515 - Request
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetActivateEntityAuditListViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IEntityAuditList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Activate/Entity/(?<entityType>[^/]+)/(?<entityId>[^/]+)/Audit$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Activate/Entity/{entityType}/{entityId}/Audit'");
                }

                // replace URI parameters with values from identity
                var entityType = _match.Groups["entityType"].Value;
                var entityId = _match.Groups["entityId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Activate/Entity/"
                        + entityType
                        + "/"
                        + entityId
                        + "/Audit"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetActivateEntityAuditList_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetActivateEntityAuditList" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetActivateEntityAuditList_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IEntityAuditList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.EntityAuditList.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetActivateEntityAuditList" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="entityType">Type of the entity</param>
        /// <param name="entityId">Unique id for the entity</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetActivateEntityAuditList_Validate(string entityType, int entityId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(entityType),entityType);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(entityId),entityId,1);
            }
        }

        /// <summary>Get detail of the AD/LDAP domain</summary>
        /// <param name="domainId">ID of the AD/LDAP domain</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAdldapDetails(int domainId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAdldapDetails>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LDAP/"
                        + (domainId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAdldapDetails_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Get detail of the AD/LDAP domain</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAdldapDetailsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAdldapDetails>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/LDAP/(?<domainId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/LDAP/{domainId}'");
                }

                // replace URI parameters with values from identity
                var domainId = _match.Groups["domainId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LDAP/"
                        + domainId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAdldapDetails_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetAdldapDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAdldapDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAdldapDetails>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.AdldapDetails.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetAdldapDetails" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="domainId">ID of the AD/LDAP domain</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAdldapDetails_Validate(int domainId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get details of alert definition</summary>
        /// <param name="id"></param>
        /// <param name="additionalProperties"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAlertDefinitionsDetails(int id, bool? additionalProperties, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAlertDefinitionsDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AlertDefinitions/"
                        + (id.ToString())
                        + "?"
                        + (null == additionalProperties ? global::System.String.Empty : "additionalProperties=" + global::System.Uri.EscapeDataString(additionalProperties.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAlertDefinitionsDetails_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Get details of alert definition</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="additionalProperties"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAlertDefinitionsDetailsViaIdentity(global::System.String viaIdentity, bool? additionalProperties, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAlertDefinitionsDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/AlertDefinitions/(?<id>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/AlertDefinitions/{id}'");
                }

                // replace URI parameters with values from identity
                var id = _match.Groups["id"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AlertDefinitions/"
                        + id
                        + "?"
                        + (null == additionalProperties ? global::System.String.Empty : "additionalProperties=" + global::System.Uri.EscapeDataString(additionalProperties.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAlertDefinitionsDetails_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetAlertDefinitionsDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAlertDefinitionsDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAlertDefinitionsDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.AlertDefinitionsDetails.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetAlertDefinitionsDetails" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="additionalProperties"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAlertDefinitionsDetails_Validate(int id, bool? additionalProperties, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get the list of Alert Definitions</summary>
        /// <param name="additionalProperties">To get extra meta data details for the api</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAlertDefinitionsList(bool? additionalProperties, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAlertDefinitionsList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AlertDefinitions"
                        + "?"
                        + (null == additionalProperties ? global::System.String.Empty : "additionalProperties=" + global::System.Uri.EscapeDataString(additionalProperties.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAlertDefinitionsList_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Get the list of Alert Definitions</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="additionalProperties">To get extra meta data details for the api</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAlertDefinitionsListViaIdentity(global::System.String viaIdentity, bool? additionalProperties, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAlertDefinitionsList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/AlertDefinitions$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/AlertDefinitions'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AlertDefinitions"
                        + "?"
                        + (null == additionalProperties ? global::System.String.Empty : "additionalProperties=" + global::System.Uri.EscapeDataString(additionalProperties.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAlertDefinitionsList_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetAlertDefinitionsList" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAlertDefinitionsList_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAlertDefinitionsList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.AlertDefinitionsList.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetAlertDefinitionsList" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="additionalProperties">To get extra meta data details for the api</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAlertDefinitionsList_Validate(bool? additionalProperties, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get List Of Alerts Triggered</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAlertsTriggered(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAlertsTriggeredListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/TriggeredAlerts"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAlertsTriggered_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetAlertsTriggered" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAlertsTriggered_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAlertsTriggeredListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.AlertsTriggeredListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetAlertsTriggered" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAlertsTriggered_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get the details of all applicationGroups</summary>
        /// <param name="clusterId">Id of the hypervisor to list application groups</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAllAPllicationGroups(int? clusterId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IApplicationGroupListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Kubernetes/ApplicationGroups"
                        + "?"
                        + (null == clusterId ? global::System.String.Empty : "ClusterId=" + global::System.Uri.EscapeDataString(clusterId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAllAPllicationGroups_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get the details of all applicationGroups</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clusterId">Id of the hypervisor to list application groups</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAllAPllicationGroupsViaIdentity(global::System.String viaIdentity, int? clusterId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IApplicationGroupListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Kubernetes/ApplicationGroups$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Kubernetes/ApplicationGroups'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Kubernetes/ApplicationGroups"
                        + "?"
                        + (null == clusterId ? global::System.String.Empty : "ClusterId=" + global::System.Uri.EscapeDataString(clusterId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAllAPllicationGroups_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetAllAPllicationGroups" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAllAPllicationGroups_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IApplicationGroupListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.ApplicationGroupListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetAllAPllicationGroups" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="clusterId">Id of the hypervisor to list application groups</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAllAPllicationGroups_Validate(int? clusterId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get the details of all vmGroup</summary>
        /// <param name="hypervisorId">Id of the hypervisor to list vm groups</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAllVMGroups(int? hypervisorId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths1Oy9W65V4VmgroupGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VMGroup"
                        + "?"
                        + (null == hypervisorId ? global::System.String.Empty : "hypervisorId=" + global::System.Uri.EscapeDataString(hypervisorId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAllVMGroups_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get the details of all vmGroup</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="hypervisorId">Id of the hypervisor to list vm groups</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAllVMGroupsViaIdentity(global::System.String viaIdentity, int? hypervisorId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths1Oy9W65V4VmgroupGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/VMGroup$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/VMGroup'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VMGroup"
                        + "?"
                        + (null == hypervisorId ? global::System.String.Empty : "hypervisorId=" + global::System.Uri.EscapeDataString(hypervisorId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAllVMGroups_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetAllVMGroups" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAllVMGroups_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths1Oy9W65V4VmgroupGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.Paths1Oy9W65V4VmgroupGetResponses200ContentApplicationJsonSchema.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetAllVMGroups" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="hypervisorId">Id of the hypervisor to list vm groups</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAllVMGroups_Validate(int? hypervisorId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>
        /// Get various anomalous conditions like events, jobs, offline clients, high CPU and memory loaded clients
        /// </summary>
        /// <param name="fromTime">unix time stamp denotes from which the anomalous events should be retrieved</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAnomalousConditions(string fromTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths16JaxnbV4AnomalousconditionsGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AnomalousConditions"
                        + "?"
                        + "fromTime=" + global::System.Uri.EscapeDataString(fromTime)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAnomalousConditions_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>
        /// Get various anomalous conditions like events, jobs, offline clients, high CPU and memory loaded clients
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="fromTime">unix time stamp denotes from which the anomalous events should be retrieved</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAnomalousConditionsViaIdentity(global::System.String viaIdentity, string fromTime, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths16JaxnbV4AnomalousconditionsGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/AnomalousConditions$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/AnomalousConditions'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AnomalousConditions"
                        + "?"
                        + "fromTime=" + global::System.Uri.EscapeDataString(fromTime)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAnomalousConditions_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetAnomalousConditions" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAnomalousConditions_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths16JaxnbV4AnomalousconditionsGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.Paths16JaxnbV4AnomalousconditionsGetResponses200ContentApplicationJsonSchema.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetAnomalousConditions" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="fromTime">unix time stamp denotes from which the anomalous events should be retrieved</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAnomalousConditions_Validate(string fromTime, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(fromTime),fromTime);
            }
        }

        /// <summary>Get Backup Destinations for a Plan</summary>
        /// <param name="planId">Id of the Archive Plan to retrieve backup destinations</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetArchiveBackupDestinations(int planId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IArchivePlanBackupDestinations>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + (planId.ToString())
                        + "/BackupDestinations"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetArchiveBackupDestinations_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get Backup Destinations for a Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetArchiveBackupDestinationsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IArchivePlanBackupDestinations>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ArchivePlan/(?<planId>[^/]+)/BackupDestinations$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ArchivePlan/{planId}/BackupDestinations'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + planId
                        + "/BackupDestinations"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetArchiveBackupDestinations_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetArchiveBackupDestinations" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetArchiveBackupDestinations_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IArchivePlanBackupDestinations>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.ArchivePlanBackupDestinations.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetArchiveBackupDestinations" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="planId">Id of the Archive Plan to retrieve backup destinations</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetArchiveBackupDestinations_Validate(int planId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>This endpoint is used to return the list of Archive file servers.</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetArchiveFileServers(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IFileServerListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchiveFileServers"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetArchiveFileServers_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetArchiveFileServers" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetArchiveFileServers_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IFileServerListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.FileServerListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetArchiveFileServers" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetArchiveFileServers_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get Archive Plan details</summary>
        /// <param name="planId">Id of the plan</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetArchivePlanById(int planId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IArchivePlanDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + (planId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetArchivePlanById_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get Archive Plan details</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetArchivePlanByIdViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IArchivePlanDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ArchivePlan/(?<planId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ArchivePlan/{planId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + planId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetArchivePlanById_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetArchivePlanById" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetArchivePlanById_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IArchivePlanDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.ArchivePlanDetails.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetArchivePlanById" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="planId">Id of the plan</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetArchivePlanById_Validate(int planId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>API to get list of association for a company</summary>
        /// <param name="companyId">Id of the Company whose associations have to be fetched</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAssociationsForCompany(int companyId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetAssociationsForCompanyResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Company/"
                        + (companyId.ToString())
                        + "/associations"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAssociationsForCompany_Call(request,onOk,onBadRequest,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>API to get list of association for a company</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetAssociationsForCompanyViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetAssociationsForCompanyResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Company/(?<companyId>[^/]+)/associations$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Company/{companyId}/associations'");
                }

                // replace URI parameters with values from identity
                var companyId = _match.Groups["companyId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Company/"
                        + companyId
                        + "/associations"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetAssociationsForCompany_Call(request,onOk,onBadRequest,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetAssociationsForCompany" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAssociationsForCompany_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetAssociationsForCompanyResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GetAssociationsForCompanyResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.ServiceUnavailable:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onServiceUnavailable(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetAssociationsForCompany" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="companyId">Id of the Company whose associations have to be fetched</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetAssociationsForCompany_Validate(int companyId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get Backup Destinations for a Plan</summary>
        /// <param name="planId">Id of the Plan to retrieve backup destinations</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetBackupDestinations(int planId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinations>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + (planId.ToString())
                        + "/BackupDestinations"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetBackupDestinations_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get Backup Destinations for a Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetBackupDestinationsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinations>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerPlan/(?<planId>[^/]+)/BackupDestinations$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerPlan/{planId}/BackupDestinations'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + planId
                        + "/BackupDestinations"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetBackupDestinations_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetBackupDestinations" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetBackupDestinations_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinations>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanBackupDestinations.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetBackupDestinations" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="planId">Id of the Plan to retrieve backup destinations</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetBackupDestinations_Validate(int planId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Used to fetch mount path details of the disk storage pool</summary>
        /// <param name="storagePoolId">Id of the disk storage pool whose details have to be fetched</param>
        /// <param name="backupLocationId">Id of the backup location whose details have to be fetched</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetBackupLocationDetails(int storagePoolId, int backupLocationId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IBackupLocationDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + (storagePoolId.ToString())
                        + "/BackupLocation/"
                        + (backupLocationId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetBackupLocationDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Used to fetch mount path details of the disk storage pool</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetBackupLocationDetailsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IBackupLocationDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Disk/(?<storagePoolId>[^/]+)/BackupLocation/(?<backupLocationId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Disk/{storagePoolId}/BackupLocation/{backupLocationId}'");
                }

                // replace URI parameters with values from identity
                var storagePoolId = _match.Groups["storagePoolId"].Value;
                var backupLocationId = _match.Groups["backupLocationId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + storagePoolId
                        + "/BackupLocation/"
                        + backupLocationId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetBackupLocationDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetBackupLocationDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetBackupLocationDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IBackupLocationDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.BackupLocationDetails.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetBackupLocationDetails" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="storagePoolId">Id of the disk storage pool whose details have to be fetched</param>
        /// <param name="backupLocationId">Id of the backup location whose details have to be fetched</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetBackupLocationDetails_Validate(int storagePoolId, int backupLocationId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>This endpoint is used to return the list of big data apps.</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetBigDataList(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IBigDataAppListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/BigDataApps"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetBigDataList_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetBigDataList" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetBigDataList_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IBigDataAppListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.BigDataAppListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetBigDataList" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetBigDataList_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get details of a blackout window based on id</summary>
        /// <param name="blackoutWindowId">Id of the Blackout Window whose details have to be fetched</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetBlackoutWindowDetails(int blackoutWindowId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IBlackoutWindow>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/BlackoutWindow/"
                        + (blackoutWindowId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetBlackoutWindowDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get details of a blackout window based on id</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetBlackoutWindowDetailsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IBlackoutWindow>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/BlackoutWindow/(?<blackoutWindowId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/BlackoutWindow/{blackoutWindowId}'");
                }

                // replace URI parameters with values from identity
                var blackoutWindowId = _match.Groups["blackoutWindowId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/BlackoutWindow/"
                        + blackoutWindowId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetBlackoutWindowDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetBlackoutWindowDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetBlackoutWindowDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IBlackoutWindow>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.BlackoutWindow.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetBlackoutWindowDetails" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="blackoutWindowId">Id of the Blackout Window whose details have to be fetched</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetBlackoutWindowDetails_Validate(int blackoutWindowId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get All Blackout Windows</summary>
        /// <param name="showOnlyCommcellLevel">Shows blackout window at commcell level if set to true.</param>
        /// <param name="companyId">Shows blackout windows associated with the company whose id has been provided.</param>
        /// <param name="serverGroupId">Shows blackout windows associated with the server group whose id has been provided.</param>
        /// <param name="commcellId">Shows blackout windows associated with the commcell whose id has been provided.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetBlackoutWindows(bool? showOnlyCommcellLevel, int? companyId, string serverGroupId, string commcellId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IBlackoutWindowsListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/BlackoutWindow"
                        + "?"
                        + (null == showOnlyCommcellLevel ? global::System.String.Empty : "showOnlyCommcellLevel=" + global::System.Uri.EscapeDataString(showOnlyCommcellLevel.ToString()))
                        + "&"
                        + (null == companyId ? global::System.String.Empty : "companyId=" + global::System.Uri.EscapeDataString(companyId.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(serverGroupId) ? global::System.String.Empty : "serverGroupId=" + global::System.Uri.EscapeDataString(serverGroupId))
                        + "&"
                        + (string.IsNullOrEmpty(commcellId) ? global::System.String.Empty : "commcellId=" + global::System.Uri.EscapeDataString(commcellId))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetBlackoutWindows_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get All Blackout Windows</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="showOnlyCommcellLevel">Shows blackout window at commcell level if set to true.</param>
        /// <param name="companyId">Shows blackout windows associated with the company whose id has been provided.</param>
        /// <param name="serverGroupId">Shows blackout windows associated with the server group whose id has been provided.</param>
        /// <param name="commcellId">Shows blackout windows associated with the commcell whose id has been provided.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetBlackoutWindowsViaIdentity(global::System.String viaIdentity, bool? showOnlyCommcellLevel, int? companyId, string serverGroupId, string commcellId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IBlackoutWindowsListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/BlackoutWindow$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/BlackoutWindow'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/BlackoutWindow"
                        + "?"
                        + (null == showOnlyCommcellLevel ? global::System.String.Empty : "showOnlyCommcellLevel=" + global::System.Uri.EscapeDataString(showOnlyCommcellLevel.ToString()))
                        + "&"
                        + (null == companyId ? global::System.String.Empty : "companyId=" + global::System.Uri.EscapeDataString(companyId.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(serverGroupId) ? global::System.String.Empty : "serverGroupId=" + global::System.Uri.EscapeDataString(serverGroupId))
                        + "&"
                        + (string.IsNullOrEmpty(commcellId) ? global::System.String.Empty : "commcellId=" + global::System.Uri.EscapeDataString(commcellId))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetBlackoutWindows_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetBlackoutWindows" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetBlackoutWindows_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IBlackoutWindowsListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.BlackoutWindowsListResponse.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetBlackoutWindows" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="showOnlyCommcellLevel">Shows blackout window at commcell level if set to true.</param>
        /// <param name="companyId">Shows blackout windows associated with the company whose id has been provided.</param>
        /// <param name="serverGroupId">Shows blackout windows associated with the server group whose id has been provided.</param>
        /// <param name="commcellId">Shows blackout windows associated with the commcell whose id has been provided.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetBlackoutWindows_Validate(bool? showOnlyCommcellLevel, int? companyId, string serverGroupId, string commcellId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(serverGroupId),serverGroupId);
                await eventListener.AssertNotNull(nameof(commcellId),commcellId);
            }
        }

        /// <summary>Get details of a specific bucket of a cloud storage</summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="bucketId">Id of Bucket</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetBucketDetailsOfCloudStorage(int cloudStorageId, int bucketId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IBucketsResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + (cloudStorageId.ToString())
                        + "/Bucket/"
                        + (bucketId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetBucketDetailsOfCloudStorage_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get details of a specific bucket of a cloud storage</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetBucketDetailsOfCloudStorageViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IBucketsResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Cloud/(?<cloudStorageId>[^/]+)/Bucket/(?<bucketId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Cloud/{cloudStorageId}/Bucket/{bucketId}'");
                }

                // replace URI parameters with values from identity
                var cloudStorageId = _match.Groups["cloudStorageId"].Value;
                var bucketId = _match.Groups["bucketId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + cloudStorageId
                        + "/Bucket/"
                        + bucketId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetBucketDetailsOfCloudStorage_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetBucketDetailsOfCloudStorage" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetBucketDetailsOfCloudStorage_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IBucketsResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.BucketsResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetBucketDetailsOfCloudStorage" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="bucketId">Id of Bucket</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetBucketDetailsOfCloudStorage_Validate(int cloudStorageId, int bucketId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get All Cloud Storage</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetCloudStorageList(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths14GiyiiV4StorageCloudGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetCloudStorageList_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetCloudStorageList" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetCloudStorageList_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths14GiyiiV4StorageCloudGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.Paths14GiyiiV4StorageCloudGetResponses200ContentApplicationJsonSchema.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetCloudStorageList" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetCloudStorageList_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get details of metadata Cache of a cloud storage based on Id</summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="metadataCacheId">Id of metadata cache</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetCloudStorageMetaDataCacheById(int cloudStorageId, int metadataCacheId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IMetadataCacheConfiguration>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + (cloudStorageId.ToString())
                        + "/MetadataCache/"
                        + (metadataCacheId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetCloudStorageMetaDataCacheById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Get details of metadata Cache of a cloud storage based on Id</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetCloudStorageMetaDataCacheByIdViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IMetadataCacheConfiguration>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Cloud/(?<cloudStorageId>[^/]+)/MetadataCache/(?<metadataCacheId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Cloud/{cloudStorageId}/MetadataCache/{metadataCacheId}'");
                }

                // replace URI parameters with values from identity
                var cloudStorageId = _match.Groups["cloudStorageId"].Value;
                var metadataCacheId = _match.Groups["metadataCacheId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + cloudStorageId
                        + "/MetadataCache/"
                        + metadataCacheId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetCloudStorageMetaDataCacheById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetCloudStorageMetaDataCacheById" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetCloudStorageMetaDataCacheById_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IMetadataCacheConfiguration>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.MetadataCacheConfiguration.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetCloudStorageMetaDataCacheById" /> method. Call this like the actual call, but you
        /// will get validation events back.
        /// </summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="metadataCacheId">Id of metadata cache</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetCloudStorageMetaDataCacheById_Validate(int cloudStorageId, int metadataCacheId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get All Companies</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetCompanies(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICompanyListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/company"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetCompanies_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetCompanies" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetCompanies_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICompanyListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.CompanyListResponse.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetCompanies" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetCompanies_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get details of a company based on id</summary>
        /// <param name="companyId">Id of the Company whose details have to be fetched</param>
        /// <param name="showInheritedAssociation">Show inherited security association</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetCompanyDetails(int companyId, bool? showInheritedAssociation, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICompany>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/company/"
                        + (companyId.ToString())
                        + "?"
                        + (null == showInheritedAssociation ? global::System.String.Empty : "showInheritedAssociation=" + global::System.Uri.EscapeDataString(showInheritedAssociation.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetCompanyDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get details of a company based on id</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="showInheritedAssociation">Show inherited security association</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetCompanyDetailsViaIdentity(global::System.String viaIdentity, bool? showInheritedAssociation, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICompany>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/company/(?<companyId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/company/{companyId}'");
                }

                // replace URI parameters with values from identity
                var companyId = _match.Groups["companyId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/company/"
                        + companyId
                        + "?"
                        + (null == showInheritedAssociation ? global::System.String.Empty : "showInheritedAssociation=" + global::System.Uri.EscapeDataString(showInheritedAssociation.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetCompanyDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetCompanyDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetCompanyDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICompany>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.Company.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetCompanyDetails" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="companyId">Id of the Company whose details have to be fetched</param>
        /// <param name="showInheritedAssociation">Show inherited security association</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetCompanyDetails_Validate(int companyId, bool? showInheritedAssociation, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>List of Credentials</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetCredentials(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICredentialManagerListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Credential"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetCredentials_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetCredentials" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetCredentials_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICredentialManagerListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.CredentialManagerListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetCredentials" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetCredentials_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get all databases</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetDatabases(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IDatabaseListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Databases"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetDatabases_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetDatabases" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetDatabases_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IDatabaseListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.DatabaseListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetDatabases" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetDatabases_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get details of a disk storage pool based on id</summary>
        /// <param name="storagePoolId">Id of the disk storage pool whose details have to be fetched</param>
        /// <param name="showInheritedAssociation">Show inherited security association</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetDiskStorageDetails(int storagePoolId, bool? showInheritedAssociation, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IDiskStorage>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + (storagePoolId.ToString())
                        + "?"
                        + (null == showInheritedAssociation ? global::System.String.Empty : "showInheritedAssociation=" + global::System.Uri.EscapeDataString(showInheritedAssociation.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetDiskStorageDetails_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Get details of a disk storage pool based on id</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="showInheritedAssociation">Show inherited security association</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetDiskStorageDetailsViaIdentity(global::System.String viaIdentity, bool? showInheritedAssociation, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IDiskStorage>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Disk/(?<storagePoolId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Disk/{storagePoolId}'");
                }

                // replace URI parameters with values from identity
                var storagePoolId = _match.Groups["storagePoolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + storagePoolId
                        + "?"
                        + (null == showInheritedAssociation ? global::System.String.Empty : "showInheritedAssociation=" + global::System.Uri.EscapeDataString(showInheritedAssociation.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetDiskStorageDetails_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetDiskStorageDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetDiskStorageDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IDiskStorage>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.DiskStorage.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetDiskStorageDetails" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="storagePoolId">Id of the disk storage pool whose details have to be fetched</param>
        /// <param name="showInheritedAssociation">Show inherited security association</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetDiskStorageDetails_Validate(int storagePoolId, bool? showInheritedAssociation, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get a list of disk storage pools</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetDiskStorages(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IStorageListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetDiskStorages_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetDiskStorages" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetDiskStorages_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IStorageListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.StorageListResponse.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetDiskStorages" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetDiskStorages_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get the list of distributed storages</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetDistributedStorages(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IDistributedStorageListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/DistributedStorage"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetDistributedStorages_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetDistributedStorages" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetDistributedStorages_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IDistributedStorageListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.DistributedStorageListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetDistributedStorages" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetDistributedStorages_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>This endpoint is used to return the list of distributed systems.</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetDistributedSystems(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IDistributedSystemsListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/DistributedSystems"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetDistributedSystems_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetDistributedSystems" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetDistributedSystems_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IDistributedSystemsListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.DistributedSystemsListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetDistributedSystems" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetDistributedSystems_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Retrieves SMTP server details</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onUnauthorized">a delegate that is called when the remote service returns 401 (Unauthorized).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetEmailServer(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetEmailServerDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onUnauthorized, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/EmailServer"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetEmailServer_Call(request,onOk,onUnauthorized,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetEmailServer" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onUnauthorized">a delegate that is called when the remote service returns 401 (Unauthorized).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetEmailServer_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetEmailServerDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onUnauthorized, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GetEmailServerDetails.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Unauthorized:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onUnauthorized(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetEmailServer" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetEmailServer_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>
        /// Get list of entity settings used to modify default behaviour for linked entity like servers or server groups
        /// </summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetEntitySettings(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IEntitySettingsResponse>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/EntitySettings"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetEntitySettings_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetEntitySettings" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetEntitySettings_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IEntitySettingsResponse>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.EntitySettingsResponse.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetEntitySettings" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetEntitySettings_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>This endpoint is used to return the list of epic servers.</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetEpicServers(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IFileServerListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/EpicServers"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetEpicServers_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetEpicServers" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetEpicServers_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IFileServerListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.FileServerListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetEpicServers" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetEpicServers_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>This end point return the list of failover groups</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetFailoverGroups(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetFailoverGroups>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/FailoverGroups"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetFailoverGroups_Call(request,onOk,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetFailoverGroups" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetFailoverGroups_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetFailoverGroups>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GetFailoverGroups.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.ServiceUnavailable:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onServiceUnavailable(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetFailoverGroups" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetFailoverGroups_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>This endpoint is used to return the list of file servers.</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetFileServers(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IFileServerListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/FileServers"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetFileServers_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetFileServers" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetFileServers_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IFileServerListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.FileServerListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetFileServers" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetFileServers_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get database list for GCP</summary>
        /// <param name="cloudAccountId">the id of the node where the browse request is sent</param>
        /// <param name="projectName">google cloud project the instance belongs to</param>
        /// <param name="instanceName">the google spanner instance name</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetGcpSpannerDatabases(int cloudAccountId, string projectName, string instanceName, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGcpDatabaseList>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/GCPSpanner/databases"
                        + "?"
                        + "cloudAccountId=" + global::System.Uri.EscapeDataString(cloudAccountId.ToString())
                        + "&"
                        + "projectName=" + global::System.Uri.EscapeDataString(projectName)
                        + "&"
                        + "instanceName=" + global::System.Uri.EscapeDataString(instanceName)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetGcpSpannerDatabases_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Get database list for GCP</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="cloudAccountId">the id of the node where the browse request is sent</param>
        /// <param name="projectName">google cloud project the instance belongs to</param>
        /// <param name="instanceName">the google spanner instance name</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetGcpSpannerDatabasesViaIdentity(global::System.String viaIdentity, int cloudAccountId, string projectName, string instanceName, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGcpDatabaseList>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/GCPSpanner/databases$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/GCPSpanner/databases'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/GCPSpanner/databases"
                        + "?"
                        + "cloudAccountId=" + global::System.Uri.EscapeDataString(cloudAccountId.ToString())
                        + "&"
                        + "projectName=" + global::System.Uri.EscapeDataString(projectName)
                        + "&"
                        + "instanceName=" + global::System.Uri.EscapeDataString(instanceName)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetGcpSpannerDatabases_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetGcpSpannerDatabases" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetGcpSpannerDatabases_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGcpDatabaseList>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GcpDatabaseList.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetGcpSpannerDatabases" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="cloudAccountId">the id of the node where the browse request is sent</param>
        /// <param name="projectName">google cloud project the instance belongs to</param>
        /// <param name="instanceName">the google spanner instance name</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetGcpSpannerDatabases_Validate(int cloudAccountId, string projectName, string instanceName, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(projectName),projectName);
                await eventListener.AssertNotNull(nameof(instanceName),instanceName);
            }
        }

        /// <summary>To get the list of instances for GCP</summary>
        /// <param name="cloudAccountId">the google cloud hypervisor account id</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetGcpSpannerInstanceList(int cloudAccountId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGcpInstanceList>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/GCPSpanner/instances"
                        + "?"
                        + "cloudAccountId=" + global::System.Uri.EscapeDataString(cloudAccountId.ToString())
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetGcpSpannerInstanceList_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>To get the list of instances for GCP</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="cloudAccountId">the google cloud hypervisor account id</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetGcpSpannerInstanceListViaIdentity(global::System.String viaIdentity, int cloudAccountId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGcpInstanceList>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/GCPSpanner/instances$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/GCPSpanner/instances'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/GCPSpanner/instances"
                        + "?"
                        + "cloudAccountId=" + global::System.Uri.EscapeDataString(cloudAccountId.ToString())
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetGcpSpannerInstanceList_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetGcpSpannerInstanceList" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetGcpSpannerInstanceList_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGcpInstanceList>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GcpInstanceList.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetGcpSpannerInstanceList" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="cloudAccountId">the google cloud hypervisor account id</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetGcpSpannerInstanceList_Validate(int cloudAccountId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get permission status for a cloudAccount on a GCP project</summary>
        /// <param name="cloudAccountId">the id of the node where the browse request is sent</param>
        /// <param name="projectName">google cloud project the instance belongs to</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetGcpSpannerPermissions(int? cloudAccountId, string projectName, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IStatusModel>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/GCPSpanner/permissions"
                        + "?"
                        + (null == cloudAccountId ? global::System.String.Empty : "cloudAccountId=" + global::System.Uri.EscapeDataString(cloudAccountId.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(projectName) ? global::System.String.Empty : "projectName=" + global::System.Uri.EscapeDataString(projectName))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetGcpSpannerPermissions_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Get permission status for a cloudAccount on a GCP project</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="cloudAccountId">the id of the node where the browse request is sent</param>
        /// <param name="projectName">google cloud project the instance belongs to</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetGcpSpannerPermissionsViaIdentity(global::System.String viaIdentity, int? cloudAccountId, string projectName, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IStatusModel>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/GCPSpanner/permissions$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/GCPSpanner/permissions'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/GCPSpanner/permissions"
                        + "?"
                        + (null == cloudAccountId ? global::System.String.Empty : "cloudAccountId=" + global::System.Uri.EscapeDataString(cloudAccountId.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(projectName) ? global::System.String.Empty : "projectName=" + global::System.Uri.EscapeDataString(projectName))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetGcpSpannerPermissions_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetGcpSpannerPermissions" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetGcpSpannerPermissions_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IStatusModel>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.StatusModel.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetGcpSpannerPermissions" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="cloudAccountId">the id of the node where the browse request is sent</param>
        /// <param name="projectName">google cloud project the instance belongs to</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetGcpSpannerPermissions_Validate(int? cloudAccountId, string projectName, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(projectName),projectName);
            }
        }

        /// <summary>Get list of global execptions</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetGlobalExceptions(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetGlobalExceptions>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/GlobalExceptions"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetGlobalExceptions_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetGlobalExceptions" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetGlobalExceptions_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetGlobalExceptions>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GetGlobalExceptions.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetGlobalExceptions" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetGlobalExceptions_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get list of global settings used to modify system default behaviour</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetGlobalSettings(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGlobalSettingsResponse>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/GlobalSettings"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetGlobalSettings_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetGlobalSettings" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetGlobalSettings_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGlobalSettingsResponse>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GlobalSettingsResponse.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetGlobalSettings" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetGlobalSettings_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>API to get Hybrid File Store Share Status</summary>
        /// <param name="hfsShareId">Id of the HFS Share to fetch its status</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetHybridFileStoreShareStatus(int hfsShareId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHfsShareStatusResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHfsShareStatusResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHfsShareStatusResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/v4/HFSShare/"
                        + (hfsShareId.ToString())
                        + "/Status"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetHybridFileStoreShareStatus_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>API to get Hybrid File Store Share Status</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetHybridFileStoreShareStatusViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHfsShareStatusResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHfsShareStatusResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHfsShareStatusResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/v4/HFSShare/(?<HFSShareId>[^/]+)/Status$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/v4/HFSShare/{HFSShareId}/Status'");
                }

                // replace URI parameters with values from identity
                var hfsShareId = _match.Groups["HFSShareId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/v4/HFSShare/"
                        + hfsShareId
                        + "/Status"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetHybridFileStoreShareStatus_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetHybridFileStoreShareStatus" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetHybridFileStoreShareStatus_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHfsShareStatusResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHfsShareStatusResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHfsShareStatusResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.HfsShareStatusResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.HfsShareStatusResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.HfsShareStatusResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetHybridFileStoreShareStatus" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="hfsShareId">Id of the HFS Share to fetch its status</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetHybridFileStoreShareStatus_Validate(int hfsShareId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get list of hybrid file stores</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetHybridFileStores(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHybridFileStoresListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/HybridFileStores"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetHybridFileStores_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetHybridFileStores" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetHybridFileStores_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHybridFileStoresListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.HybridFileStoresListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetHybridFileStores" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetHybridFileStores_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get details of a specific HyperScale Storage</summary>
        /// <param name="hyperScaleStorageId">Id of hyperscale storage</param>
        /// <param name="showInheritedAssociation">Set to true if want to show inherited security associations</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetHyperScaleStorageById(int hyperScaleStorageId, string showInheritedAssociation, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHyperScaleStorageDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/HyperScale/"
                        + (hyperScaleStorageId.ToString())
                        + "?"
                        + (string.IsNullOrEmpty(showInheritedAssociation) ? global::System.String.Empty : "showInheritedAssociation=" + global::System.Uri.EscapeDataString(showInheritedAssociation))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetHyperScaleStorageById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Get details of a specific HyperScale Storage</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="showInheritedAssociation">Set to true if want to show inherited security associations</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetHyperScaleStorageByIdViaIdentity(global::System.String viaIdentity, string showInheritedAssociation, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHyperScaleStorageDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/HyperScale/(?<hyperScaleStorageId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/HyperScale/{hyperScaleStorageId}'");
                }

                // replace URI parameters with values from identity
                var hyperScaleStorageId = _match.Groups["hyperScaleStorageId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/HyperScale/"
                        + hyperScaleStorageId
                        + "?"
                        + (string.IsNullOrEmpty(showInheritedAssociation) ? global::System.String.Empty : "showInheritedAssociation=" + global::System.Uri.EscapeDataString(showInheritedAssociation))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetHyperScaleStorageById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetHyperScaleStorageById" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetHyperScaleStorageById_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHyperScaleStorageDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.HyperScaleStorageDetails.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetHyperScaleStorageById" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="hyperScaleStorageId">Id of hyperscale storage</param>
        /// <param name="showInheritedAssociation">Set to true if want to show inherited security associations</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetHyperScaleStorageById_Validate(int hyperScaleStorageId, string showInheritedAssociation, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(showInheritedAssociation),showInheritedAssociation);
            }
        }

        /// <summary>Get All HyperScale Storage</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetHyperScaleStorageList(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths1BigzubV4StorageHyperscaleGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/HyperScale"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetHyperScaleStorageList_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetHyperScaleStorageList" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetHyperScaleStorageList_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths1BigzubV4StorageHyperscaleGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.Paths1BigzubV4StorageHyperscaleGetResponses200ContentApplicationJsonSchema.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetHyperScaleStorageList" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetHyperScaleStorageList_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get the details of HYpervisor</summary>
        /// <param name="hypervisorId">Id of the HYpervisor to get</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetHypervisors(int hypervisorId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHypervisorPropertiesResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Hypervisor/"
                        + (hypervisorId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetHypervisors_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get the details of HYpervisor</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetHypervisorsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHypervisorPropertiesResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Hypervisor/(?<hypervisorId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Hypervisor/{hypervisorId}'");
                }

                // replace URI parameters with values from identity
                var hypervisorId = _match.Groups["hypervisorId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Hypervisor/"
                        + hypervisorId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetHypervisors_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetHypervisors" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetHypervisors_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHypervisorPropertiesResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.HypervisorPropertiesResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetHypervisors" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="hypervisorId">Id of the HYpervisor to get</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetHypervisors_Validate(int hypervisorId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get identity servers list</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetIdentityServers(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdentityServersListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/IdentityServers"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetIdentityServers_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetIdentityServers" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetIdentityServers_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdentityServersListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.IdentityServersListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetIdentityServers" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetIdentityServers_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get list of index servers</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetIndexServers(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIndexServersListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/IndexServers"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetIndexServers_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetIndexServers" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetIndexServers_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIndexServersListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.IndexServersListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetIndexServers" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetIndexServers_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>This endpoint is used to return the list of instances.</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetInstances(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IInstanceListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Instances"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetInstances_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetInstances" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetInstances_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IInstanceListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.InstanceListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetInstances" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetInstances_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get all instant clones</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetInstantClones(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IInstantClonesListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/InstantClones"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetInstantClones_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetInstantClones" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetInstantClones_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IInstantClonesListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.InstantClonesListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetInstantClones" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetInstantClones_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get key management servers</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetKeyManagementServers(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths1Ir1YhfV4KeymanagementserversGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/KeyManagementServers"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetKeyManagementServers_Call(request,onOk,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetKeyManagementServers" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetKeyManagementServers_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths1Ir1YhfV4KeymanagementserversGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.Paths1Ir1YhfV4KeymanagementserversGetResponses200ContentApplicationJsonSchema.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.ServiceUnavailable:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onServiceUnavailable(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetKeyManagementServers" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetKeyManagementServers_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get all application in Kubenetes cluster</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetKubernetesApplication(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IApplicationListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Kubernetes/Applications"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetKubernetesApplication_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetKubernetesApplication" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetKubernetesApplication_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IApplicationListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.ApplicationListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetKubernetesApplication" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetKubernetesApplication_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get Backup Destinations for a Plan</summary>
        /// <param name="planId">Id of the Laptop Plan to retrieve backup destinations</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetLaptopBackupDestinations(int planId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinations>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + (planId.ToString())
                        + "/BackupDestinations"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetLaptopBackupDestinations_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get Backup Destinations for a Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetLaptopBackupDestinationsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinations>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/LaptopPlan/(?<planId>[^/]+)/BackupDestinations$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/LaptopPlan/{planId}/BackupDestinations'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + planId
                        + "/BackupDestinations"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetLaptopBackupDestinations_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetLaptopBackupDestinations" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetLaptopBackupDestinations_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinations>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanBackupDestinations.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetLaptopBackupDestinations" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="planId">Id of the Laptop Plan to retrieve backup destinations</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetLaptopBackupDestinations_Validate(int planId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>API to get the list of laptop owner mappings</summary>
        /// <param name="companyId">Id of the company for which the laptop owner mapping needs to be returned</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetLaptopOwnerMapping(int? companyId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ILaptopOwnerMapping>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopOwnerMapping"
                        + "?"
                        + (null == companyId ? global::System.String.Empty : "companyId=" + global::System.Uri.EscapeDataString(companyId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetLaptopOwnerMapping_Call(request,onOk,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>API to get the list of laptop owner mappings</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="companyId">Id of the company for which the laptop owner mapping needs to be returned</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetLaptopOwnerMappingViaIdentity(global::System.String viaIdentity, int? companyId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ILaptopOwnerMapping>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/LaptopOwnerMapping$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/LaptopOwnerMapping'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopOwnerMapping"
                        + "?"
                        + (null == companyId ? global::System.String.Empty : "companyId=" + global::System.Uri.EscapeDataString(companyId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetLaptopOwnerMapping_Call(request,onOk,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetLaptopOwnerMapping" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetLaptopOwnerMapping_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ILaptopOwnerMapping>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.LaptopOwnerMapping.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.ServiceUnavailable:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onServiceUnavailable(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetLaptopOwnerMapping" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="companyId">Id of the company for which the laptop owner mapping needs to be returned</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetLaptopOwnerMapping_Validate(int? companyId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get Laptop Plan details</summary>
        /// <param name="planId">Id of the plan</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetLaptopPlanById(int planId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ILaptopPlanDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + (planId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetLaptopPlanById_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get Laptop Plan details</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetLaptopPlanByIdViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ILaptopPlanDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/LaptopPlan/(?<planId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/LaptopPlan/{planId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + planId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetLaptopPlanById_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetLaptopPlanById" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetLaptopPlanById_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ILaptopPlanDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.LaptopPlanDetails.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetLaptopPlanById" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="planId">Id of the plan</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetLaptopPlanById_Validate(int planId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>This endpoint returns license information</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetLicenseInfo(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ILicenseInfo>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/License"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetLicenseInfo_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetLicenseInfo" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetLicenseInfo_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ILicenseInfo>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.LicenseInfo.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetLicenseInfo" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetLicenseInfo_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get a list of all the roles</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetListOfRoles(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRoleListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Role"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetListOfRoles_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetListOfRoles" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetListOfRoles_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRoleListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.RoleListResponse.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetListOfRoles" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetListOfRoles_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get details of a media agent based on id</summary>
        /// <param name="mediaAgentId">Id of the Media Agent whose details have to be fetched</param>
        /// <param name="showInheritedAssociation">Show inherited security association</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetMediaAgentDetails(int mediaAgentId, bool? showInheritedAssociation, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IMediaAgent>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/mediaAgent/"
                        + (mediaAgentId.ToString())
                        + "?"
                        + (null == showInheritedAssociation ? global::System.String.Empty : "showInheritedAssociation=" + global::System.Uri.EscapeDataString(showInheritedAssociation.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetMediaAgentDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get details of a media agent based on id</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="showInheritedAssociation">Show inherited security association</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetMediaAgentDetailsViaIdentity(global::System.String viaIdentity, bool? showInheritedAssociation, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IMediaAgent>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/mediaAgent/(?<mediaAgentId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/mediaAgent/{mediaAgentId}'");
                }

                // replace URI parameters with values from identity
                var mediaAgentId = _match.Groups["mediaAgentId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/mediaAgent/"
                        + mediaAgentId
                        + "?"
                        + (null == showInheritedAssociation ? global::System.String.Empty : "showInheritedAssociation=" + global::System.Uri.EscapeDataString(showInheritedAssociation.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetMediaAgentDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetMediaAgentDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetMediaAgentDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IMediaAgent>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.MediaAgent.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetMediaAgentDetails" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="mediaAgentId">Id of the Media Agent whose details have to be fetched</param>
        /// <param name="showInheritedAssociation">Show inherited security association</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetMediaAgentDetails_Validate(int mediaAgentId, bool? showInheritedAssociation, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get All Media Agents</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetMediaAgents(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IMediaAgentListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/mediaAgent"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetMediaAgents_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetMediaAgents" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetMediaAgents_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IMediaAgentListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.MediaAgentListResponse.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetMediaAgents" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetMediaAgents_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get details of a specific node of a hyperscale storage</summary>
        /// <param name="hyperScaleStorageId">Id of hyperscale storage</param>
        /// <param name="nodeId">Id of node</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetNodeDetailsOfHyperScaleStorage(int hyperScaleStorageId, int nodeId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHyperScaleNodeDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/HyperScale/"
                        + (hyperScaleStorageId.ToString())
                        + "/Node/"
                        + (nodeId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetNodeDetailsOfHyperScaleStorage_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get details of a specific node of a hyperscale storage</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetNodeDetailsOfHyperScaleStorageViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHyperScaleNodeDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/HyperScale/(?<hyperScaleStorageId>[^/]+)/Node/(?<nodeId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/HyperScale/{hyperScaleStorageId}/Node/{nodeId}'");
                }

                // replace URI parameters with values from identity
                var hyperScaleStorageId = _match.Groups["hyperScaleStorageId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/HyperScale/"
                        + hyperScaleStorageId
                        + "/Node/"
                        + nodeId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetNodeDetailsOfHyperScaleStorage_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetNodeDetailsOfHyperScaleStorage" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetNodeDetailsOfHyperScaleStorage_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IHyperScaleNodeDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.HyperScaleNodeDetails.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetNodeDetailsOfHyperScaleStorage" /> method. Call this like the actual call, but you
        /// will get validation events back.
        /// </summary>
        /// <param name="hyperScaleStorageId">Id of hyperscale storage</param>
        /// <param name="nodeId">Id of node</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetNodeDetailsOfHyperScaleStorage_Validate(int hyperScaleStorageId, int nodeId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get a list of categories and permissions in each category</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetPermissionResponse(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPermissionListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Permissions"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetPermissionResponse_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetPermissionResponse" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPermissionResponse_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPermissionListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PermissionListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetPermissionResponse" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPermissionResponse_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get Plan details</summary>
        /// <param name="planId">Id of the plan to fetch details</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetPlanById(int planId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IServerPlan>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + (planId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetPlanById_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get Plan details</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetPlanByIdViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IServerPlan>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerPlan/(?<planId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerPlan/{planId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + planId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetPlanById_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetPlanById" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanById_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IServerPlan>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.ServerPlan.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetPlanById" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="planId">Id of the plan to fetch details</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanById_Validate(int planId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get All Plans as Name Id Pairs</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetPlanIds(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IEntityDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/PlanIds"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetPlanIds_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetPlanIds" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanIds_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IEntityDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.EntityDetails.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetPlanIds" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanIds_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>
        /// API to fetch list of entities that are applicable for plan association via plan assignment rules.
        /// </summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetPlanRuleAssociatedEntities(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanRuleApplicableEntitiesList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule/Entities"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetPlanRuleAssociatedEntities_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetPlanRuleAssociatedEntities" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanRuleAssociatedEntities_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanRuleApplicableEntitiesList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanRuleApplicableEntitiesList.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetPlanRuleAssociatedEntities" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanRuleAssociatedEntities_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Api to fetch plan rules details.</summary>
        /// <param name="ruleId">Id of the rule to update in Plan</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetPlanRuleDetails(int ruleId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanEntityRuleInfo>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule/"
                        + (ruleId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetPlanRuleDetails_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Api to fetch plan rules details.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetPlanRuleDetailsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanEntityRuleInfo>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Plan/Rule/(?<ruleId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Plan/Rule/{ruleId}'");
                }

                // replace URI parameters with values from identity
                var ruleId = _match.Groups["ruleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule/"
                        + ruleId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetPlanRuleDetails_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetPlanRuleDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanRuleDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanEntityRuleInfo>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanEntityRuleInfo.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetPlanRuleDetails" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="ruleId">Id of the rule to update in Plan</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanRuleDetails_Validate(int ruleId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>API to get excluded workloads from plan rule evaluation framework</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetPlanRuleEntitiesExclude(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanRuleExcludedEntitiesList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule/Entities/Exclude"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetPlanRuleEntitiesExclude_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetPlanRuleEntitiesExclude" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanRuleEntitiesExclude_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanRuleExcludedEntitiesList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanRuleExcludedEntitiesList.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetPlanRuleEntitiesExclude" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanRuleEntitiesExclude_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>API to fetch plan rule execution settings</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onUnauthorized">a delegate that is called when the remote service returns 401 (Unauthorized).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetPlanRuleSettings(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanRuleExecutionSettings>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onUnauthorized, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule/Settings"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetPlanRuleSettings_Call(request,onOk,onUnauthorized,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetPlanRuleSettings" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onUnauthorized">a delegate that is called when the remote service returns 401 (Unauthorized).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanRuleSettings_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanRuleExecutionSettings>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onUnauthorized, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanRuleExecutionSettings.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Unauthorized:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onUnauthorized(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetPlanRuleSettings" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanRuleSettings_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Api to fetch plan rules list.</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetPlanRules(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanEntityRuleList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetPlanRules_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetPlanRules" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanRules_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanEntityRuleList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanEntityRuleList.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetPlanRules" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanRules_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get Plan Summary</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetPlanSummary(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanSummaryListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Summary"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetPlanSummary_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Api to fetch summary of a plan.</summary>
        /// <param name="planId">Id of the plan to get summary of</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetPlanSummary1(int planId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ISinglePlanSummary>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/v4/Plan/Summary/"
                        + (planId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetPlanSummary1_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Api to fetch summary of a plan.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetPlanSummary1ViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ISinglePlanSummary>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/v4/Plan/Summary/(?<planId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/v4/Plan/Summary/{planId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/v4/Plan/Summary/"
                        + planId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetPlanSummary1_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetPlanSummary1" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanSummary1_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ISinglePlanSummary>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.SinglePlanSummary.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetPlanSummary1" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="planId">Id of the plan to get summary of</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanSummary1_Validate(int planId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Actual wire call for <see cref="GetPlanSummary" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanSummary_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanSummaryListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanSummaryListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetPlanSummary" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetPlanSummary_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Retrieve list of projects for the request</summary>
        /// <param name="requestId">Unique request id</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetProjectsForRequest(int requestId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRmProjectsList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RequestManager/Request/"
                        + (requestId.ToString())
                        + "/Projects"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetProjectsForRequest_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Retrieve list of projects for the request</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetProjectsForRequestViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRmProjectsList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/RequestManager/Request/(?<requestId>[^/]+)/Projects$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/RequestManager/Request/{requestId}/Projects'");
                }

                // replace URI parameters with values from identity
                var requestId = _match.Groups["requestId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RequestManager/Request/"
                        + requestId
                        + "/Projects"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetProjectsForRequest_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetProjectsForRequest" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetProjectsForRequest_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRmProjectsList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.RmProjectsList.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetProjectsForRequest" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="requestId">Unique request id</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetProjectsForRequest_Validate(int requestId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertIsGreaterThanOrEqual(nameof(requestId),requestId,1);
            }
        }

        /// <summary>Fetch details about recovery point stores or library details</summary>
        /// <param name="rpsId"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetRecoveryPointStores(string rpsId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRecoveryPointStoreDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RecoveryPointStore/"
                        + global::System.Uri.EscapeDataString(rpsId)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetRecoveryPointStores_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Fetch details about recovery point stores or library details</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetRecoveryPointStoresViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRecoveryPointStoreDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/RecoveryPointStore/(?<rpsId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/RecoveryPointStore/{rpsId}'");
                }

                // replace URI parameters with values from identity
                var rpsId = _match.Groups["rpsId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RecoveryPointStore/"
                        + rpsId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetRecoveryPointStores_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetRecoveryPointStores" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRecoveryPointStores_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRecoveryPointStoreDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.RecoveryPointStoreDetails.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetRecoveryPointStores" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="rpsId"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRecoveryPointStores_Validate(string rpsId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(rpsId),rpsId);
            }
        }

        /// <summary>To get recovery target details by ID</summary>
        /// <param name="recoveryTargetId">id of recovery target</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetRecoveryTarget(int recoveryTargetId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPathsN53EymV4RecoverytargetRecoverytargetidGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RecoveryTarget/"
                        + (recoveryTargetId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetRecoveryTarget_Call(request,onOk,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>To get recovery target details by ID</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetRecoveryTargetViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPathsN53EymV4RecoverytargetRecoverytargetidGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/RecoveryTarget/(?<recoveryTargetId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/RecoveryTarget/{recoveryTargetId}'");
                }

                // replace URI parameters with values from identity
                var recoveryTargetId = _match.Groups["recoveryTargetId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RecoveryTarget/"
                        + recoveryTargetId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetRecoveryTarget_Call(request,onOk,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetRecoveryTarget" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRecoveryTarget_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPathsN53EymV4RecoverytargetRecoverytargetidGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PathsN53EymV4RecoverytargetRecoverytargetidGetResponses200ContentApplicationJsonSchema.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.ServiceUnavailable:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onServiceUnavailable(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetRecoveryTarget" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="recoveryTargetId">id of recovery target</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRecoveryTarget_Validate(int recoveryTargetId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get the list of recovery targets</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetRecoveryTargets(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetRecoveryTargetListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RecoveryTargets"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetRecoveryTargets_Call(request,onOk,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetRecoveryTargets" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRecoveryTargets_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetRecoveryTargetListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GetRecoveryTargetListResponse.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.ServiceUnavailable:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onServiceUnavailable(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetRecoveryTargets" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRecoveryTargets_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get details of the region</summary>
        /// <param name="regionId"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetRegionDetails(string regionId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRegionDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Regions/"
                        + global::System.Uri.EscapeDataString(regionId)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetRegionDetails_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Get details of the region</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetRegionDetailsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRegionDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Regions/(?<regionId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Regions/{regionId}'");
                }

                // replace URI parameters with values from identity
                var regionId = _match.Groups["regionId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Regions/"
                        + regionId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetRegionDetails_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetRegionDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRegionDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRegionDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.RegionDetails.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetRegionDetails" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="regionId"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRegionDetails_Validate(string regionId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(regionId),regionId);
            }
        }

        /// <summary>Api to fetch region details for an entity.</summary>
        /// <param name="entityType">Type of the entity</param>
        /// <param name="entityId">Unique id for the entity</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetRegionForEntity(string entityType, int entityId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdNameDisplayName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/entity/"
                        + global::System.Uri.EscapeDataString(entityType)
                        + "/"
                        + (entityId.ToString())
                        + "/region"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetRegionForEntity_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Api to fetch region details for an entity.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetRegionForEntityViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdNameDisplayName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/entity/(?<entityType>[^/]+)/(?<entityId>[^/]+)/region$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/entity/{entityType}/{entityId}/region'");
                }

                // replace URI parameters with values from identity
                var entityType = _match.Groups["entityType"].Value;
                var entityId = _match.Groups["entityId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/entity/"
                        + entityType
                        + "/"
                        + entityId
                        + "/region"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetRegionForEntity_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetRegionForEntity" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRegionForEntity_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdNameDisplayName>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.IdNameDisplayName.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetRegionForEntity" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="entityType">Type of the entity</param>
        /// <param name="entityId">Unique id for the entity</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRegionForEntity_Validate(string entityType, int entityId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(entityType),entityType);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(entityId),entityId,1);
            }
        }

        /// <summary>Get list of regions</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetRegions(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRegionsListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Regions"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetRegions_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetRegions" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRegions_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRegionsListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.RegionsListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetRegions" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRegions_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get all replication groups</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetReplicationGroups(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IReplicationGroupListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ReplicationGroup"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetReplicationGroups_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetReplicationGroups" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetReplicationGroups_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IReplicationGroupListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.ReplicationGroupListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetReplicationGroups" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetReplicationGroups_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get Continuous Replication Pair Details</summary>
        /// <param name="pairId"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetReplicationMonitorPairId(int pairId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IReplicationMonitorDetail>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ReplicationMonitor/"
                        + (pairId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetReplicationMonitorPairId_Call(request,onOk,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>Get Continuous Replication Pair Details</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetReplicationMonitorPairIdViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IReplicationMonitorDetail>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ReplicationMonitor/(?<pairId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ReplicationMonitor/{pairId}'");
                }

                // replace URI parameters with values from identity
                var pairId = _match.Groups["pairId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ReplicationMonitor/"
                        + pairId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetReplicationMonitorPairId_Call(request,onOk,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetReplicationMonitorPairId" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetReplicationMonitorPairId_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IReplicationMonitorDetail>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.ReplicationMonitorDetail.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.ServiceUnavailable:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onServiceUnavailable(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetReplicationMonitorPairId" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="pairId"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetReplicationMonitorPairId_Validate(int pairId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Retrieve details of an existing request</summary>
        /// <param name="requestId">Unique identifier for the request</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetRequestDetails(int requestId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRmRequestDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RequestManager/Request/"
                        + (requestId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetRequestDetails_Call(request,onOk,onBadRequest,onForbidden,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Retrieve details of an existing request</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetRequestDetailsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRmRequestDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/RequestManager/Request/(?<requestId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/RequestManager/Request/{requestId}'");
                }

                // replace URI parameters with values from identity
                var requestId = _match.Groups["requestId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RequestManager/Request/"
                        + requestId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetRequestDetails_Call(request,onOk,onBadRequest,onForbidden,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetRequestDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRequestDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRmRequestDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.RmRequestDetails.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Forbidden:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onForbidden(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetRequestDetails" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="requestId">Unique identifier for the request</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRequestDetails_Validate(int requestId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertIsGreaterThanOrEqual(nameof(requestId),requestId,1);
            }
        }

        /// <summary>Get All Resource Pools</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetResourcePools(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IResourcePoolListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ResourcePool"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetResourcePools_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetResourcePools" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetResourcePools_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IResourcePoolListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.ResourcePoolListResponse.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetResourcePools" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetResourcePools_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get a details of the role whose role id has been provided</summary>
        /// <param name="roleId">Role Id</param>
        /// <param name="showInheritedAssociation">Shows inherited security associations</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetRoleDetails(int roleId, bool? showInheritedAssociation, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRole>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Role/"
                        + (roleId.ToString())
                        + "?"
                        + (null == showInheritedAssociation ? global::System.String.Empty : "showInheritedAssociation=" + global::System.Uri.EscapeDataString(showInheritedAssociation.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetRoleDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get a details of the role whose role id has been provided</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="showInheritedAssociation">Shows inherited security associations</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetRoleDetailsViaIdentity(global::System.String viaIdentity, bool? showInheritedAssociation, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRole>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Role/(?<roleId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Role/{roleId}'");
                }

                // replace URI parameters with values from identity
                var roleId = _match.Groups["roleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Role/"
                        + roleId
                        + "?"
                        + (null == showInheritedAssociation ? global::System.String.Empty : "showInheritedAssociation=" + global::System.Uri.EscapeDataString(showInheritedAssociation.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetRoleDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetRoleDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRoleDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRole>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.Role.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetRoleDetails" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="roleId">Role Id</param>
        /// <param name="showInheritedAssociation">Shows inherited security associations</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetRoleDetails_Validate(int roleId, bool? showInheritedAssociation, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Gets details of SAML app based on SAML app name</summary>
        /// <param name="name"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetSamlApp(string name, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ISaml>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/SAML/"
                        + global::System.Uri.EscapeDataString(name)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetSamlApp_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Gets details of SAML app based on SAML app name</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetSamlAppViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ISaml>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/SAML/(?<name>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/SAML/{name}'");
                }

                // replace URI parameters with values from identity
                var name = _match.Groups["name"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/SAML/"
                        + name

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetSamlApp_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetSamlApp" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetSamlApp_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ISaml>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.Saml.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetSamlApp" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetSamlApp_Validate(string name, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(name),name);
            }
        }

        /// <summary>Get details of a serverGroup based on id</summary>
        /// <param name="serverGroupId">Id of the serverGroupId whose details have to be fetched</param>
        /// <param name="mode"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetServerGroupIdDetails(int serverGroupId, string mode, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IServerGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + (serverGroupId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != mode)
                {
                    request.Headers.Add("mode",mode);
                }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetServerGroupIdDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get details of a serverGroup based on id</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="mode"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetServerGroupIdDetailsViaIdentity(global::System.String viaIdentity, string mode, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IServerGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerGroup/(?<serverGroupId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerGroup/{serverGroupId}'");
                }

                // replace URI parameters with values from identity
                var serverGroupId = _match.Groups["serverGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup/"
                        + serverGroupId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != mode)
                {
                    request.Headers.Add("mode",mode);
                }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetServerGroupIdDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetServerGroupIdDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetServerGroupIdDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IServerGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.ServerGroup.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetServerGroupIdDetails" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="serverGroupId">Id of the serverGroupId whose details have to be fetched</param>
        /// <param name="mode"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetServerGroupIdDetails_Validate(int serverGroupId, string mode, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(mode),mode);
            }
        }

        /// <summary>Get All Server Groups</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetServerGroups(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetServerGroupsResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerGroup"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetServerGroups_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetServerGroups" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetServerGroups_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetServerGroupsResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GetServerGroupsResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetServerGroups" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetServerGroups_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>API to fetch schedules responsible for server plan RPO</summary>
        /// <param name="planId">Id of the Server Plan</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetServerPlanRpo(int planId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IServerPlanUpdateRpo>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + (planId.ToString())
                        + "/RPO"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetServerPlanRpo_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>API to fetch schedules responsible for server plan RPO</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetServerPlanRpoViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IServerPlanUpdateRpo>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerPlan/(?<planId>[^/]+)/RPO$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerPlan/{planId}/RPO'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + planId
                        + "/RPO"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetServerPlanRpo_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetServerPlanRpo" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetServerPlanRpo_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IServerPlanUpdateRpo>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.ServerPlanUpdateRpo.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetServerPlanRpo" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="planId">Id of the Server Plan</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetServerPlanRpo_Validate(int planId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>This end point returns the list of servers</summary>
        /// <param name="showOnlyInfrastructureMachines">Returns only infrastructure machines if value is 1 if 0, it returns all servers,
        /// default value is 1</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetServers(int? showOnlyInfrastructureMachines, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IServersListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Servers"
                        + "?"
                        + (null == showOnlyInfrastructureMachines ? global::System.String.Empty : "showOnlyInfrastructureMachines=" + global::System.Uri.EscapeDataString(showOnlyInfrastructureMachines.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetServers_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>API to get list of servers with no packages for a company</summary>
        /// <param name="companyId">Id of the Company whose servers(with no packages) have to be fetched</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetServersForCompany(int companyId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetPseudoClientsForCompanyResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Company/"
                        + (companyId.ToString())
                        + "/Servers"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetServersForCompany_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>API to get list of servers with no packages for a company</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetServersForCompanyViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetPseudoClientsForCompanyResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Company/(?<companyId>[^/]+)/Servers$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Company/{companyId}/Servers'");
                }

                // replace URI parameters with values from identity
                var companyId = _match.Groups["companyId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Company/"
                        + companyId
                        + "/Servers"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetServersForCompany_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetServersForCompany" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetServersForCompany_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetPseudoClientsForCompanyResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GetPseudoClientsForCompanyResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetServersForCompany" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="companyId">Id of the Company whose servers(with no packages) have to be fetched</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetServersForCompany_Validate(int companyId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>This end point returns the list of servers</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="showOnlyInfrastructureMachines">Returns only infrastructure machines if value is 1 if 0, it returns all servers,
        /// default value is 1</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetServersViaIdentity(global::System.String viaIdentity, int? showOnlyInfrastructureMachines, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IServersListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Servers$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Servers'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Servers"
                        + "?"
                        + (null == showOnlyInfrastructureMachines ? global::System.String.Empty : "showOnlyInfrastructureMachines=" + global::System.Uri.EscapeDataString(showOnlyInfrastructureMachines.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetServers_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetServers" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetServers_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IServersListResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.ServersListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetServers" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="showOnlyInfrastructureMachines">Returns only infrastructure machines if value is 1 if 0, it returns all servers,
        /// default value is 1</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetServers_Validate(int? showOnlyInfrastructureMachines, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Returns a list of Service Commcells</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetServiceCommcells(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths9Ld6GxV4ServicecommcellsGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServiceCommcells"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetServiceCommcells_Call(request,onOk,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetServiceCommcells" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetServiceCommcells_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths9Ld6GxV4ServicecommcellsGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.Paths9Ld6GxV4ServicecommcellsGetResponses200ContentApplicationJsonSchema.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.ServiceUnavailable:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onServiceUnavailable(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetServiceCommcells" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetServiceCommcells_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>
        /// API to fetch applicable workload solutions for the user like File Server, Virtualization or Database
        /// </summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetSolutionsId(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ISolutionsList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Solutions"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetSolutionsId_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetSolutionsId" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetSolutionsId_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ISolutionsList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.SolutionsList.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetSolutionsId" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetSolutionsId_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>This endpoint returns the details of a syslog server.</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetSyslogStatus(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ISyslogStatus>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/SyslogServer"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetSyslogStatus_Call(request,onOk,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetSyslogStatus" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetSyslogStatus_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ISyslogStatus>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.SyslogStatus.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.ServiceUnavailable:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onServiceUnavailable(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetSyslogStatus" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetSyslogStatus_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get details of triggered alert</summary>
        /// <param name="id"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetTriggeredAlertDetails(int id, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ITriggeredAlertsDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/TriggeredAlerts/"
                        + (id.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetTriggeredAlertDetails_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Get details of triggered alert</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetTriggeredAlertDetailsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ITriggeredAlertsDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/TriggeredAlerts/(?<id>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/TriggeredAlerts/{id}'");
                }

                // replace URI parameters with values from identity
                var id = _match.Groups["id"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/TriggeredAlerts/"
                        + id

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetTriggeredAlertDetails_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetTriggeredAlertDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetTriggeredAlertDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ITriggeredAlertsDetails>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.TriggeredAlertsDetails.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetTriggeredAlertDetails" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetTriggeredAlertDetails_Validate(int id, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get details of a User based on id</summary>
        /// <param name="userId">Id of the User whose details have to be fetched</param>
        /// <param name="mode"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetUserDetails(int userId, string mode, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IUser>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/user/"
                        + (userId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != mode)
                {
                    request.Headers.Add("mode",mode);
                }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetUserDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get details of a User based on id</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="mode"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetUserDetailsViaIdentity(global::System.String viaIdentity, string mode, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IUser>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/user/(?<userId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/user/{userId}'");
                }

                // replace URI parameters with values from identity
                var userId = _match.Groups["userId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/user/"
                        + userId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != mode)
                {
                    request.Headers.Add("mode",mode);
                }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetUserDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetUserDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetUserDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IUser>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.User.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetUserDetails" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="userId">Id of the User whose details have to be fetched</param>
        /// <param name="mode"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetUserDetails_Validate(int userId, string mode, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(mode),mode);
            }
        }

        /// <summary>Get details of a user-group based on id</summary>
        /// <param name="userGroupId">Id of the user-group whose details have to be fetched</param>
        /// <param name="mode"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetUserGroupDetails(int userGroupId, string mode, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IUserGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/UserGroup/"
                        + (userGroupId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != mode)
                {
                    request.Headers.Add("mode",mode);
                }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetUserGroupDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get details of a user-group based on id</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="mode"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetUserGroupDetailsViaIdentity(global::System.String viaIdentity, string mode, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IUserGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/UserGroup/(?<userGroupId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/UserGroup/{userGroupId}'");
                }

                // replace URI parameters with values from identity
                var userGroupId = _match.Groups["userGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/UserGroup/"
                        + userGroupId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != mode)
                {
                    request.Headers.Add("mode",mode);
                }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetUserGroupDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetUserGroupDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetUserGroupDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IUserGroup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.UserGroup.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetUserGroupDetails" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="userGroupId">Id of the user-group whose details have to be fetched</param>
        /// <param name="mode"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetUserGroupDetails_Validate(int userGroupId, string mode, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(mode),mode);
            }
        }

        /// <summary>Get a list of existing user groups.</summary>
        /// <param name="mode"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetUserGroups(string mode, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IUserGroupListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/UserGroup"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != mode)
                {
                    request.Headers.Add("mode",mode);
                }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetUserGroups_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get a list of existing user groups.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="mode"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetUserGroupsViaIdentity(global::System.String viaIdentity, string mode, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IUserGroupListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/UserGroup$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/UserGroup'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/UserGroup"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != mode)
                {
                    request.Headers.Add("mode",mode);
                }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetUserGroups_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetUserGroups" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetUserGroups_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IUserGroupListResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.UserGroupListResponse.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetUserGroups" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="mode"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetUserGroups_Validate(string mode, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(mode),mode);
            }
        }

        /// <summary>Get All Users</summary>
        /// <param name="laptopUsers">Returns only laptop users when set to true. This param is only effective when EdgeMode header
        /// is passed.</param>
        /// <param name="userGroupId">Returns the list of users associated to the userGroupId provided.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetUsers(bool? laptopUsers, int? userGroupId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IUserListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/user"
                        + "?"
                        + (null == laptopUsers ? global::System.String.Empty : "laptopUsers=" + global::System.Uri.EscapeDataString(laptopUsers.ToString()))
                        + "&"
                        + (null == userGroupId ? global::System.String.Empty : "userGroupId=" + global::System.Uri.EscapeDataString(userGroupId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetUsers_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get All Users</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="laptopUsers">Returns only laptop users when set to true. This param is only effective when EdgeMode header
        /// is passed.</param>
        /// <param name="userGroupId">Returns the list of users associated to the userGroupId provided.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetUsersViaIdentity(global::System.String viaIdentity, bool? laptopUsers, int? userGroupId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IUserListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/user$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/user'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/user"
                        + "?"
                        + (null == laptopUsers ? global::System.String.Empty : "laptopUsers=" + global::System.Uri.EscapeDataString(laptopUsers.ToString()))
                        + "&"
                        + (null == userGroupId ? global::System.String.Empty : "userGroupId=" + global::System.Uri.EscapeDataString(userGroupId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetUsers_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetUsers" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetUsers_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IUserListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.UserListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetUsers" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="laptopUsers">Returns only laptop users when set to true. This param is only effective when EdgeMode header
        /// is passed.</param>
        /// <param name="userGroupId">Returns the list of users associated to the userGroupId provided.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetUsers_Validate(bool? laptopUsers, int? userGroupId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get details for virtual machine</summary>
        /// <param name="vmUuid">The vmUUID can be obtained from GET /virtualMachines UUID property</param>
        /// <param name="showInheritedAssociation"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetVMDetails(string vmUuid, bool? showInheritedAssociation, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPathsCfcpthV4VirtualmachinesVmuuidGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VirtualMachines/"
                        + global::System.Uri.EscapeDataString(vmUuid)
                        + "?"
                        + (null == showInheritedAssociation ? global::System.String.Empty : "showInheritedAssociation=" + global::System.Uri.EscapeDataString(showInheritedAssociation.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetVMDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get details for virtual machine</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="showInheritedAssociation"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetVMDetailsViaIdentity(global::System.String viaIdentity, bool? showInheritedAssociation, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPathsCfcpthV4VirtualmachinesVmuuidGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/VirtualMachines/(?<vmUUID>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/VirtualMachines/{vmUUID}'");
                }

                // replace URI parameters with values from identity
                var vmUuid = _match.Groups["vmUUID"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VirtualMachines/"
                        + vmUuid
                        + "?"
                        + (null == showInheritedAssociation ? global::System.String.Empty : "showInheritedAssociation=" + global::System.Uri.EscapeDataString(showInheritedAssociation.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetVMDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetVMDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetVMDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPathsCfcpthV4VirtualmachinesVmuuidGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PathsCfcpthV4VirtualmachinesVmuuidGetResponses200ContentApplicationJsonSchema.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetVMDetails" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="vmUuid">The vmUUID can be obtained from GET /virtualMachines UUID property</param>
        /// <param name="showInheritedAssociation"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetVMDetails_Validate(string vmUuid, bool? showInheritedAssociation, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(vmUuid),vmUuid);
            }
        }

        /// <summary>Get the details of vmGroup</summary>
        /// <param name="vmGroupId">Id of the VmGroup to get</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetVMGroup(int vmGroupId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetVMGroupResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VmGroup/"
                        + (vmGroupId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetVMGroup_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Get the details of vmGroup</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetVMGroupViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetVMGroupResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/VmGroup/(?<VmGroupId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/VmGroup/{VmGroupId}'");
                }

                // replace URI parameters with values from identity
                var vmGroupId = _match.Groups["VmGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VmGroup/"
                        + vmGroupId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetVMGroup_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetVMGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetVMGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetVMGroupResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GetVMGroupResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetVMGroup" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="vmGroupId">Id of the VmGroup to get</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetVMGroup_Validate(int vmGroupId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get all virtual machines</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetVirtualMachines(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IVirtualMachineListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VirtualMachines"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetVirtualMachines_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetVirtualMachines" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetVirtualMachines_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IVirtualMachineListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.VirtualMachineListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetVirtualMachines" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetVirtualMachines_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>This endpoint is used to return the list of network topology.</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetfirewallTopology(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths8Zh6F2V4NetworktopologyGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/NetworkTopology"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetfirewallTopology_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>This endpoint is used to return the detail of network topology.</summary>
        /// <param name="topologyId"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetfirewallTopologyDetails(string topologyId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPathsCvbrweV4NetworktopologyTopologyidGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/NetworkTopology/"
                        + global::System.Uri.EscapeDataString(topologyId)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetfirewallTopologyDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>This endpoint is used to return the detail of network topology.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GetfirewallTopologyDetailsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPathsCvbrweV4NetworktopologyTopologyidGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/NetworkTopology/(?<topologyId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/NetworkTopology/{topologyId}'");
                }

                // replace URI parameters with values from identity
                var topologyId = _match.Groups["topologyId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/NetworkTopology/"
                        + topologyId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GetfirewallTopologyDetails_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GetfirewallTopologyDetails" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetfirewallTopologyDetails_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPathsCvbrweV4NetworktopologyTopologyidGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PathsCvbrweV4NetworktopologyTopologyidGetResponses200ContentApplicationJsonSchema.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetfirewallTopologyDetails" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="topologyId"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetfirewallTopologyDetails_Validate(string topologyId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(topologyId),topologyId);
            }
        }

        /// <summary>Actual wire call for <see cref="GetfirewallTopology" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetfirewallTopology_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPaths8Zh6F2V4NetworktopologyGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.Paths8Zh6F2V4NetworktopologyGetResponses200ContentApplicationJsonSchema.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GetfirewallTopology" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GetfirewallTopology_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <param name="globalSearchEntity">name of global search entity</param>
        /// <param name="fq">Filter criteria to filter out global search entities</param>
        /// <param name="groupBy">comma-seperated list of attributes based on which aggregate results would be grouped</param>
        /// <param name="func">aggregation function to be applied.</param>
        /// <param name="aggregateOn">attribute on which aggregation function would be applied.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GlobalSearch(string globalSearchEntity, string fq, string groupBy, string func, string aggregateOn, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGlobalEntityAggregationValueResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/"
                        + global::System.Uri.EscapeDataString(globalSearchEntity)
                        + "/aggregate"
                        + "?"
                        + (string.IsNullOrEmpty(fq) ? global::System.String.Empty : "fq=" + global::System.Uri.EscapeDataString(fq))
                        + "&"
                        + (string.IsNullOrEmpty(groupBy) ? global::System.String.Empty : "groupBy=" + global::System.Uri.EscapeDataString(groupBy))
                        + "&"
                        + "func=" + global::System.Uri.EscapeDataString(func)
                        + "&"
                        + (string.IsNullOrEmpty(aggregateOn) ? global::System.String.Empty : "aggregateOn=" + global::System.Uri.EscapeDataString(aggregateOn))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GlobalSearch_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <param name="viaIdentity"></param>
        /// <param name="fq">Filter criteria to filter out global search entities</param>
        /// <param name="groupBy">comma-seperated list of attributes based on which aggregate results would be grouped</param>
        /// <param name="func">aggregation function to be applied.</param>
        /// <param name="aggregateOn">attribute on which aggregation function would be applied.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task GlobalSearchViaIdentity(global::System.String viaIdentity, string fq, string groupBy, string func, string aggregateOn, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGlobalEntityAggregationValueResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/(?<globalSearchEntity>[^/]+)/aggregate$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/{globalSearchEntity}/aggregate'");
                }

                // replace URI parameters with values from identity
                var globalSearchEntity = _match.Groups["globalSearchEntity"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/"
                        + globalSearchEntity
                        + "/aggregate"
                        + "?"
                        + (string.IsNullOrEmpty(fq) ? global::System.String.Empty : "fq=" + global::System.Uri.EscapeDataString(fq))
                        + "&"
                        + (string.IsNullOrEmpty(groupBy) ? global::System.String.Empty : "groupBy=" + global::System.Uri.EscapeDataString(groupBy))
                        + "&"
                        + "func=" + global::System.Uri.EscapeDataString(func)
                        + "&"
                        + (string.IsNullOrEmpty(aggregateOn) ? global::System.String.Empty : "aggregateOn=" + global::System.Uri.EscapeDataString(aggregateOn))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.GlobalSearch_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="GlobalSearch" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GlobalSearch_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGlobalEntityAggregationValueResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GlobalEntityAggregationValueResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="GlobalSearch" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="globalSearchEntity">name of global search entity</param>
        /// <param name="fq">Filter criteria to filter out global search entities</param>
        /// <param name="groupBy">comma-seperated list of attributes based on which aggregate results would be grouped</param>
        /// <param name="func">aggregation function to be applied.</param>
        /// <param name="aggregateOn">attribute on which aggregation function would be applied.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task GlobalSearch_Validate(string globalSearchEntity, string fq, string groupBy, string func, string aggregateOn, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(globalSearchEntity),globalSearchEntity);
                await eventListener.AssertNotNull(nameof(fq),fq);
                await eventListener.AssertNotNull(nameof(groupBy),groupBy);
                await eventListener.AssertNotNull(nameof(func),func);
                await eventListener.AssertNotNull(nameof(aggregateOn),aggregateOn);
            }
        }

        /// <summary>To install MediaAgent package on a server</summary>
        /// <param name="body">Server information where you want to install MediaAgent package.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task InstallMediaAgent(Commvault.Powershell.Models.IInstallMediaAgent body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IJobId>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/mediaAgent"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.InstallMediaAgent_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="InstallMediaAgent" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task InstallMediaAgent_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IJobId>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.JobId.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="InstallMediaAgent" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">Server information where you want to install MediaAgent package.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task InstallMediaAgent_Validate(Commvault.Powershell.Models.IInstallMediaAgent body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Get the details of all Hypervisor</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ListHypervisors(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IListHypervisors>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Hypervisor"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ListHypervisors_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ListHypervisors" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ListHypervisors_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IListHypervisors>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.ListHypervisors.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ListHypervisors" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ListHypervisors_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Get the details of all cluster</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ListKubernetesCluster(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IListClusters>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Kubernetes/cluster"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ListKubernetesCluster_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ListKubernetesCluster" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ListKubernetesCluster_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IListClusters>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.ListClusters.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ListKubernetesCluster" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ListKubernetesCluster_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Modify Backup Destination for a Plan</summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="backupDestinationId">Id of the backupDestination to be modified</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyArchiveBackupDestination(int planId, int backupDestinationId, Commvault.Powershell.Models.IUpdateArchivePlanBackupDestination body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + (planId.ToString())
                        + "/BackupDestination/"
                        + (backupDestinationId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyArchiveBackupDestination_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Modify Backup Destination for a Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyArchiveBackupDestinationViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateArchivePlanBackupDestination body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ArchivePlan/(?<planId>[^/]+)/BackupDestination/(?<BackupDestinationId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ArchivePlan/{planId}/BackupDestination/{BackupDestinationId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                var backupDestinationId = _match.Groups["BackupDestinationId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + planId
                        + "/BackupDestination/"
                        + backupDestinationId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyArchiveBackupDestination_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyArchiveBackupDestination" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyArchiveBackupDestination_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanBackupDestinationResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyArchiveBackupDestination" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="backupDestinationId">Id of the backupDestination to be modified</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyArchiveBackupDestination_Validate(int planId, int backupDestinationId, Commvault.Powershell.Models.IUpdateArchivePlanBackupDestination body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify existing archive plan details</summary>
        /// <param name="planId">Id of the plan</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyArchivePlanById(int planId, Commvault.Powershell.Models.IUpdateArchivePlan body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + (planId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyArchivePlanById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Modify existing archive plan details</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyArchivePlanByIdViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateArchivePlan body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ArchivePlan/(?<planId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ArchivePlan/{planId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ArchivePlan/"
                        + planId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyArchivePlanById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyArchivePlanById" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyArchivePlanById_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyArchivePlanById" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="planId">Id of the plan</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyArchivePlanById_Validate(int planId, Commvault.Powershell.Models.IUpdateArchivePlan body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify Backup Destination for a Plan</summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="backupDestinationId">Id of the backupDestination to be modified</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyBackupDestination(int planId, int backupDestinationId, Commvault.Powershell.Models.IUpdatePlanBackupDestination body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + (planId.ToString())
                        + "/BackupDestination/"
                        + (backupDestinationId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyBackupDestination_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Modify Backup Destination for a Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyBackupDestinationViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdatePlanBackupDestination body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerPlan/(?<planId>[^/]+)/BackupDestination/(?<BackupDestinationId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerPlan/{planId}/BackupDestination/{BackupDestinationId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                var backupDestinationId = _match.Groups["BackupDestinationId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + planId
                        + "/BackupDestination/"
                        + backupDestinationId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyBackupDestination_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyBackupDestination" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyBackupDestination_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanBackupDestinationResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyBackupDestination" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="backupDestinationId">Id of the backupDestination to be modified</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyBackupDestination_Validate(int planId, int backupDestinationId, Commvault.Powershell.Models.IUpdatePlanBackupDestination body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify the properties of an existing mount path</summary>
        /// <param name="storagePoolId">Id of the disk storage to update</param>
        /// <param name="backupLocationId">Id of the backup location to update</param>
        /// <param name="body">While adding network access path, please add credentials or saved credentials. If both are provided,
        /// credentials will be selected.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyBackupLocation(int storagePoolId, int backupLocationId, Commvault.Powershell.Models.IUpdateBackupLocation body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + (storagePoolId.ToString())
                        + "/BackupLocation/"
                        + (backupLocationId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyBackupLocation_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Modify the properties of an existing mount path</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">While adding network access path, please add credentials or saved credentials. If both are provided,
        /// credentials will be selected.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyBackupLocationViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateBackupLocation body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Disk/(?<storagePoolId>[^/]+)/BackupLocation/(?<backupLocationId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Disk/{storagePoolId}/BackupLocation/{backupLocationId}'");
                }

                // replace URI parameters with values from identity
                var storagePoolId = _match.Groups["storagePoolId"].Value;
                var backupLocationId = _match.Groups["backupLocationId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + storagePoolId
                        + "/BackupLocation/"
                        + backupLocationId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyBackupLocation_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyBackupLocation" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyBackupLocation_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyBackupLocation" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="storagePoolId">Id of the disk storage to update</param>
        /// <param name="backupLocationId">Id of the backup location to update</param>
        /// <param name="body">While adding network access path, please add credentials or saved credentials. If both are provided,
        /// credentials will be selected.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyBackupLocation_Validate(int storagePoolId, int backupLocationId, Commvault.Powershell.Models.IUpdateBackupLocation body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify the properties of an existing Blackout Window</summary>
        /// <param name="blackoutWindowId">Id of the Blackout Window to update</param>
        /// <param name="body">company-refers to company to which the blackout window is associated.Dates have to be provided in unix
        /// time format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyBlackoutWindow(int blackoutWindowId, Commvault.Powershell.Models.IUpdateBlackoutWindow body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/BlackoutWindow/"
                        + (blackoutWindowId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyBlackoutWindow_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Modify the properties of an existing Blackout Window</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">company-refers to company to which the blackout window is associated.Dates have to be provided in unix
        /// time format.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyBlackoutWindowViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateBlackoutWindow body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/BlackoutWindow/(?<blackoutWindowId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/BlackoutWindow/{blackoutWindowId}'");
                }

                // replace URI parameters with values from identity
                var blackoutWindowId = _match.Groups["blackoutWindowId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/BlackoutWindow/"
                        + blackoutWindowId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyBlackoutWindow_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyBlackoutWindow" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyBlackoutWindow_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyBlackoutWindow" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="blackoutWindowId">Id of the Blackout Window to update</param>
        /// <param name="body">company-refers to company to which the blackout window is associated.Dates have to be provided in unix
        /// time format.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyBlackoutWindow_Validate(int blackoutWindowId, Commvault.Powershell.Models.IUpdateBlackoutWindow body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify configuration of a specific bucket of a specific cloud storage</summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="bucketId">Id of Bucket</param>
        /// <param name="body">CloudBucketConfiguration</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyBucketOfCloudStorage(int cloudStorageId, int bucketId, Commvault.Powershell.Models.ICloudBucketConfiguration body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + (cloudStorageId.ToString())
                        + "/Bucket/"
                        + (bucketId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyBucketOfCloudStorage_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Modify configuration of a specific bucket of a specific cloud storage</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">CloudBucketConfiguration</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyBucketOfCloudStorageViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.ICloudBucketConfiguration body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Cloud/(?<cloudStorageId>[^/]+)/Bucket/(?<bucketId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Cloud/{cloudStorageId}/Bucket/{bucketId}'");
                }

                // replace URI parameters with values from identity
                var cloudStorageId = _match.Groups["cloudStorageId"].Value;
                var bucketId = _match.Groups["bucketId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + cloudStorageId
                        + "/Bucket/"
                        + bucketId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyBucketOfCloudStorage_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyBucketOfCloudStorage" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyBucketOfCloudStorage_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyBucketOfCloudStorage" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="bucketId">Id of Bucket</param>
        /// <param name="body">CloudBucketConfiguration</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyBucketOfCloudStorage_Validate(int cloudStorageId, int bucketId, Commvault.Powershell.Models.ICloudBucketConfiguration body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// Modify details like credentials and path for metadata Cache of a cloud storage based on Id
        /// </summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="metadataCacheId">Id of metadata cache</param>
        /// <param name="body">If updating to a network access path, Please add credentials or saved credentials. If both are provided,
        /// credentials will be taken into consideration.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyCloudStorageMetaDataCacheById(int cloudStorageId, int metadataCacheId, Commvault.Powershell.Models.IUpdateMetadataCacheConfiguration body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + (cloudStorageId.ToString())
                        + "/MetadataCache/"
                        + (metadataCacheId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyCloudStorageMetaDataCacheById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>
        /// Modify details like credentials and path for metadata Cache of a cloud storage based on Id
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">If updating to a network access path, Please add credentials or saved credentials. If both are provided,
        /// credentials will be taken into consideration.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyCloudStorageMetaDataCacheByIdViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateMetadataCacheConfiguration body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Cloud/(?<cloudStorageId>[^/]+)/MetadataCache/(?<metadataCacheId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Cloud/{cloudStorageId}/MetadataCache/{metadataCacheId}'");
                }

                // replace URI parameters with values from identity
                var cloudStorageId = _match.Groups["cloudStorageId"].Value;
                var metadataCacheId = _match.Groups["metadataCacheId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Cloud/"
                        + cloudStorageId
                        + "/MetadataCache/"
                        + metadataCacheId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyCloudStorageMetaDataCacheById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyCloudStorageMetaDataCacheById" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyCloudStorageMetaDataCacheById_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyCloudStorageMetaDataCacheById" /> method. Call this like the actual call, but you
        /// will get validation events back.
        /// </summary>
        /// <param name="cloudStorageId">Id of cloud Storage</param>
        /// <param name="metadataCacheId">Id of metadata cache</param>
        /// <param name="body">If updating to a network access path, Please add credentials or saved credentials. If both are provided,
        /// credentials will be taken into consideration.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyCloudStorageMetaDataCacheById_Validate(int cloudStorageId, int metadataCacheId, Commvault.Powershell.Models.IUpdateMetadataCacheConfiguration body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify the properties of an existing company</summary>
        /// <param name="companyId">Id of the company to update</param>
        /// <param name="body">Used to update the properties of an existing company</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyCompany(int companyId, Commvault.Powershell.Models.IUpdateCompany body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/company/"
                        + (companyId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyCompany_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Modify the properties of an existing company</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">Used to update the properties of an existing company</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyCompanyViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateCompany body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/company/(?<companyId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/company/{companyId}'");
                }

                // replace URI parameters with values from identity
                var companyId = _match.Groups["companyId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/company/"
                        + companyId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyCompany_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyCompany" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyCompany_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyCompany" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="companyId">Id of the company to update</param>
        /// <param name="body">Used to update the properties of an existing company</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyCompany_Validate(int companyId, Commvault.Powershell.Models.IUpdateCompany body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify the properties of an existing disk storage pool</summary>
        /// <param name="storagePoolId">Id of the disk storage to update</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyDiskStorage(int storagePoolId, Commvault.Powershell.Models.IUpdateDiskStorage body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + (storagePoolId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyDiskStorage_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Modify the properties of an existing disk storage pool</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyDiskStorageViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateDiskStorage body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/Disk/(?<storagePoolId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/Disk/{storagePoolId}'");
                }

                // replace URI parameters with values from identity
                var storagePoolId = _match.Groups["storagePoolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Disk/"
                        + storagePoolId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyDiskStorage_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyDiskStorage" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyDiskStorage_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyDiskStorage" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="storagePoolId">Id of the disk storage to update</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyDiskStorage_Validate(int storagePoolId, Commvault.Powershell.Models.IUpdateDiskStorage body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// Modify entity settings used to change default behaviour for linked entity like servers or server groups
        /// </summary>
        /// <param name="body">ModifyEntitySettings</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyEntitySettings(Commvault.Powershell.Models.IModifyEntitySettings body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/EntitySettings"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyEntitySettings_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyEntitySettings" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyEntitySettings_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyEntitySettings" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">ModifyEntitySettings</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyEntitySettings_Validate(Commvault.Powershell.Models.IModifyEntitySettings body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify global settings used to override system default behaviour</summary>
        /// <param name="body">ModifyGlobalSettings</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyGlobalSettings(Commvault.Powershell.Models.IModifyGlobalSettings body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/GlobalSettings"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyGlobalSettings_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyGlobalSettings" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyGlobalSettings_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyGlobalSettings" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">ModifyGlobalSettings</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyGlobalSettings_Validate(Commvault.Powershell.Models.IModifyGlobalSettings body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify details like name, encryption, security of a specific hyperscale storage</summary>
        /// <param name="hyperScaleStorageId">Id of hyperscale storage</param>
        /// <param name="body">UpdateHyperScaleStorage</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyHyperScaleStorageById(int hyperScaleStorageId, Commvault.Powershell.Models.IUpdateHyperScaleStorage body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/HyperScale/"
                        + (hyperScaleStorageId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyHyperScaleStorageById_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Modify details like name, encryption, security of a specific hyperscale storage</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">UpdateHyperScaleStorage</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyHyperScaleStorageByIdViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateHyperScaleStorage body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/HyperScale/(?<hyperScaleStorageId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/HyperScale/{hyperScaleStorageId}'");
                }

                // replace URI parameters with values from identity
                var hyperScaleStorageId = _match.Groups["hyperScaleStorageId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/HyperScale/"
                        + hyperScaleStorageId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyHyperScaleStorageById_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyHyperScaleStorageById" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyHyperScaleStorageById_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyHyperScaleStorageById" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="hyperScaleStorageId">Id of hyperscale storage</param>
        /// <param name="body">UpdateHyperScaleStorage</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyHyperScaleStorageById_Validate(int hyperScaleStorageId, Commvault.Powershell.Models.IUpdateHyperScaleStorage body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify Backup Destination for a Plan</summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="backupDestinationId">Id of the backupDestination to be modified</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyLaptopBackupDestination(int planId, int backupDestinationId, Commvault.Powershell.Models.IUpdatePlanBackupDestination body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + (planId.ToString())
                        + "/BackupDestination/"
                        + (backupDestinationId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyLaptopBackupDestination_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Modify Backup Destination for a Plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyLaptopBackupDestinationViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdatePlanBackupDestination body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/LaptopPlan/(?<planId>[^/]+)/BackupDestination/(?<BackupDestinationId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/LaptopPlan/{planId}/BackupDestination/{BackupDestinationId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                var backupDestinationId = _match.Groups["BackupDestinationId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + planId
                        + "/BackupDestination/"
                        + backupDestinationId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyLaptopBackupDestination_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyLaptopBackupDestination" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyLaptopBackupDestination_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPlanBackupDestinationResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PlanBackupDestinationResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyLaptopBackupDestination" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="planId">Id of the Plan to modify</param>
        /// <param name="backupDestinationId">Id of the backupDestination to be modified</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyLaptopBackupDestination_Validate(int planId, int backupDestinationId, Commvault.Powershell.Models.IUpdatePlanBackupDestination body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify existing laptop plan details</summary>
        /// <param name="planId">Id of the plan</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyLaptopPlanById(int planId, Commvault.Powershell.Models.IUpdateLaptopPlan body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + (planId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyLaptopPlanById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Modify existing laptop plan details</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyLaptopPlanByIdViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateLaptopPlan body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/LaptopPlan/(?<planId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/LaptopPlan/{planId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopPlan/"
                        + planId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyLaptopPlanById_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyLaptopPlanById" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyLaptopPlanById_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyLaptopPlanById" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="planId">Id of the plan</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyLaptopPlanById_Validate(int planId, Commvault.Powershell.Models.IUpdateLaptopPlan body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify the properties of an existing media agent</summary>
        /// <param name="mediaAgentId">Id of the mediaAgent to update</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyMediaAgent(int mediaAgentId, Commvault.Powershell.Models.IUpdateMediaAgent body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/mediaAgent/"
                        + (mediaAgentId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyMediaAgent_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Modify the properties of an existing media agent</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyMediaAgentViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateMediaAgent body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/mediaAgent/(?<mediaAgentId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/mediaAgent/{mediaAgentId}'");
                }

                // replace URI parameters with values from identity
                var mediaAgentId = _match.Groups["mediaAgentId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/mediaAgent/"
                        + mediaAgentId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyMediaAgent_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyMediaAgent" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyMediaAgent_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyMediaAgent" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="mediaAgentId">Id of the mediaAgent to update</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyMediaAgent_Validate(int mediaAgentId, Commvault.Powershell.Models.IUpdateMediaAgent body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Used to modify an exsiting server plan</summary>
        /// <param name="planId">Id of the Plan to update</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyPlan(int planId, Commvault.Powershell.Models.IUpdateServerPlan body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + (planId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyPlan_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Used to modify an exsiting server plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyPlanViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateServerPlan body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerPlan/(?<planId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerPlan/{planId}'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + planId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyPlan_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyPlan" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyPlan_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyPlan" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="planId">Id of the Plan to update</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyPlan_Validate(int planId, Commvault.Powershell.Models.IUpdateServerPlan body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify the properties of an existing replication group</summary>
        /// <param name="replicationGroupId"></param>
        /// <param name="body">UpdateReplicationGroupReq</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyReplicationGroup(string replicationGroupId, Commvault.Powershell.Models.IUpdateReplicationGroup body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ReplicationGroup/"
                        + global::System.Uri.EscapeDataString(replicationGroupId)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyReplicationGroup_Call(request,onOk,onBadRequest,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Modify the properties of an existing replication group</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">UpdateReplicationGroupReq</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyReplicationGroupViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateReplicationGroup body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ReplicationGroup/(?<replicationGroupId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ReplicationGroup/{replicationGroupId}'");
                }

                // replace URI parameters with values from identity
                var replicationGroupId = _match.Groups["replicationGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ReplicationGroup/"
                        + replicationGroupId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyReplicationGroup_Call(request,onOk,onBadRequest,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyReplicationGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyReplicationGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyReplicationGroup" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="replicationGroupId"></param>
        /// <param name="body">UpdateReplicationGroupReq</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyReplicationGroup_Validate(string replicationGroupId, Commvault.Powershell.Models.IUpdateReplicationGroup body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(replicationGroupId),replicationGroupId);
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify the properties of an existing role</summary>
        /// <param name="roleId">Role Id</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyRole(int roleId, Commvault.Powershell.Models.IUpdateRole body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Role/"
                        + (roleId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyRole_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Modify the properties of an existing role</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyRoleViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateRole body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Role/(?<roleId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Role/{roleId}'");
                }

                // replace URI parameters with values from identity
                var roleId = _match.Groups["roleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Role/"
                        + roleId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyRole_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyRole" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyRole_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyRole" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="roleId">Role Id</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyRole_Validate(int roleId, Commvault.Powershell.Models.IUpdateRole body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>API to update pattern for schedule in schedule policy</summary>
        /// <param name="schedulePolicyId"></param>
        /// <param name="scheduleId"></param>
        /// <param name="body">If updating pattern, the value which needs to be retained also needs to be provided along with the
        /// updated value</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifySchedulePattern(string schedulePolicyId, string scheduleId, Commvault.Powershell.Models.IPlanPattern body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/SchedulePolicy/"
                        + global::System.Uri.EscapeDataString(schedulePolicyId)
                        + "/Schedule/"
                        + global::System.Uri.EscapeDataString(scheduleId)
                        + "/Pattern"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifySchedulePattern_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>API to update pattern for schedule in schedule policy</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">If updating pattern, the value which needs to be retained also needs to be provided along with the
        /// updated value</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifySchedulePatternViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IPlanPattern body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/SchedulePolicy/(?<schedulePolicyId>[^/]+)/Schedule/(?<scheduleId>[^/]+)/Pattern$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/SchedulePolicy/{schedulePolicyId}/Schedule/{scheduleId}/Pattern'");
                }

                // replace URI parameters with values from identity
                var schedulePolicyId = _match.Groups["schedulePolicyId"].Value;
                var scheduleId = _match.Groups["scheduleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/SchedulePolicy/"
                        + schedulePolicyId
                        + "/Schedule/"
                        + scheduleId
                        + "/Pattern"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifySchedulePattern_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifySchedulePattern" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifySchedulePattern_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifySchedulePattern" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="schedulePolicyId"></param>
        /// <param name="scheduleId"></param>
        /// <param name="body">If updating pattern, the value which needs to be retained also needs to be provided along with the
        /// updated value</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifySchedulePattern_Validate(string schedulePolicyId, string scheduleId, Commvault.Powershell.Models.IPlanPattern body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(schedulePolicyId),schedulePolicyId);
                await eventListener.AssertNotNull(nameof(scheduleId),scheduleId);
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Add, Modify and Delete notes for triggered alerts</summary>
        /// <param name="id"></param>
        /// <param name="body">UpdateTriggeredAlertsNotes</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyTriggeredAlertsNotes(int id, Commvault.Powershell.Models.IUpdateTriggeredAlertsNotes body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/TriggeredAlerts/"
                        + (id.ToString())
                        + "/Notes"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyTriggeredAlertsNotes_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Add, Modify and Delete notes for triggered alerts</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">UpdateTriggeredAlertsNotes</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyTriggeredAlertsNotesViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateTriggeredAlertsNotes body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/TriggeredAlerts/(?<id>[^/]+)/Notes$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/TriggeredAlerts/{id}/Notes'");
                }

                // replace URI parameters with values from identity
                var id = _match.Groups["id"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/TriggeredAlerts/"
                        + id
                        + "/Notes"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyTriggeredAlertsNotes_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyTriggeredAlertsNotes" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyTriggeredAlertsNotes_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyTriggeredAlertsNotes" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="body">UpdateTriggeredAlertsNotes</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyTriggeredAlertsNotes_Validate(int id, Commvault.Powershell.Models.IUpdateTriggeredAlertsNotes body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Used to modify an existing user</summary>
        /// <param name="userId">Id of the User to update</param>
        /// <param name="body">Used to update an existing user.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyUser(int userId, Commvault.Powershell.Models.IUpdateUser body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/user/"
                        + (userId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyUser_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Modify the properties of an existing user-group</summary>
        /// <param name="userGroupId">Id of the user-group to update</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyUserGroup(int userGroupId, Commvault.Powershell.Models.IUpdateUserGroup body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/UserGroup/"
                        + (userGroupId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyUserGroup_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Modify the properties of an existing user-group</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyUserGroupViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateUserGroup body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/UserGroup/(?<userGroupId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/UserGroup/{userGroupId}'");
                }

                // replace URI parameters with values from identity
                var userGroupId = _match.Groups["userGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/UserGroup/"
                        + userGroupId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyUserGroup_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyUserGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyUserGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyUserGroup" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="userGroupId">Id of the user-group to update</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyUserGroup_Validate(int userGroupId, Commvault.Powershell.Models.IUpdateUserGroup body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Used to modify an existing user</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">Used to update an existing user.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyUserViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateUser body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/user/(?<userId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/user/{userId}'");
                }

                // replace URI parameters with values from identity
                var userId = _match.Groups["userId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/user/"
                        + userId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyUser_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyUser" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyUser_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyUser" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="userId">Id of the User to update</param>
        /// <param name="body">Used to update an existing user.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyUser_Validate(int userId, Commvault.Powershell.Models.IUpdateUser body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Modify the properties of an existing virtual machine</summary>
        /// <param name="vmUuid">The vmUUID can be obtained from GET /virtualMachines UUID property</param>
        /// <param name="body">UpdateVMProperties</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onUnauthorized">a delegate that is called when the remote service returns 401 (Unauthorized).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyVirtualMachine(string vmUuid, Commvault.Powershell.Models.IUpdateVMProperties body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onUnauthorized, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VirtualMachines/"
                        + global::System.Uri.EscapeDataString(vmUuid)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyVirtualMachine_Call(request,onOk,onUnauthorized,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Modify the properties of an existing virtual machine</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">UpdateVMProperties</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onUnauthorized">a delegate that is called when the remote service returns 401 (Unauthorized).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ModifyVirtualMachineViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateVMProperties body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onUnauthorized, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/VirtualMachines/(?<vmUUID>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/VirtualMachines/{vmUUID}'");
                }

                // replace URI parameters with values from identity
                var vmUuid = _match.Groups["vmUUID"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VirtualMachines/"
                        + vmUuid

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ModifyVirtualMachine_Call(request,onOk,onUnauthorized,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ModifyVirtualMachine" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onUnauthorized">a delegate that is called when the remote service returns 401 (Unauthorized).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyVirtualMachine_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onUnauthorized, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Unauthorized:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onUnauthorized(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ModifyVirtualMachine" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="vmUuid">The vmUUID can be obtained from GET /virtualMachines UUID property</param>
        /// <param name="body">UpdateVMProperties</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ModifyVirtualMachine_Validate(string vmUuid, Commvault.Powershell.Models.IUpdateVMProperties body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(vmUuid),vmUuid);
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Pin triggered alerts</summary>
        /// <param name="id"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PinTriggeredAlerts(int id, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/TriggeredAlerts/"
                        + (id.ToString())
                        + "/Pin"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PinTriggeredAlerts_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Pin triggered alerts</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PinTriggeredAlertsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/TriggeredAlerts/(?<id>[^/]+)/Pin$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/TriggeredAlerts/{id}/Pin'");
                }

                // replace URI parameters with values from identity
                var id = _match.Groups["id"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/TriggeredAlerts/"
                        + id
                        + "/Pin"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PinTriggeredAlerts_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PinTriggeredAlerts" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PinTriggeredAlerts_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PinTriggeredAlerts" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PinTriggeredAlerts_Validate(int id, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>This endpoint is used to create network topology.</summary>
        /// <param name="body">FirewallTopologyReq</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PostFirewallTopology(Commvault.Powershell.Models.IFirewallTopologyCreateReq body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IFirewallTopologyCreateResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/NetworkTopology"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PostFirewallTopology_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PostFirewallTopology" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PostFirewallTopology_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IFirewallTopologyCreateResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.FirewallTopologyCreateResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PostFirewallTopology" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">FirewallTopologyReq</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PostFirewallTopology_Validate(Commvault.Powershell.Models.IFirewallTopologyCreateReq body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Simplified API to create a laptop</summary>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PostLaptop(Commvault.Powershell.Models.IAddLaptop body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAddLaptopResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Laptop"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PostLaptop_Call(request,onOk,onBadRequest,onNotFound,eventListener,sender);
            }
        }

        /// <summary>API to create laptop owner mappings</summary>
        /// <param name="body">List of laptop owner mappings to be added</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PostLaptopOwnerMapping(Commvault.Powershell.Models.ICreateLaptopOwnerMapping body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopOwnerMapping"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PostLaptopOwnerMapping_Call(request,onOk,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PostLaptopOwnerMapping" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PostLaptopOwnerMapping_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.ServiceUnavailable:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onServiceUnavailable(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PostLaptopOwnerMapping" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">List of laptop owner mappings to be added</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PostLaptopOwnerMapping_Validate(Commvault.Powershell.Models.ICreateLaptopOwnerMapping body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Actual wire call for <see cref="PostLaptop" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PostLaptop_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IAddLaptopResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.AddLaptopResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PostLaptop" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PostLaptop_Validate(Commvault.Powershell.Models.IAddLaptop body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Updates owner permissions and/or automatic laptop ownership assignment</summary>
        /// <param name="body">Owner permissions and laptop ownership details</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PutAccessControl(Commvault.Powershell.Models.IAccessControl body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/AccessControl"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PutAccessControl_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PutAccessControl" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutAccessControl_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PutAccessControl" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">Owner permissions and laptop ownership details</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutAccessControl_Validate(Commvault.Powershell.Models.IAccessControl body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>API to update existing laptop owner mapping</summary>
        /// <param name="body">List of laptop owner mappings to update.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PutLaptopOwnerMapping(Commvault.Powershell.Models.ILaptopOwnerMapping body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LaptopOwnerMapping"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PutLaptopOwnerMapping_Call(request,onOk,onNotFound,onServiceUnavailable,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PutLaptopOwnerMapping" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onServiceUnavailable">a delegate that is called when the remote service returns 503 (ServiceUnavailable).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutLaptopOwnerMapping_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onServiceUnavailable, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.ServiceUnavailable:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onServiceUnavailable(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PutLaptopOwnerMapping" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">List of laptop owner mappings to update.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutLaptopOwnerMapping_Validate(Commvault.Powershell.Models.ILaptopOwnerMapping body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>API to send request to process plan rules against specific set of entities.</summary>
        /// <param name="body">Request body will consist of entities that are need to be evaluated against plan rules.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PutPlanRuleAssociatedEntities(Commvault.Powershell.Models.IExecutePlanRules body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule/Entities"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PutPlanRuleAssociatedEntities_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PutPlanRuleAssociatedEntities" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutPlanRuleAssociatedEntities_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PutPlanRuleAssociatedEntities" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="body">Request body will consist of entities that are need to be evaluated against plan rules.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutPlanRuleAssociatedEntities_Validate(Commvault.Powershell.Models.IExecutePlanRules body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>API to associate workloads to selected plan and plan rule</summary>
        /// <param name="body">List of entities that are will be associated to provided plan and said rule</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PutPlanRuleEntitiesAssociate(Commvault.Powershell.Models.IAssociatePlanRuleEntityList body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule/Entities/Associate"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PutPlanRuleEntitiesAssociate_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PutPlanRuleEntitiesAssociate" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutPlanRuleEntitiesAssociate_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PutPlanRuleEntitiesAssociate" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="body">List of entities that are will be associated to provided plan and said rule</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutPlanRuleEntitiesAssociate_Validate(Commvault.Powershell.Models.IAssociatePlanRuleEntityList body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>API to exclude workloads from plan rule evaluation framework</summary>
        /// <param name="body">Entities that need to be excluded from plan rule evaluation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PutPlanRuleEntitiesExclude(Commvault.Powershell.Models.IExcludeEntitiesFromPlanRuleEvaluation body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule/Entities/Exclude"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PutPlanRuleEntitiesExclude_Call(request,onOk,onForbidden,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PutPlanRuleEntitiesExclude" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutPlanRuleEntitiesExclude_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Forbidden:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onForbidden(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PutPlanRuleEntitiesExclude" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="body">Entities that need to be excluded from plan rule evaluation</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutPlanRuleEntitiesExclude_Validate(Commvault.Powershell.Models.IExcludeEntitiesFromPlanRuleEvaluation body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>API to include workloads to be applicable for plan rule evaluation.</summary>
        /// <param name="body">Entities that need to be included for plan rule evaluation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PutPlanRuleEntitiesInclude(Commvault.Powershell.Models.IIncludeEntitiesForPlanRuleEvaluation body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule/Entities/Include"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PutPlanRuleEntitiesInclude_Call(request,onOk,onForbidden,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PutPlanRuleEntitiesInclude" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutPlanRuleEntitiesInclude_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Forbidden:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onForbidden(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PutPlanRuleEntitiesInclude" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="body">Entities that need to be included for plan rule evaluation</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutPlanRuleEntitiesInclude_Validate(Commvault.Powershell.Models.IIncludeEntitiesForPlanRuleEvaluation body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>API to set plan rule execution settings</summary>
        /// <param name="body">Message object to hold settings for plan rule execution.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onUnauthorized">a delegate that is called when the remote service returns 401 (Unauthorized).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PutPlanRuleSettings(Commvault.Powershell.Models.IPlanRuleExecutionSettings body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onUnauthorized, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule/Settings"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PutPlanRuleSettings_Call(request,onOk,onUnauthorized,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PutPlanRuleSettings" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onUnauthorized">a delegate that is called when the remote service returns 401 (Unauthorized).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutPlanRuleSettings_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onUnauthorized, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Unauthorized:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onUnauthorized(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PutPlanRuleSettings" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">Message object to hold settings for plan rule execution.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutPlanRuleSettings_Validate(Commvault.Powershell.Models.IPlanRuleExecutionSettings body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>This endpoint is used to edit network topology.</summary>
        /// <param name="topologyId"></param>
        /// <param name="body">FirewallTopologyReq</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PutfirewallTopology(string topologyId, Commvault.Powershell.Models.IFirewallTopologyCreateReq body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/NetworkTopology/"
                        + global::System.Uri.EscapeDataString(topologyId)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PutfirewallTopology_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>This endpoint is used to edit network topology.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">FirewallTopologyReq</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PutfirewallTopologyViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IFirewallTopologyCreateReq body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/NetworkTopology/(?<topologyId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/NetworkTopology/{topologyId}'");
                }

                // replace URI parameters with values from identity
                var topologyId = _match.Groups["topologyId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/NetworkTopology/"
                        + topologyId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PutfirewallTopology_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="PutfirewallTopology" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutfirewallTopology_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PutfirewallTopology" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="topologyId"></param>
        /// <param name="body">FirewallTopologyReq</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PutfirewallTopology_Validate(string topologyId, Commvault.Powershell.Models.IFirewallTopologyCreateReq body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(topologyId),topologyId);
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>REconfigures and Renew License for the hypervisor client</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ReConfigureHypervisor(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Hypervisor/{hypervisorId}/Reconfigure"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ReConfigureHypervisor_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ReConfigureHypervisor" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ReConfigureHypervisor_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ReConfigureHypervisor" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ReConfigureHypervisor_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Refresh a specific node of HyperScale</summary>
        /// <param name="hyperScaleStorageId">Id of hyperscale storage</param>
        /// <param name="nodeId">Id of node</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task RefreshNodeOfHyperScaleStorage(int hyperScaleStorageId, int nodeId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/HyperScale/"
                        + (hyperScaleStorageId.ToString())
                        + "/Node/"
                        + (nodeId.ToString())
                        + "/Refresh"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.RefreshNodeOfHyperScaleStorage_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Refresh a specific node of HyperScale</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task RefreshNodeOfHyperScaleStorageViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Storage/HyperScale/(?<hyperScaleStorageId>[^/]+)/Node/(?<nodeId>[^/]+)/Refresh$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Storage/HyperScale/{hyperScaleStorageId}/Node/{nodeId}/Refresh'");
                }

                // replace URI parameters with values from identity
                var hyperScaleStorageId = _match.Groups["hyperScaleStorageId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/HyperScale/"
                        + hyperScaleStorageId
                        + "/Node/"
                        + nodeId
                        + "/Refresh"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.RefreshNodeOfHyperScaleStorage_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="RefreshNodeOfHyperScaleStorage" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task RefreshNodeOfHyperScaleStorage_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="RefreshNodeOfHyperScaleStorage" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="hyperScaleStorageId">Id of hyperscale storage</param>
        /// <param name="nodeId">Id of node</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task RefreshNodeOfHyperScaleStorage_Validate(int hyperScaleStorageId, int nodeId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Retrieves the list of Requests</summary>
        /// <param name="createdFrom">Source application of the request</param>
        /// <param name="sourceEntityType">Entity type of the source from which data is gathered for the request</param>
        /// <param name="sourceEntityId">Entity id of the source from which data is gathered for the request</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task RequestManagerRequestList(string createdFrom, string sourceEntityType, int? sourceEntityId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRmRequestList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RequestManager/Request"
                        + "?"
                        + (string.IsNullOrEmpty(createdFrom) ? global::System.String.Empty : "createdFrom=" + global::System.Uri.EscapeDataString(createdFrom))
                        + "&"
                        + (string.IsNullOrEmpty(sourceEntityType) ? global::System.String.Empty : "sourceEntityType=" + global::System.Uri.EscapeDataString(sourceEntityType))
                        + "&"
                        + (null == sourceEntityId ? global::System.String.Empty : "sourceEntityId=" + global::System.Uri.EscapeDataString(sourceEntityId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.RequestManagerRequestList_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Retrieves the list of Requests</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="createdFrom">Source application of the request</param>
        /// <param name="sourceEntityType">Entity type of the source from which data is gathered for the request</param>
        /// <param name="sourceEntityId">Entity id of the source from which data is gathered for the request</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task RequestManagerRequestListViaIdentity(global::System.String viaIdentity, string createdFrom, string sourceEntityType, int? sourceEntityId, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRmRequestList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/RequestManager/Request$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/RequestManager/Request'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RequestManager/Request"
                        + "?"
                        + (string.IsNullOrEmpty(createdFrom) ? global::System.String.Empty : "createdFrom=" + global::System.Uri.EscapeDataString(createdFrom))
                        + "&"
                        + (string.IsNullOrEmpty(sourceEntityType) ? global::System.String.Empty : "sourceEntityType=" + global::System.Uri.EscapeDataString(sourceEntityType))
                        + "&"
                        + (null == sourceEntityId ? global::System.String.Empty : "sourceEntityId=" + global::System.Uri.EscapeDataString(sourceEntityId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.RequestManagerRequestList_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="RequestManagerRequestList" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task RequestManagerRequestList_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IRmRequestList>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.RmRequestList.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="RequestManagerRequestList" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="createdFrom">Source application of the request</param>
        /// <param name="sourceEntityType">Entity type of the source from which data is gathered for the request</param>
        /// <param name="sourceEntityId">Entity id of the source from which data is gathered for the request</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task RequestManagerRequestList_Validate(string createdFrom, string sourceEntityType, int? sourceEntityId, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(createdFrom),createdFrom);
                await eventListener.AssertNotNull(nameof(sourceEntityType),sourceEntityType);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(sourceEntityId),sourceEntityId,1);
            }
        }

        /// <summary>This endpoint is used to return the list of tape storages.</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ReturnListOfTapes(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ITapeListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Storage/Tape"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ReturnListOfTapes_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="ReturnListOfTapes" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ReturnListOfTapes_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ITapeListResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.TapeListResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ReturnListOfTapes" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ReturnListOfTapes_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Configure a created request</summary>
        /// <param name="requestId"></param>
        /// <param name="body">RMConfigureRequest</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task RmconfigureRequestOperation(int requestId, Commvault.Powershell.Models.IRmConfigureRequest body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RequestManager/Request/"
                        + (requestId.ToString())
                        + "/Configure"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.RmconfigureRequestOperation_Call(request,onOk,onBadRequest,onForbidden,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Configure a created request</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">RMConfigureRequest</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task RmconfigureRequestOperationViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IRmConfigureRequest body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/RequestManager/Request/(?<requestId>[^/]+)/Configure$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/RequestManager/Request/{requestId}/Configure'");
                }

                // replace URI parameters with values from identity
                var requestId = _match.Groups["requestId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RequestManager/Request/"
                        + requestId
                        + "/Configure"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.RmconfigureRequestOperation_Call(request,onOk,onBadRequest,onForbidden,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="RmconfigureRequestOperation" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task RmconfigureRequestOperation_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Forbidden:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onForbidden(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="RmconfigureRequestOperation" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="requestId"></param>
        /// <param name="body">RMConfigureRequest</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task RmconfigureRequestOperation_Validate(int requestId, Commvault.Powershell.Models.IRmConfigureRequest body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertIsGreaterThanOrEqual(nameof(requestId),requestId,1);
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Creating a request for request manager</summary>
        /// <param name="body">RMCreateRequest</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task RmcreateRequestOperation(Commvault.Powershell.Models.IRmCreateRequest body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/RequestManager/Request"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.RmcreateRequestOperation_Call(request,onCreated,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="RmcreateRequestOperation" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task RmcreateRequestOperation_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IIdName>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Created:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onCreated(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.IdName.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="RmcreateRequestOperation" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="body">RMCreateRequest</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task RmcreateRequestOperation_Validate(Commvault.Powershell.Models.IRmCreateRequest body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>To test Email settings</summary>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onUnauthorized">a delegate that is called when the remote service returns 401 (Unauthorized).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task SendTestMailReq(Commvault.Powershell.Models.ISendTestMailReq body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onUnauthorized, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/EmailServer/Action/Test"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.SendTestMailReq_Call(request,onOk,onBadRequest,onUnauthorized,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="SendTestMailReq" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onUnauthorized">a delegate that is called when the remote service returns 401 (Unauthorized).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task SendTestMailReq_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onUnauthorized, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Unauthorized:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onUnauthorized(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="SendTestMailReq" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task SendTestMailReq_Validate(Commvault.Powershell.Models.ISendTestMailReq body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Endpoint to Change the Access Node</summary>
        /// <param name="hypervisorId">Hypervisor ID to update the Access Node</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task SetHypervisorAccessNode(int hypervisorId, Commvault.Powershell.Models.IPathsPghlw2V4HypervisorHypervisoridAccessnodePutRequestbodyContentApplicationJsonSchema body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Hypervisor/"
                        + (hypervisorId.ToString())
                        + "/AccessNode"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.SetHypervisorAccessNode_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Endpoint to Change the Access Node</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task SetHypervisorAccessNodeViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IPathsPghlw2V4HypervisorHypervisoridAccessnodePutRequestbodyContentApplicationJsonSchema body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Hypervisor/(?<hypervisorId>[^/]+)/AccessNode$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Hypervisor/{hypervisorId}/AccessNode'");
                }

                // replace URI parameters with values from identity
                var hypervisorId = _match.Groups["hypervisorId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Hypervisor/"
                        + hypervisorId
                        + "/AccessNode"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.SetHypervisorAccessNode_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="SetHypervisorAccessNode" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task SetHypervisorAccessNode_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="SetHypervisorAccessNode" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="hypervisorId">Hypervisor ID to update the Access Node</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task SetHypervisorAccessNode_Validate(int hypervisorId, Commvault.Powershell.Models.IPathsPghlw2V4HypervisorHypervisoridAccessnodePutRequestbodyContentApplicationJsonSchema body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Endpoint to set FBR</summary>
        /// <param name="hypervisorId">Linux Media Agent to set as FBR for linux File based restores</param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task SetHypervisorFbr(int hypervisorId, Commvault.Powershell.Models.IPaths1OwzkoeV4HypervisorHypervisoridFbrPutRequestbodyContentApplicationJsonSchema body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateHypervisorResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Hypervisor/"
                        + (hypervisorId.ToString())
                        + "/FBR"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.SetHypervisorFbr_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Endpoint to set FBR</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task SetHypervisorFbrViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IPaths1OwzkoeV4HypervisorHypervisoridFbrPutRequestbodyContentApplicationJsonSchema body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateHypervisorResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Hypervisor/(?<hypervisorId>[^/]+)/FBR$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Hypervisor/{hypervisorId}/FBR'");
                }

                // replace URI parameters with values from identity
                var hypervisorId = _match.Groups["hypervisorId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Hypervisor/"
                        + hypervisorId
                        + "/FBR"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.SetHypervisorFbr_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="SetHypervisorFbr" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task SetHypervisorFbr_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateHypervisorResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.CreateHypervisorResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="SetHypervisorFbr" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="hypervisorId">Linux Media Agent to set as FBR for linux File based restores</param>
        /// <param name="body"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task SetHypervisorFbr_Validate(int hypervisorId, Commvault.Powershell.Models.IPaths1OwzkoeV4HypervisorHypervisoridFbrPutRequestbodyContentApplicationJsonSchema body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Get list of SNMP hosts for alert notification</summary>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Snmp(global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPathsZz45HxV4SnmpGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Snmp"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Get, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.Snmp_Call(request,onOk,onNotFound,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="Snmp" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task Snmp_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IPathsZz45HxV4SnmpGetResponses200ContentApplicationJsonSchema>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.PathsZz45HxV4SnmpGetResponses200ContentApplicationJsonSchema.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="Snmp" /> method. Call this like the actual call, but you will get validation events back.
        /// </summary>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task Snmp_Validate(Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Unpin triggered alerts</summary>
        /// <param name="id"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UnpinTriggeredAlerts(int id, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/TriggeredAlerts/"
                        + (id.ToString())
                        + "/Unpin"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UnpinTriggeredAlerts_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Unpin triggered alerts</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UnpinTriggeredAlertsViaIdentity(global::System.String viaIdentity, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/TriggeredAlerts/(?<id>[^/]+)/Unpin$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/TriggeredAlerts/{id}/Unpin'");
                }

                // replace URI parameters with values from identity
                var id = _match.Groups["id"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/TriggeredAlerts/"
                        + id
                        + "/Unpin"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UnpinTriggeredAlerts_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="UnpinTriggeredAlerts" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UnpinTriggeredAlerts_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="UnpinTriggeredAlerts" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UnpinTriggeredAlerts_Validate(int id, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {

            }
        }

        /// <summary>Update an AD/LDAP domain</summary>
        /// <param name="domainId">ID of the AD/LDAP domain</param>
        /// <param name="body">Properties of the domain to be updated</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdateAdldap(int domainId, Commvault.Powershell.Models.IUpdateAdldap body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LDAP/"
                        + (domainId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdateAdldap_Call(request,onOk,onBadRequest,eventListener,sender);
            }
        }

        /// <summary>Update an AD/LDAP domain</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">Properties of the domain to be updated</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdateAdldapViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateAdldap body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/LDAP/(?<domainId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/LDAP/{domainId}'");
                }

                // replace URI parameters with values from identity
                var domainId = _match.Groups["domainId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/LDAP/"
                        + domainId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdateAdldap_Call(request,onOk,onBadRequest,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="UpdateAdldap" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdateAdldap_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="UpdateAdldap" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="domainId">ID of the AD/LDAP domain</param>
        /// <param name="body">Properties of the domain to be updated</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdateAdldap_Validate(int domainId, Commvault.Powershell.Models.IUpdateAdldap body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// Assigns company's timezone as the timezone for servers with no packages installed
        /// </summary>
        /// <param name="companyId">Id of the company whose timezone is used to update timezone of servers (with no packages)</param>
        /// <param name="body">Request body for updating timezone for clients</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdateCompanyTimezoneForServers(int companyId, Commvault.Powershell.Models.IUpdateTimezoneForClientsReq body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Company/"
                        + (companyId.ToString())
                        + "/Servers/Timezone"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdateCompanyTimezoneForServers_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>
        /// Assigns company's timezone as the timezone for servers with no packages installed
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">Request body for updating timezone for clients</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdateCompanyTimezoneForServersViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateTimezoneForClientsReq body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Company/(?<companyId>[^/]+)/Servers/Timezone$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Company/{companyId}/Servers/Timezone'");
                }

                // replace URI parameters with values from identity
                var companyId = _match.Groups["companyId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Company/"
                        + companyId
                        + "/Servers/Timezone"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdateCompanyTimezoneForServers_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="UpdateCompanyTimezoneForServers" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdateCompanyTimezoneForServers_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="UpdateCompanyTimezoneForServers" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="companyId">Id of the company whose timezone is used to update timezone of servers (with no packages)</param>
        /// <param name="body">Request body for updating timezone for clients</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdateCompanyTimezoneForServers_Validate(int companyId, Commvault.Powershell.Models.IUpdateTimezoneForClientsReq body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Add/Edit/Delete global execptions</summary>
        /// <param name="body">Request body to be passed to the POST API</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdateGlobalExceptions(Commvault.Powershell.Models.ISetGlobalExceptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/GlobalExceptions"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdateGlobalExceptions_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="UpdateGlobalExceptions" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdateGlobalExceptions_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="UpdateGlobalExceptions" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">Request body to be passed to the POST API</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdateGlobalExceptions_Validate(Commvault.Powershell.Models.ISetGlobalExceptions body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// Api to update existing plan rules. Request body will suggest which rule need to be updated and type of entities(workloads
        /// type, server groups, regions and all) that need to be referenced for applying that rule against a workload.
        /// </summary>
        /// <param name="body">Plan entity rule update object. Fields in this object need to be populated to suggest what need to
        /// be changed in the rule.
        /// User can provide all rule options or can specify a specific rule group. Be default, for rule to be applicable for association
        /// to a workload, ALL specified rules in that Rule need to be matched.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdatePlanRule(Commvault.Powershell.Models.IUpdatePlanEntityRule body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdatePlanRule_Call(request,onOk,onBadRequest,onForbidden,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>API to update rank for multiple rules at a time.</summary>
        /// <param name="body">Plan entity rule update rank object. Fields in this object need to be populated to suggest what rank
        /// need to be set for the said rule.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdatePlanRuleRank(Commvault.Powershell.Models.IUpdatePlanEntityRuleRanks body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Plan/Rule/Rank"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdatePlanRuleRank_Call(request,onOk,onBadRequest,onForbidden,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="UpdatePlanRuleRank" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdatePlanRuleRank_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Forbidden:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onForbidden(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="UpdatePlanRuleRank" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">Plan entity rule update rank object. Fields in this object need to be populated to suggest what rank
        /// need to be set for the said rule.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdatePlanRuleRank_Validate(Commvault.Powershell.Models.IUpdatePlanEntityRuleRanks body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Actual wire call for <see cref="UpdatePlanRule" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onForbidden">a delegate that is called when the remote service returns 403 (Forbidden).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdatePlanRule_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onForbidden, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.Forbidden:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onForbidden(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="UpdatePlanRule" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="body">Plan entity rule update object. Fields in this object need to be populated to suggest what need to
        /// be changed in the rule.
        /// User can provide all rule options or can specify a specific rule group. Be default, for rule to be applicable for association
        /// to a workload, ALL specified rules in that Rule need to be matched.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdatePlanRule_Validate(Commvault.Powershell.Models.IUpdatePlanEntityRule body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Update details of the region</summary>
        /// <param name="regionId"></param>
        /// <param name="body">Properties to be updated for the region</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdateRegion(string regionId, Commvault.Powershell.Models.IUpdateRegion body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Regions/"
                        + global::System.Uri.EscapeDataString(regionId)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdateRegion_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Update details of the region</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">Properties to be updated for the region</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdateRegionViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdateRegion body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/Regions/(?<regionId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/Regions/{regionId}'");
                }

                // replace URI parameters with values from identity
                var regionId = _match.Groups["regionId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/Regions/"
                        + regionId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdateRegion_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="UpdateRegion" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdateRegion_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response);
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="UpdateRegion" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="regionId"></param>
        /// <param name="body">Properties to be updated for the region</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdateRegion_Validate(string regionId, Commvault.Powershell.Models.IUpdateRegion body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(regionId),regionId);
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Updates details of existing SAML app</summary>
        /// <param name="name"></param>
        /// <param name="body">Updates SAML details</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdateSamlApp(string name, Commvault.Powershell.Models.ISamlUpdate body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/SAML/"
                        + global::System.Uri.EscapeDataString(name)

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdateSamlApp_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Updates details of existing SAML app</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">Updates SAML details</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdateSamlAppViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.ISamlUpdate body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/SAML/(?<name>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/SAML/{name}'");
                }

                // replace URI parameters with values from identity
                var name = _match.Groups["name"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/SAML/"
                        + name

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdateSamlApp_Call(request,onOk,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="UpdateSamlApp" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdateSamlApp_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="UpdateSamlApp" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="body">Updates SAML details</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdateSamlApp_Validate(string name, Commvault.Powershell.Models.ISamlUpdate body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(name),name);
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>API to modify RPO schedules on server plan</summary>
        /// <param name="planId">Id of the Server Plan</param>
        /// <param name="body">Recovery Point Objective (RPO) is the maximum amount of time that data can be lost during a service
        /// disruption. Your RPO determines the frequency of your backup jobs.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdateServerPlanRpo(int planId, Commvault.Powershell.Models.IServerPlanUpdateRpo body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + (planId.ToString())
                        + "/RPO"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdateServerPlanRpo_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>API to modify RPO schedules on server plan</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">Recovery Point Objective (RPO) is the maximum amount of time that data can be lost during a service
        /// disruption. Your RPO determines the frequency of your backup jobs.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdateServerPlanRpoViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IServerPlanUpdateRpo body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/ServerPlan/(?<planId>[^/]+)/RPO$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/ServerPlan/{planId}/RPO'");
                }

                // replace URI parameters with values from identity
                var planId = _match.Groups["planId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/ServerPlan/"
                        + planId
                        + "/RPO"

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdateServerPlanRpo_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="UpdateServerPlanRpo" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdateServerPlanRpo_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="UpdateServerPlanRpo" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="planId">Id of the Server Plan</param>
        /// <param name="body">Recovery Point Objective (RPO) is the maximum amount of time that data can be lost during a service
        /// disruption. Your RPO determines the frequency of your backup jobs.</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdateServerPlanRpo_Validate(int planId, Commvault.Powershell.Models.IServerPlanUpdateRpo body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Updates the VM Group</summary>
        /// <param name="vmGroupId">Id of the VMgroup to update</param>
        /// <param name="body">UpdatevmGroupReq</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdateVMGroup(int vmGroupId, Commvault.Powershell.Models.IUpdatevmGroupReq body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetVMGroupResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VmGroup/"
                        + (vmGroupId.ToString())

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdateVMGroup_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Updates the VM Group</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="body">UpdatevmGroupReq</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task UpdateVMGroupViaIdentity(global::System.String viaIdentity, Commvault.Powershell.Models.IUpdatevmGroupReq body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetVMGroupResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/VmGroup/(?<VmGroupId>[^/]+)$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/VmGroup/{VmGroupId}'");
                }

                // replace URI parameters with values from identity
                var vmGroupId = _match.Groups["VmGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VmGroup/"
                        + vmGroupId

                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Put, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.UpdateVMGroup_Call(request,onOk,onBadRequest,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="UpdateVMGroup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onBadRequest">a delegate that is called when the remote service returns 400 (BadRequest).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdateVMGroup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGetVMGroupResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onBadRequest, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GetVMGroupResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.BadRequest:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onBadRequest(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="UpdateVMGroup" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="vmGroupId">Id of the VMgroup to update</param>
        /// <param name="body">UpdatevmGroupReq</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task UpdateVMGroup_Validate(int vmGroupId, Commvault.Powershell.Models.IUpdatevmGroupReq body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Preview of the vm to be protected in VMGroup</summary>
        /// <param name="hypervisorId">Hypervisor Id of VMGroup</param>
        /// <param name="body">vmGroupPreviewReq</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task VMGroupPreview(int? hypervisorId, Commvault.Powershell.Models.IVMGroupPreviewReq body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IVMGroupPreviewResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VmGroup/Preview"
                        + "?"
                        + (null == hypervisorId ? global::System.String.Empty : "hypervisorId=" + global::System.Uri.EscapeDataString(hypervisorId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.VMGroupPreview_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Preview of the vm to be protected in VMGroup</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="hypervisorId">Hypervisor Id of VMGroup</param>
        /// <param name="body">vmGroupPreviewReq</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task VMGroupPreviewViaIdentity(global::System.String viaIdentity, int? hypervisorId, Commvault.Powershell.Models.IVMGroupPreviewReq body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IVMGroupPreviewResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/VmGroup/Preview$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/VmGroup/Preview'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VmGroup/Preview"
                        + "?"
                        + (null == hypervisorId ? global::System.String.Empty : "hypervisorId=" + global::System.Uri.EscapeDataString(hypervisorId.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.VMGroupPreview_Call(request,onOk,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="VMGroupPreview" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task VMGroupPreview_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IVMGroupPreviewResp>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.VMGroupPreviewResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="VMGroupPreview" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="hypervisorId">Hypervisor Id of VMGroup</param>
        /// <param name="body">vmGroupPreviewReq</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task VMGroupPreview_Validate(int? hypervisorId, Commvault.Powershell.Models.IVMGroupPreviewReq body, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>To Backup the virtual machines in vmgroup</summary>
        /// <param name="vmGroupId">Id of the VMgroup to backup</param>
        /// <param name="backupLevel">Backup level , Default :Incremental</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task VmgroupBackup(int vmGroupId, string backupLevel, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateTaskRespforBackup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VmGroup/"
                        + (vmGroupId.ToString())
                        + "/backup"
                        + "?"
                        + (string.IsNullOrEmpty(backupLevel) ? global::System.String.Empty : "backupLevel=" + global::System.Uri.EscapeDataString(backupLevel))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.VmgroupBackup_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>To Backup the virtual machines in vmgroup</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="backupLevel">Backup level , Default :Incremental</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task VmgroupBackupViaIdentity(global::System.String viaIdentity, string backupLevel, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateTaskRespforBackup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/V4/VmGroup/(?<VmGroupId>[^/]+)/backup$").Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/V4/VmGroup/{VmGroupId}/backup'");
                }

                // replace URI parameters with values from identity
                var vmGroupId = _match.Groups["VmGroupId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/V4/VmGroup/"
                        + vmGroupId
                        + "/backup"
                        + "?"
                        + (string.IsNullOrEmpty(backupLevel) ? global::System.String.Empty : "backupLevel=" + global::System.Uri.EscapeDataString(backupLevel))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"http://WebserverUrl.Commvault.com/webconsole/api/V4{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Commvault.Powershell.Runtime.Method.Post, _url);
                await eventListener.Signal(Commvault.Powershell.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Commvault.Powershell.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.VmgroupBackup_Call(request,onOk,onNotFound,onInternalServerError,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref="VmgroupBackup" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onInternalServerError">a delegate that is called when the remote service returns 500 (InternalServerError).</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Commvault.Powershell.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task VmgroupBackup_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.ICreateTaskRespforBackup>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp>, global::System.Threading.Tasks.Task> onInternalServerError, Commvault.Powershell.Runtime.IEventListener eventListener, Commvault.Powershell.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.CreateTaskRespforBackup.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        case global::System.Net.HttpStatusCode.InternalServerError:
                        {
                            await eventListener.Signal(Commvault.Powershell.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onInternalServerError(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Commvault.Powershell.Models.GenericResp.FromJson(Commvault.Powershell.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            throw new Commvault.Powershell.Runtime.UndeclaredResponseException(_response);
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Commvault.Powershell.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="VmgroupBackup" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="vmGroupId">Id of the VMgroup to backup</param>
        /// <param name="backupLevel">Backup level , Default :Incremental</param>
        /// <param name="eventListener">an <see cref="Commvault.Powershell.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task VmgroupBackup_Validate(int vmGroupId, string backupLevel, Commvault.Powershell.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(backupLevel),backupLevel);
            }
        }
    }
}