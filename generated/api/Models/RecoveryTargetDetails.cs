// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.8.3, generator: @autorest/powershell@3.0.415)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Commvault.Powershell.Models
{
    using static Commvault.Powershell.Runtime.Extensions;

    /// <summary>Recovery target info</summary>
    public partial class RecoveryTargetDetails :
        Commvault.Powershell.Models.IRecoveryTargetDetails,
        Commvault.Powershell.Models.IRecoveryTargetDetailsInternal
    {

        /// <summary>Backing field for <see cref="AccessNode" /> property.</summary>
        private Commvault.Powershell.Models.IIdName _accessNode;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IIdName AccessNode { get => (this._accessNode = this._accessNode ?? new Commvault.Powershell.Models.IdName()); set => this._accessNode = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? AccessNodeId { get => ((Commvault.Powershell.Models.IIdNameInternal)AccessNode).Id; set => ((Commvault.Powershell.Models.IIdNameInternal)AccessNode).Id = value ?? default(int); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string AccessNodeName { get => ((Commvault.Powershell.Models.IIdNameInternal)AccessNode).Name; set => ((Commvault.Powershell.Models.IIdNameInternal)AccessNode).Name = value ?? null; }

        /// <summary>Backing field for <see cref="ApplicationType" /> property.</summary>
        private string _applicationType;

        /// <summary>Recovery target application type</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string ApplicationType { get => this._applicationType; set => this._applicationType = value; }

        /// <summary>Backing field for <see cref="AvailabilityZones" /> property.</summary>
        private string[] _availabilityZones;

        /// <summary>Availalility zone</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string[] AvailabilityZones { get => this._availabilityZones; set => this._availabilityZones = value; }

        /// <summary>Internal Acessors for AccessNode</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IRecoveryTargetDetailsInternal.AccessNode { get => (this._accessNode = this._accessNode ?? new Commvault.Powershell.Models.IdName()); set { {_accessNode = value;} } }

        /// <summary>Internal Acessors for DestinationHypervisor</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IRecoveryTargetDetailsInternal.DestinationHypervisor { get => (this._destinationHypervisor = this._destinationHypervisor ?? new Commvault.Powershell.Models.IdName()); set { {_destinationHypervisor = value;} } }

        /// <summary>Internal Acessors for VMDisplayName</summary>
        Commvault.Powershell.Models.IVMDisplayName Commvault.Powershell.Models.IRecoveryTargetDetailsInternal.VMDisplayName { get => (this._vMDisplayName = this._vMDisplayName ?? new Commvault.Powershell.Models.VMDisplayName()); set { {_vMDisplayName = value;} } }

        /// <summary>Backing field for <see cref="ConfigureIsolatedNetwork" /> property.</summary>
        private bool? _configureIsolatedNetwork;

        /// <summary>To use isolated network for the virtual lab VM</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public bool? ConfigureIsolatedNetwork { get => this._configureIsolatedNetwork; set => this._configureIsolatedNetwork = value; }

        /// <summary>Backing field for <see cref="DataStore" /> property.</summary>
        private string[] _dataStore;

        /// <summary>
        /// Data Store for destination vm.Destination folder for restore when default folder is not set.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string[] DataStore { get => this._dataStore; set => this._dataStore = value; }

        /// <summary>Backing field for <see cref="DestinationHost" /> property.</summary>
        private Commvault.Powershell.Models.IIdName[] _destinationHost;

        /// <summary>Array of esx server name</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public Commvault.Powershell.Models.IIdName[] DestinationHost { get => this._destinationHost; set => this._destinationHost = value; }

        /// <summary>Backing field for <see cref="DestinationHypervisor" /> property.</summary>
        private Commvault.Powershell.Models.IIdName _destinationHypervisor;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IIdName DestinationHypervisor { get => (this._destinationHypervisor = this._destinationHypervisor ?? new Commvault.Powershell.Models.IdName()); set => this._destinationHypervisor = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? DestinationHypervisorId { get => ((Commvault.Powershell.Models.IIdNameInternal)DestinationHypervisor).Id; set => ((Commvault.Powershell.Models.IIdNameInternal)DestinationHypervisor).Id = value ?? default(int); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string DestinationHypervisorName { get => ((Commvault.Powershell.Models.IIdNameInternal)DestinationHypervisor).Name; set => ((Commvault.Powershell.Models.IIdNameInternal)DestinationHypervisor).Name = value ?? null; }

        /// <summary>Backing field for <see cref="DestinationNetwork" /> property.</summary>
        private string[] _destinationNetwork;

        /// <summary>A network interface for the destination instances.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string[] DestinationNetwork { get => this._destinationNetwork; set => this._destinationNetwork = value; }

        /// <summary>Backing field for <see cref="EncryptionKey" /> property.</summary>
        private string _encryptionKey;

        /// <summary>SSH key for the destination instance</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string EncryptionKey { get => this._encryptionKey; set => this._encryptionKey = value; }

        /// <summary>Backing field for <see cref="ExpirationTime" /> property.</summary>
        private int? _expirationTime;

        /// <summary>
        /// Specifies the amount of time(hours) that a live mounted VMs can run before they expire.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public int? ExpirationTime { get => this._expirationTime; set => this._expirationTime = value; }

        /// <summary>Backing field for <see cref="Id" /> property.</summary>
        private int? _id;

        /// <summary>Unique ID of recovery target</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public int? Id { get => this._id; set => this._id = value; }

        /// <summary>Backing field for <see cref="IsoPath" /> property.</summary>
        private string[] _isoPath;

        /// <summary>Path for the Windows/Unix ISO files</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string[] IsoPath { get => this._isoPath; set => this._isoPath = value; }

        /// <summary>Backing field for <see cref="MaximumCpuCores" /> property.</summary>
        private int? _maximumCpuCores;

        /// <summary>Maximum cores</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public int? MaximumCpuCores { get => this._maximumCpuCores; set => this._maximumCpuCores = value; }

        /// <summary>Backing field for <see cref="MaximumMemory" /> property.</summary>
        private string _maximumMemory;

        /// <summary>Maximum memory of the vm in bytes</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string MaximumMemory { get => this._maximumMemory; set => this._maximumMemory = value; }

        /// <summary>Backing field for <see cref="MigrateVM" /> property.</summary>
        private bool? _migrateVM;

        /// <summary>True when live mount is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public bool? MigrateVM { get => this._migrateVM; set => this._migrateVM = value; }

        /// <summary>Backing field for <see cref="Name" /> property.</summary>
        private string _name;

        /// <summary>Name of the recovery target</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string Name { get => this._name; set => this._name = value; }

        /// <summary>Backing field for <see cref="NumberOfVMS" /> property.</summary>
        private int? _numberOfVMS;

        /// <summary>Number of concurrent VMs that each user can run on the recovery target</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public int? NumberOfVMS { get => this._numberOfVMS; set => this._numberOfVMS = value; }

        /// <summary>Backing field for <see cref="PublicIP" /> property.</summary>
        private bool? _publicIP;

        /// <summary>If true, public IP address are configured for destination VMs</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public bool? PublicIP { get => this._publicIP; set => this._publicIP = value; }

        /// <summary>Backing field for <see cref="Region" /> property.</summary>
        private string _region;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string Region { get => this._region; set => this._region = value; }

        /// <summary>Backing field for <see cref="ResourcePoolPath" /> property.</summary>
        private string _resourcePoolPath;

        /// <summary>Resource pool for all destination VMs</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string ResourcePoolPath { get => this._resourcePoolPath; set => this._resourcePoolPath = value; }

        /// <summary>Backing field for <see cref="RestoreAsManagedVM" /> property.</summary>
        private bool? _restoreAsManagedVM;

        /// <summary>If true, restore creates the destination VM as a managed VM in Azure</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public bool? RestoreAsManagedVM { get => this._restoreAsManagedVM; set => this._restoreAsManagedVM = value; }

        /// <summary>Backing field for <see cref="Users" /> property.</summary>
        private Commvault.Powershell.Models.IIdNameGuid[] _users;

        /// <summary>users or user groups that have access to the recovery target</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public Commvault.Powershell.Models.IIdNameGuid[] Users { get => this._users; set => this._users = value; }

        /// <summary>Backing field for <see cref="VMDisplayName" /> property.</summary>
        private Commvault.Powershell.Models.IVMDisplayName _vMDisplayName;

        /// <summary>Prefix or Suffix appended to create display name for destination instance</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IVMDisplayName VMDisplayName { get => (this._vMDisplayName = this._vMDisplayName ?? new Commvault.Powershell.Models.VMDisplayName()); set => this._vMDisplayName = value; }

        /// <summary>
        /// A prefix string that will be appended to source instances to create the display name for each destination instance.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string VMDisplayNamePrefix { get => ((Commvault.Powershell.Models.IVMDisplayNameInternal)VMDisplayName).Prefix; set => ((Commvault.Powershell.Models.IVMDisplayNameInternal)VMDisplayName).Prefix = value ?? null; }

        /// <summary>
        /// A suffix string that will be appended to source instances to create the display name for each destination instance.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string VMDisplayNameSuffix { get => ((Commvault.Powershell.Models.IVMDisplayNameInternal)VMDisplayName).Suffix; set => ((Commvault.Powershell.Models.IVMDisplayNameInternal)VMDisplayName).Suffix = value ?? null; }

        /// <summary>Backing field for <see cref="VMInstanceTypes" /> property.</summary>
        private string[] _vMInstanceTypes;

        /// <summary>An instance type that provides the available CPU cores and memory</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string[] VMInstanceTypes { get => this._vMInstanceTypes; set => this._vMInstanceTypes = value; }

        /// <summary>Backing field for <see cref="VolumeType" /> property.</summary>
        private string _volumeType;

        /// <summary>volume type that is defined for the zone of the source volumes</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string VolumeType { get => this._volumeType; set => this._volumeType = value; }

        /// <summary>Creates an new <see cref="RecoveryTargetDetails" /> instance.</summary>
        public RecoveryTargetDetails()
        {

        }
    }
    /// Recovery target info
    public partial interface IRecoveryTargetDetails :
        Commvault.Powershell.Runtime.IJsonSerializable
    {
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(int) })]
        int? AccessNodeId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string AccessNodeName { get; set; }
        /// <summary>Recovery target application type</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Recovery target application type",
        SerializedName = @"applicationType",
        PossibleTypes = new [] { typeof(string) })]
        string ApplicationType { get; set; }
        /// <summary>Availalility zone</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Availalility zone",
        SerializedName = @"availabilityZones",
        PossibleTypes = new [] { typeof(string) })]
        string[] AvailabilityZones { get; set; }
        /// <summary>To use isolated network for the virtual lab VM</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To use isolated network for the virtual lab VM",
        SerializedName = @"configureIsolatedNetwork",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ConfigureIsolatedNetwork { get; set; }
        /// <summary>
        /// Data Store for destination vm.Destination folder for restore when default folder is not set.
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Data Store for destination vm.Destination folder for restore when default folder is not set.",
        SerializedName = @"dataStore",
        PossibleTypes = new [] { typeof(string) })]
        string[] DataStore { get; set; }
        /// <summary>Array of esx server name</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Array of esx server name",
        SerializedName = @"destinationHost",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IIdName) })]
        Commvault.Powershell.Models.IIdName[] DestinationHost { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(int) })]
        int? DestinationHypervisorId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string DestinationHypervisorName { get; set; }
        /// <summary>A network interface for the destination instances.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A network interface for the destination instances.",
        SerializedName = @"destinationNetwork",
        PossibleTypes = new [] { typeof(string) })]
        string[] DestinationNetwork { get; set; }
        /// <summary>SSH key for the destination instance</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SSH key for the destination instance",
        SerializedName = @"encryptionKey",
        PossibleTypes = new [] { typeof(string) })]
        string EncryptionKey { get; set; }
        /// <summary>
        /// Specifies the amount of time(hours) that a live mounted VMs can run before they expire.
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the amount of time(hours) that a live mounted VMs can run before they expire.",
        SerializedName = @"expirationTime",
        PossibleTypes = new [] { typeof(int) })]
        int? ExpirationTime { get; set; }
        /// <summary>Unique ID of recovery target</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Unique ID of recovery target",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(int) })]
        int? Id { get; set; }
        /// <summary>Path for the Windows/Unix ISO files</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @" Path for the Windows/Unix ISO files",
        SerializedName = @"isoPath",
        PossibleTypes = new [] { typeof(string) })]
        string[] IsoPath { get; set; }
        /// <summary>Maximum cores</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum cores",
        SerializedName = @"maximumCPUCores",
        PossibleTypes = new [] { typeof(int) })]
        int? MaximumCpuCores { get; set; }
        /// <summary>Maximum memory of the vm in bytes</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum memory of the vm in bytes",
        SerializedName = @"maximumMemory",
        PossibleTypes = new [] { typeof(string) })]
        string MaximumMemory { get; set; }
        /// <summary>True when live mount is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True when live mount is enabled",
        SerializedName = @"migrateVM",
        PossibleTypes = new [] { typeof(bool) })]
        bool? MigrateVM { get; set; }
        /// <summary>Name of the recovery target</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Name of the recovery target",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string Name { get; set; }
        /// <summary>Number of concurrent VMs that each user can run on the recovery target</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of concurrent VMs that each user can run on the recovery target",
        SerializedName = @"numberOfVMs",
        PossibleTypes = new [] { typeof(int) })]
        int? NumberOfVMS { get; set; }
        /// <summary>If true, public IP address are configured for destination VMs</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If true, public IP address are configured for destination VMs",
        SerializedName = @"publicIP",
        PossibleTypes = new [] { typeof(bool) })]
        bool? PublicIP { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"region",
        PossibleTypes = new [] { typeof(string) })]
        string Region { get; set; }
        /// <summary>Resource pool for all destination VMs</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource pool for all destination VMs",
        SerializedName = @"resourcePoolPath",
        PossibleTypes = new [] { typeof(string) })]
        string ResourcePoolPath { get; set; }
        /// <summary>If true, restore creates the destination VM as a managed VM in Azure</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If true, restore creates the destination VM as a managed VM in Azure",
        SerializedName = @"restoreAsManagedVM",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RestoreAsManagedVM { get; set; }
        /// <summary>users or user groups that have access to the recovery target</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"users or user groups that have access to the recovery target",
        SerializedName = @"users",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IIdNameGuid) })]
        Commvault.Powershell.Models.IIdNameGuid[] Users { get; set; }
        /// <summary>
        /// A prefix string that will be appended to source instances to create the display name for each destination instance.
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A prefix string that will be appended to source instances to create the display name for each destination instance.",
        SerializedName = @"prefix",
        PossibleTypes = new [] { typeof(string) })]
        string VMDisplayNamePrefix { get; set; }
        /// <summary>
        /// A suffix string that will be appended to source instances to create the display name for each destination instance.
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A suffix string that will be appended to source instances to create the display name for each destination instance.",
        SerializedName = @"suffix",
        PossibleTypes = new [] { typeof(string) })]
        string VMDisplayNameSuffix { get; set; }
        /// <summary>An instance type that provides the available CPU cores and memory</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"An instance type that provides the available CPU cores and memory",
        SerializedName = @"vmInstanceTypes",
        PossibleTypes = new [] { typeof(string) })]
        string[] VMInstanceTypes { get; set; }
        /// <summary>volume type that is defined for the zone of the source volumes</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"volume type that is defined for the zone of the source volumes",
        SerializedName = @"volumeType",
        PossibleTypes = new [] { typeof(string) })]
        string VolumeType { get; set; }

    }
    /// Recovery target info
    internal partial interface IRecoveryTargetDetailsInternal

    {
        Commvault.Powershell.Models.IIdName AccessNode { get; set; }

        int? AccessNodeId { get; set; }

        string AccessNodeName { get; set; }
        /// <summary>Recovery target application type</summary>
        string ApplicationType { get; set; }
        /// <summary>Availalility zone</summary>
        string[] AvailabilityZones { get; set; }
        /// <summary>To use isolated network for the virtual lab VM</summary>
        bool? ConfigureIsolatedNetwork { get; set; }
        /// <summary>
        /// Data Store for destination vm.Destination folder for restore when default folder is not set.
        /// </summary>
        string[] DataStore { get; set; }
        /// <summary>Array of esx server name</summary>
        Commvault.Powershell.Models.IIdName[] DestinationHost { get; set; }

        Commvault.Powershell.Models.IIdName DestinationHypervisor { get; set; }

        int? DestinationHypervisorId { get; set; }

        string DestinationHypervisorName { get; set; }
        /// <summary>A network interface for the destination instances.</summary>
        string[] DestinationNetwork { get; set; }
        /// <summary>SSH key for the destination instance</summary>
        string EncryptionKey { get; set; }
        /// <summary>
        /// Specifies the amount of time(hours) that a live mounted VMs can run before they expire.
        /// </summary>
        int? ExpirationTime { get; set; }
        /// <summary>Unique ID of recovery target</summary>
        int? Id { get; set; }
        /// <summary>Path for the Windows/Unix ISO files</summary>
        string[] IsoPath { get; set; }
        /// <summary>Maximum cores</summary>
        int? MaximumCpuCores { get; set; }
        /// <summary>Maximum memory of the vm in bytes</summary>
        string MaximumMemory { get; set; }
        /// <summary>True when live mount is enabled</summary>
        bool? MigrateVM { get; set; }
        /// <summary>Name of the recovery target</summary>
        string Name { get; set; }
        /// <summary>Number of concurrent VMs that each user can run on the recovery target</summary>
        int? NumberOfVMS { get; set; }
        /// <summary>If true, public IP address are configured for destination VMs</summary>
        bool? PublicIP { get; set; }

        string Region { get; set; }
        /// <summary>Resource pool for all destination VMs</summary>
        string ResourcePoolPath { get; set; }
        /// <summary>If true, restore creates the destination VM as a managed VM in Azure</summary>
        bool? RestoreAsManagedVM { get; set; }
        /// <summary>users or user groups that have access to the recovery target</summary>
        Commvault.Powershell.Models.IIdNameGuid[] Users { get; set; }
        /// <summary>Prefix or Suffix appended to create display name for destination instance</summary>
        Commvault.Powershell.Models.IVMDisplayName VMDisplayName { get; set; }
        /// <summary>
        /// A prefix string that will be appended to source instances to create the display name for each destination instance.
        /// </summary>
        string VMDisplayNamePrefix { get; set; }
        /// <summary>
        /// A suffix string that will be appended to source instances to create the display name for each destination instance.
        /// </summary>
        string VMDisplayNameSuffix { get; set; }
        /// <summary>An instance type that provides the available CPU cores and memory</summary>
        string[] VMInstanceTypes { get; set; }
        /// <summary>volume type that is defined for the zone of the source volumes</summary>
        string VolumeType { get; set; }

    }
}