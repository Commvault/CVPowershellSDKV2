// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.0.6365, generator: {generator})
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Commvault.Powershell.Models
{
    using static Commvault.Powershell.Runtime.Extensions;

    public partial class UpdateMediaAgent :
        Commvault.Powershell.Models.IUpdateMediaAgent,
        Commvault.Powershell.Models.IUpdateMediaAgentInternal
    {

        /// <summary>Internal Acessors for Control</summary>
        Commvault.Powershell.Models.IMediaAgentControl Commvault.Powershell.Models.IUpdateMediaAgentInternal.Control { get => (this._control = this._control ?? new Commvault.Powershell.Models.MediaAgentControl()); set { {_control = value;} } }

        /// <summary>Internal Acessors for IndexCache</summary>
        Commvault.Powershell.Models.IIndexCache Commvault.Powershell.Models.IUpdateMediaAgentInternal.IndexCache { get => (this._indexCache = this._indexCache ?? new Commvault.Powershell.Models.IndexCache()); set { {_indexCache = value;} } }

        /// <summary>Internal Acessors for IndexCacheLogsCache</summary>
        Commvault.Powershell.Models.IMediaAgentLogsCache Commvault.Powershell.Models.IUpdateMediaAgentInternal.IndexCacheLogsCache { get => ((Commvault.Powershell.Models.IIndexCacheInternal)IndexCache).LogsCache; set => ((Commvault.Powershell.Models.IIndexCacheInternal)IndexCache).LogsCache = value; }

        /// <summary>Internal Acessors for Security</summary>
        Commvault.Powershell.Models.IUpdateSecurityAssoc Commvault.Powershell.Models.IUpdateMediaAgentInternal.Security { get => (this._security = this._security ?? new Commvault.Powershell.Models.UpdateSecurityAssoc()); set { {_security = value;} } }

        /// <summary>Internal Acessors for SecurityRole</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdateMediaAgentInternal.SecurityRole { get => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).Role; set => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).Role = value; }

        /// <summary>Internal Acessors for SecurityUser</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdateMediaAgentInternal.SecurityUser { get => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).User; set => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).User = value; }

        /// <summary>Internal Acessors for SecurityUserGroup</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdateMediaAgentInternal.SecurityUserGroup { get => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).UserGroup; set => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).UserGroup = value; }

        /// <summary>Backing field for <see cref="Control" /> property.</summary>
        private Commvault.Powershell.Models.IMediaAgentControl _control;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IMediaAgentControl Control { get => (this._control = this._control ?? new Commvault.Powershell.Models.MediaAgentControl()); set => this._control = value; }

        /// <summary>Determines if the media agent is currently enabled or disabled.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? ControlEnabled { get => ((Commvault.Powershell.Models.IMediaAgentControlInternal)Control).Enabled; set => ((Commvault.Powershell.Models.IMediaAgentControlInternal)Control).Enabled = value ?? default(bool); }

        /// <summary>
        /// Specifies whether the MediaAgent is available for data protection, data recovery and auxiliary copy operations.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? ControlMaintenanceMode { get => ((Commvault.Powershell.Models.IMediaAgentControlInternal)Control).MaintenanceMode; set => ((Commvault.Powershell.Models.IMediaAgentControlInternal)Control).MaintenanceMode = value ?? default(bool); }

        /// <summary>
        /// Allows optimization for concurrent LAN backups. If set to true, default value for parallel data transfer operations will
        /// be 100. If set to false, default value of parallel data transfer operations will be set to 25.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? ControlOptimizeForConcurrentLanBackups { get => ((Commvault.Powershell.Models.IMediaAgentControlInternal)Control).OptimizeForConcurrentLanBackups; set => ((Commvault.Powershell.Models.IMediaAgentControlInternal)Control).OptimizeForConcurrentLanBackups = value ?? default(bool); }

        /// <summary>Specifies the number of parallel data operations that can take place.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? ControlParallelDataTransferOperations { get => ((Commvault.Powershell.Models.IMediaAgentControlInternal)Control).ParallelDataTransferOperations; set => ((Commvault.Powershell.Models.IMediaAgentControlInternal)Control).ParallelDataTransferOperations = value ?? default(int); }

        /// <summary>
        /// If set to true, ransomware protection against the media agent is enabled. If set to false, ransomware protection against
        /// media agent is disabled.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? ControlRansomwareProtection { get => ((Commvault.Powershell.Models.IMediaAgentControlInternal)Control).RansomwareProtection; set => ((Commvault.Powershell.Models.IMediaAgentControlInternal)Control).RansomwareProtection = value ?? default(bool); }

        /// <summary>Backing field for <see cref="Description" /> property.</summary>
        private string _description;

        /// <summary>Provides the media agent with a new description.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string Description { get => this._description; set => this._description = value; }

        /// <summary>Backing field for <see cref="IndexCache" /> property.</summary>
        private Commvault.Powershell.Models.IIndexCache _indexCache;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IIndexCache IndexCache { get => (this._indexCache = this._indexCache ?? new Commvault.Powershell.Models.IndexCache()); set => this._indexCache = value; }

        /// <summary>Path where the index cache is maintained.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string IndexCachePath { get => ((Commvault.Powershell.Models.IIndexCacheInternal)IndexCache).Path; set => ((Commvault.Powershell.Models.IIndexCacheInternal)IndexCache).Path = value ?? null; }

        /// <summary>This tag determines if the logs cache has been enabled or not.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? LogCacheEnabled { get => ((Commvault.Powershell.Models.IIndexCacheInternal)IndexCache).LogCacheEnabled; set => ((Commvault.Powershell.Models.IIndexCacheInternal)IndexCache).LogCacheEnabled = value ?? default(bool); }

        /// <summary>If the logs cache is enabled, this tag gives the path to store the logs cache.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string LogCachePath { get => ((Commvault.Powershell.Models.IIndexCacheInternal)IndexCache).LogCachePath; set => ((Commvault.Powershell.Models.IIndexCacheInternal)IndexCache).LogCachePath = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? RoleId { get => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).RoleId; set => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).RoleId = value ?? default(int); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string RoleName { get => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).RoleName; set => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).RoleName = value ?? null; }

        /// <summary>Backing field for <see cref="Security" /> property.</summary>
        private Commvault.Powershell.Models.IUpdateSecurityAssoc _security;

        /// <summary>
        /// A list of users or user groups each having a specific set of roles that determine the kind of operations they can perform
        /// on the entity. Either id/name of the user/usergroup/roles can be provided. If both id and name are provided, id will be
        /// taken into consideration.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IUpdateSecurityAssoc Security { get => (this._security = this._security ?? new Commvault.Powershell.Models.UpdateSecurityAssoc()); set => this._security = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? UserGroupId { get => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).UserGroupId; set => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).UserGroupId = value ?? default(int); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string UserGroupName { get => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).UserGroupName; set => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).UserGroupName = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? UserId { get => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).UserId; set => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).UserId = value ?? default(int); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string UserName { get => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).UserName; set => ((Commvault.Powershell.Models.IUpdateSecurityAssocInternal)Security).UserName = value ?? null; }

        /// <summary>Creates an new <see cref="UpdateMediaAgent" /> instance.</summary>
        public UpdateMediaAgent()
        {

        }
    }
    public partial interface IUpdateMediaAgent :
        Commvault.Powershell.Runtime.IJsonSerializable
    {
        /// <summary>Determines if the media agent is currently enabled or disabled.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Determines if the media agent is currently enabled or disabled.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ControlEnabled { get; set; }
        /// <summary>
        /// Specifies whether the MediaAgent is available for data protection, data recovery and auxiliary copy operations.
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether the MediaAgent is available for data protection, data recovery and auxiliary copy operations.",
        SerializedName = @"maintenanceMode",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ControlMaintenanceMode { get; set; }
        /// <summary>
        /// Allows optimization for concurrent LAN backups. If set to true, default value for parallel data transfer operations will
        /// be 100. If set to false, default value of parallel data transfer operations will be set to 25.
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allows optimization for concurrent LAN backups. If set to true, default value for parallel data transfer operations will be 100. If set to false, default value of parallel data transfer operations will be set to 25.",
        SerializedName = @"optimizeForConcurrentLANBackups",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ControlOptimizeForConcurrentLanBackups { get; set; }
        /// <summary>Specifies the number of parallel data operations that can take place.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the number of parallel data operations that can take place. ",
        SerializedName = @"parallelDataTransferOperations",
        PossibleTypes = new [] { typeof(int) })]
        int? ControlParallelDataTransferOperations { get; set; }
        /// <summary>
        /// If set to true, ransomware protection against the media agent is enabled. If set to false, ransomware protection against
        /// media agent is disabled.
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If set to true, ransomware protection against the media agent is enabled. If set to false, ransomware protection against media agent is disabled.",
        SerializedName = @"ransomwareProtection",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ControlRansomwareProtection { get; set; }
        /// <summary>Provides the media agent with a new description.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Provides the media agent with a new description.",
        SerializedName = @"description",
        PossibleTypes = new [] { typeof(string) })]
        string Description { get; set; }
        /// <summary>Path where the index cache is maintained.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Path where the index cache is maintained.",
        SerializedName = @"path",
        PossibleTypes = new [] { typeof(string) })]
        string IndexCachePath { get; set; }
        /// <summary>This tag determines if the logs cache has been enabled or not.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This tag determines if the logs cache has been enabled or not. ",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LogCacheEnabled { get; set; }
        /// <summary>If the logs cache is enabled, this tag gives the path to store the logs cache.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If the logs cache is enabled, this tag gives the path to store the logs cache.",
        SerializedName = @"path",
        PossibleTypes = new [] { typeof(string) })]
        string LogCachePath { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(int) })]
        int? RoleId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string RoleName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(int) })]
        int? UserGroupId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string UserGroupName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(int) })]
        int? UserId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string UserName { get; set; }

    }
    internal partial interface IUpdateMediaAgentInternal

    {
        Commvault.Powershell.Models.IMediaAgentControl Control { get; set; }
        /// <summary>Determines if the media agent is currently enabled or disabled.</summary>
        bool? ControlEnabled { get; set; }
        /// <summary>
        /// Specifies whether the MediaAgent is available for data protection, data recovery and auxiliary copy operations.
        /// </summary>
        bool? ControlMaintenanceMode { get; set; }
        /// <summary>
        /// Allows optimization for concurrent LAN backups. If set to true, default value for parallel data transfer operations will
        /// be 100. If set to false, default value of parallel data transfer operations will be set to 25.
        /// </summary>
        bool? ControlOptimizeForConcurrentLanBackups { get; set; }
        /// <summary>Specifies the number of parallel data operations that can take place.</summary>
        int? ControlParallelDataTransferOperations { get; set; }
        /// <summary>
        /// If set to true, ransomware protection against the media agent is enabled. If set to false, ransomware protection against
        /// media agent is disabled.
        /// </summary>
        bool? ControlRansomwareProtection { get; set; }
        /// <summary>Provides the media agent with a new description.</summary>
        string Description { get; set; }

        Commvault.Powershell.Models.IIndexCache IndexCache { get; set; }

        Commvault.Powershell.Models.IMediaAgentLogsCache IndexCacheLogsCache { get; set; }
        /// <summary>Path where the index cache is maintained.</summary>
        string IndexCachePath { get; set; }
        /// <summary>This tag determines if the logs cache has been enabled or not.</summary>
        bool? LogCacheEnabled { get; set; }
        /// <summary>If the logs cache is enabled, this tag gives the path to store the logs cache.</summary>
        string LogCachePath { get; set; }

        int? RoleId { get; set; }

        string RoleName { get; set; }
        /// <summary>
        /// A list of users or user groups each having a specific set of roles that determine the kind of operations they can perform
        /// on the entity. Either id/name of the user/usergroup/roles can be provided. If both id and name are provided, id will be
        /// taken into consideration.
        /// </summary>
        Commvault.Powershell.Models.IUpdateSecurityAssoc Security { get; set; }

        Commvault.Powershell.Models.IIdName SecurityRole { get; set; }

        Commvault.Powershell.Models.IIdName SecurityUser { get; set; }

        Commvault.Powershell.Models.IIdName SecurityUserGroup { get; set; }

        int? UserGroupId { get; set; }

        string UserGroupName { get; set; }

        int? UserId { get; set; }

        string UserName { get; set; }

    }
}