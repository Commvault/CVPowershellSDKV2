// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.8.3, generator: @autorest/powershell@3.0.415)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Commvault.Powershell.Models
{
    using static Commvault.Powershell.Runtime.Extensions;

    /// <summary>UpdatevmGroupReq</summary>
    public partial class UpdatevmGroupReq :
        Commvault.Powershell.Models.IUpdatevmGroupReq,
        Commvault.Powershell.Models.IUpdatevmGroupReqInternal
    {

        /// <summary>Backing field for <see cref="AccessNode" /> property.</summary>
        private Commvault.Powershell.Models.IIdName[] _accessNode;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public Commvault.Powershell.Models.IIdName[] AccessNode { get => this._accessNode; set => this._accessNode = value; }

        /// <summary>Backing field for <see cref="ActivityControl" /> property.</summary>
        private Commvault.Powershell.Models.IActivityControlOptions _activityControl;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IActivityControlOptions ActivityControl { get => (this._activityControl = this._activityControl ?? new Commvault.Powershell.Models.ActivityControlOptions()); set => this._activityControl = value; }

        /// <summary>true if Backup is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? ActivityControlEnableBackup { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).EnableBackup; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).EnableBackup = value ?? default(bool); }

        /// <summary>true if Restore is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? ActivityControlEnableRestore { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).EnableRestore; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).EnableRestore = value ?? default(bool); }

        /// <summary>Backing field for <see cref="ApplicationValidation" /> property.</summary>
        private Commvault.Powershell.Models.IVMAppValidation _applicationValidation;

        /// <summary>vmAppValidation</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public Commvault.Powershell.Models.IVMAppValidation ApplicationValidation { get => (this._applicationValidation = this._applicationValidation ?? new Commvault.Powershell.Models.VMAppValidation()); set => this._applicationValidation = value; }

        /// <summary>Delayed by n Hrs</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string BackupActivityControlOptionDelayTime { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionDelayTime; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionDelayTime = value ?? null; }

        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? BackupActivityControlOptionEnableAfterDelay { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionEnableAfterDelay; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionEnableAfterDelay = value ?? default(bool); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? BackupActivityControlOptionsTimeZoneId { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsTimeZoneId; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsTimeZoneId = value ?? default(int); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string BackupActivityControlOptionsTimeZoneName { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsTimeZoneName; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsTimeZoneName = value ?? null; }

        /// <summary>Internal Acessors for ActivityControl</summary>
        Commvault.Powershell.Models.IActivityControlOptions Commvault.Powershell.Models.IUpdatevmGroupReqInternal.ActivityControl { get => (this._activityControl = this._activityControl ?? new Commvault.Powershell.Models.ActivityControlOptions()); set { {_activityControl = value;} } }

        /// <summary>Internal Acessors for ActivityControlBackupActivityControlOptions</summary>
        Commvault.Powershell.Models.IBackupActivityControlOptionsProp Commvault.Powershell.Models.IUpdatevmGroupReqInternal.ActivityControlBackupActivityControlOptions { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptions; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptions = value; }

        /// <summary>Internal Acessors for ActivityControlRestoreActivityControlOptions</summary>
        Commvault.Powershell.Models.IBackupActivityControlOptionsProp Commvault.Powershell.Models.IUpdatevmGroupReqInternal.ActivityControlRestoreActivityControlOptions { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptions; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptions = value; }

        /// <summary>Internal Acessors for BackupActivityControlOptionTimeZone</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.BackupActivityControlOptionTimeZone { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionTimeZone; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionTimeZone = value; }

        /// <summary>Internal Acessors for Content</summary>
        Commvault.Powershell.Models.IVMContent Commvault.Powershell.Models.IUpdatevmGroupReqInternal.Content { get => (this._content = this._content ?? new Commvault.Powershell.Models.VMContent()); set { {_content = value;} } }

        /// <summary>Internal Acessors for Filters</summary>
        Commvault.Powershell.Models.IVMContent Commvault.Powershell.Models.IUpdatevmGroupReqInternal.Filters { get => (this._filters = this._filters ?? new Commvault.Powershell.Models.VMContent()); set { {_filters = value;} } }

        /// <summary>Internal Acessors for GuestCredentials</summary>
        Commvault.Powershell.Models.IUserNamePassword Commvault.Powershell.Models.IUpdatevmGroupReqInternal.GuestCredentials { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).GuestCredentialsCredentials; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).GuestCredentialsCredentials = value; }

        /// <summary>Internal Acessors for GuestCredentialsSavedCredentials</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.GuestCredentialsSavedCredentials { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).GuestCredentialsSavedCredentials; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).GuestCredentialsSavedCredentials = value; }

        /// <summary>Internal Acessors for Plan</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.Plan { get => (this._plan = this._plan ?? new Commvault.Powershell.Models.IdName()); set { {_plan = value;} } }

        /// <summary>Internal Acessors for RestoreActivityControlOptionTimeZone</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.RestoreActivityControlOptionTimeZone { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionTimeZone; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionTimeZone = value; }

        /// <summary>Internal Acessors for SettingGuestCredentials</summary>
        Commvault.Powershell.Models.IGuestCredentialInfo Commvault.Powershell.Models.IUpdatevmGroupReqInternal.SettingGuestCredentials { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).GuestCredentials; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).GuestCredentials = value; }

        /// <summary>Internal Acessors for Settings</summary>
        Commvault.Powershell.Models.IVMGroupSettings Commvault.Powershell.Models.IUpdatevmGroupReqInternal.Settings { get => (this._settings = this._settings ?? new Commvault.Powershell.Models.VMGroupSettings()); set { {_settings = value;} } }

        /// <summary>Internal Acessors for SnapshotManagement</summary>
        Commvault.Powershell.Models.ISnapCopyInfo Commvault.Powershell.Models.IUpdatevmGroupReqInternal.SnapshotManagement { get => (this._snapshotManagement = this._snapshotManagement ?? new Commvault.Powershell.Models.SnapCopyInfo()); set { {_snapshotManagement = value;} } }

        /// <summary>Internal Acessors for SnapshotManagementCrossAccountCopyDestinationClient</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.SnapshotManagementCrossAccountCopyDestinationClient { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).CrossAccountCopyDestinationClient; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).CrossAccountCopyDestinationClient = value; }

        /// <summary>Internal Acessors for SnapshotManagementSnapEngine</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.SnapshotManagementSnapEngine { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngine; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngine = value; }

        /// <summary>Internal Acessors for SnapshotManagementSnapMountProxy</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.SnapshotManagementSnapMountProxy { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxy; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxy = value; }

        /// <summary>Internal Acessors for Storage</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.Storage { get => (this._storage = this._storage ?? new Commvault.Powershell.Models.IdName()); set { {_storage = value;} } }

        /// <summary>Backing field for <see cref="Content" /> property.</summary>
        private Commvault.Powershell.Models.IVMContent _content;

        /// <summary>RuleContent</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IVMContent Content { get => (this._content = this._content ?? new Commvault.Powershell.Models.VMContent()); set => this._content = value; }

        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? ContentOverwrite { get => ((Commvault.Powershell.Models.IVMContentInternal)Content).Overwrite; set => ((Commvault.Powershell.Models.IVMContentInternal)Content).Overwrite = value ?? default(bool); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public Commvault.Powershell.Models.IRuleGroupContent[] ContentRuleGroups { get => ((Commvault.Powershell.Models.IVMContentInternal)Content).RuleGroups; set => ((Commvault.Powershell.Models.IVMContentInternal)Content).RuleGroups = value ?? null /* arrayOf */; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public Commvault.Powershell.Models.IVirtualMachinecontent[] ContentVirtualMachines { get => ((Commvault.Powershell.Models.IVMContentInternal)Content).VirtualMachines; set => ((Commvault.Powershell.Models.IVMContentInternal)Content).VirtualMachines = value ?? null /* arrayOf */; }

        /// <summary>username to access the network path</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string CredentialsName { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).CredentialsName; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).CredentialsName = value ?? null; }

        /// <summary>password to access the network path</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string CredentialsPassword { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).CredentialsPassword; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).CredentialsPassword = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? CrossAccountCopyDestinationClientId { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).CrossAccountCopyDestinationClientId; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).CrossAccountCopyDestinationClientId = value ?? default(int); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string CrossAccountCopyDestinationClientName { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).CrossAccountCopyDestinationClientName; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).CrossAccountCopyDestinationClientName = value ?? null; }

        /// <summary>Backing field for <see cref="DiskFilters" /> property.</summary>
        private Commvault.Powershell.Models.IVMDiskFilter[] _diskFilters;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public Commvault.Powershell.Models.IVMDiskFilter[] DiskFilters { get => this._diskFilters; set => this._diskFilters = value; }

        /// <summary>Backing field for <see cref="EnableFileIndexing" /> property.</summary>
        private bool? _enableFileIndexing;

        /// <summary>True if file indexing needs to be enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public bool? EnableFileIndexing { get => this._enableFileIndexing; set => this._enableFileIndexing = value; }

        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? FilterOverwrite { get => ((Commvault.Powershell.Models.IVMContentInternal)Filters).Overwrite; set => ((Commvault.Powershell.Models.IVMContentInternal)Filters).Overwrite = value ?? default(bool); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public Commvault.Powershell.Models.IRuleGroupContent[] FilterRuleGroups { get => ((Commvault.Powershell.Models.IVMContentInternal)Filters).RuleGroups; set => ((Commvault.Powershell.Models.IVMContentInternal)Filters).RuleGroups = value ?? null /* arrayOf */; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public Commvault.Powershell.Models.IVirtualMachinecontent[] FilterVirtualMachines { get => ((Commvault.Powershell.Models.IVMContentInternal)Filters).VirtualMachines; set => ((Commvault.Powershell.Models.IVMContentInternal)Filters).VirtualMachines = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="Filters" /> property.</summary>
        private Commvault.Powershell.Models.IVMContent _filters;

        /// <summary>RuleContent</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IVMContent Filters { get => (this._filters = this._filters ?? new Commvault.Powershell.Models.VMContent()); set => this._filters = value; }

        /// <summary>Backing field for <see cref="NewName" /> property.</summary>
        private string _newName;

        /// <summary>subclient name</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string NewName { get => this._newName; set => this._newName = value; }

        /// <summary>Backing field for <see cref="Plan" /> property.</summary>
        private Commvault.Powershell.Models.IIdName _plan;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IIdName Plan { get => (this._plan = this._plan ?? new Commvault.Powershell.Models.IdName()); set => this._plan = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? PlanId { get => ((Commvault.Powershell.Models.IIdNameInternal)Plan).Id; set => ((Commvault.Powershell.Models.IIdNameInternal)Plan).Id = value ?? default(int); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string PlanName { get => ((Commvault.Powershell.Models.IIdNameInternal)Plan).Name; set => ((Commvault.Powershell.Models.IIdNameInternal)Plan).Name = value ?? null; }

        /// <summary>Delayed by n Hrs</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string RestoreActivityControlOptionDelayTime { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionDelayTime; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionDelayTime = value ?? null; }

        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? RestoreActivityControlOptionEnableAfterDelay { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionEnableAfterDelay; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionEnableAfterDelay = value ?? default(bool); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? RestoreActivityControlOptionsTimeZoneId { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsTimeZoneId; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsTimeZoneId = value ?? default(int); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string RestoreActivityControlOptionsTimeZoneName { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsTimeZoneName; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsTimeZoneName = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? SavedCredentialsId { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).SavedCredentialsId; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).SavedCredentialsId = value ?? default(int); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SavedCredentialsName { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).SavedCredentialsName; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).SavedCredentialsName = value ?? null; }

        /// <summary>Backing field for <see cref="SecurityAssociations" /> property.</summary>
        private Commvault.Powershell.Models.ISecurityAssoc[] _securityAssociations;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public Commvault.Powershell.Models.ISecurityAssoc[] SecurityAssociations { get => this._securityAssociations; set => this._securityAssociations = value; }

        /// <summary>True if auto detect VM Owner enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SettingAutoDetectVMOwner { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).AutoDetectVMOwner; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).AutoDetectVMOwner = value ?? default(bool); }

        /// <summary>
        /// True if metadata collection is enabled for intellisnap jobs. Only applicable for Indexing v1
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SettingCollectFileDetailsFromSnapshotCopy { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).CollectFileDetailsFromSnapshotCopy; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).CollectFileDetailsFromSnapshotCopy = value ?? default(bool); }

        /// <summary>True if metadata collection is enabled. Only applicable for Indexing v1</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SettingCollectFileDetailsforGranularRecovery { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).CollectFileDetailsforGranularRecovery; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).CollectFileDetailsforGranularRecovery = value ?? default(bool); }

        /// <summary>Custom snapshot resource group GUID for Azure</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SettingCustomSnapshotResourceGroup { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).CustomSnapshotResourceGroup; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).CustomSnapshotResourceGroup = value ?? null; }

        /// <summary>True if Datastore Free space check is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SettingDatastoreFreespaceCheck { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).DatastoreFreespaceCheck; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).DatastoreFreespaceCheck = value ?? default(bool); }

        /// <summary>precentage of datastore free space check value</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? SettingDatastoreFreespaceRequired { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).DatastoreFreespaceRequired; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).DatastoreFreespaceRequired = value ?? default(int); }

        /// <summary>Is the VM App Aware</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SettingIsApplicationAware { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).IsApplicationAware; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).IsApplicationAware = value ?? default(bool); }

        /// <summary>Start Time for the VM Group Job</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? SettingJobStartTime { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).JobStartTime; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).JobStartTime = value ?? default(int); }

        /// <summary>Number of readers for backup</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? SettingNoOfReaders { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).NoOfReaders; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).NoOfReaders = value ?? default(int); }

        /// <summary>transport mode based on environment. Values are case sensitive</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SettingTransportMode { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).TransportMode; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).TransportMode = value ?? null; }

        /// <summary>True if Changed Block Tracking is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SettingUseChangedBlockTrackingOnVM { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).UseChangedBlockTrackingOnVM; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).UseChangedBlockTrackingOnVM = value ?? default(bool); }

        /// <summary>True if use VM CheckPoint setting is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SettingUseVMCheckpointSetting { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).UseVMCheckpointSetting; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).UseVMCheckpointSetting = value ?? default(bool); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SettingVMBackupType { get => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).VMBackupType; set => ((Commvault.Powershell.Models.IVMGroupSettingsInternal)Settings).VMBackupType = value ?? null; }

        /// <summary>Backing field for <see cref="Settings" /> property.</summary>
        private Commvault.Powershell.Models.IVMGroupSettings _settings;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IVMGroupSettings Settings { get => (this._settings = this._settings ?? new Commvault.Powershell.Models.VMGroupSettings()); set => this._settings = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? SnapEngineId { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngineId; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngineId = value ?? default(int); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapEngineName { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngineName; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngineName = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? SnapMountProxyId { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxyId; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxyId = value ?? default(int); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapMountProxyName { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxyName; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxyName = value ?? null; }

        /// <summary>Backing field for <see cref="SnapshotManagement" /> property.</summary>
        private Commvault.Powershell.Models.ISnapCopyInfo _snapshotManagement;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.ISnapCopyInfo SnapshotManagement { get => (this._snapshotManagement = this._snapshotManagement ?? new Commvault.Powershell.Models.SnapCopyInfo()); set => this._snapshotManagement = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapshotManagementBackupCopyInterface { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).BackupCopyInterface; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).BackupCopyInterface = value ?? null; }

        /// <summary>True if hardware snapshot is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SnapshotManagementEnableHardwareSnapshot { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).EnableHardwareSnapshot; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).EnableHardwareSnapshot = value ?? default(bool); }

        /// <summary>True if full copy of amazon snapshot to different amazon account is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SnapshotManagementIsCrossAccountCopyEnabled { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsCrossAccountCopyEnabled; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsCrossAccountCopyEnabled = value ?? default(bool); }

        /// <summary>
        /// True if replicate and copy or sharing of amazon snapshot to different amazon account in same or different geographic location
        /// is enabled
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SnapshotManagementIsCrossAccountEnabled { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsCrossAccountEnabled; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsCrossAccountEnabled = value ?? default(bool); }

        /// <summary>True if independent disk option is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SnapshotManagementIsIndependentDisksEnabled { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsIndependentDisksEnabled; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsIndependentDisksEnabled = value ?? default(bool); }

        /// <summary>True if raw device maps option is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SnapshotManagementIsRawDeviceMapsEnabled { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsRawDeviceMapsEnabled; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsRawDeviceMapsEnabled = value ?? default(bool); }

        /// <summary>Name of ESX Host</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapshotManagementSnapMountEsxHost { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountEsxHost; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountEsxHost = value ?? null; }

        /// <summary>True if separate proxy client is used for snap to tape</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SnapshotManagementUseSeparateProxyForSnapToTape { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).UseSeparateProxyForSnapToTape; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).UseSeparateProxyForSnapToTape = value ?? default(bool); }

        /// <summary>Virtual machine application user name</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapshotManagementVMApplicationUserName { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).VMApplicationUserName; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).VMApplicationUserName = value ?? null; }

        /// <summary>Backing field for <see cref="Storage" /> property.</summary>
        private Commvault.Powershell.Models.IIdName _storage;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IIdName Storage { get => (this._storage = this._storage ?? new Commvault.Powershell.Models.IdName()); set => this._storage = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public int? StorageId { get => ((Commvault.Powershell.Models.IIdNameInternal)Storage).Id; set => ((Commvault.Powershell.Models.IIdNameInternal)Storage).Id = value ?? default(int); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string StorageName { get => ((Commvault.Powershell.Models.IIdNameInternal)Storage).Name; set => ((Commvault.Powershell.Models.IIdNameInternal)Storage).Name = value ?? null; }

        /// <summary>Creates an new <see cref="UpdatevmGroupReq" /> instance.</summary>
        public UpdatevmGroupReq()
        {

        }
    }
    /// UpdatevmGroupReq
    public partial interface IUpdatevmGroupReq :
        Commvault.Powershell.Runtime.IJsonSerializable
    {
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"accessNode",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IIdName) })]
        Commvault.Powershell.Models.IIdName[] AccessNode { get; set; }
        /// <summary>true if Backup is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"true if Backup is enabled",
        SerializedName = @"enableBackup",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ActivityControlEnableBackup { get; set; }
        /// <summary>true if Restore is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"true if Restore is enabled",
        SerializedName = @"enableRestore",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ActivityControlEnableRestore { get; set; }
        /// <summary>vmAppValidation</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"vmAppValidation",
        SerializedName = @"applicationValidation",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IVMAppValidation) })]
        Commvault.Powershell.Models.IVMAppValidation ApplicationValidation { get; set; }
        /// <summary>Delayed by n Hrs</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Delayed by n Hrs",
        SerializedName = @"delayTime",
        PossibleTypes = new [] { typeof(string) })]
        string BackupActivityControlOptionDelayTime { get; set; }
        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if the activity will be enabled after a delay time interval",
        SerializedName = @"enableAfterDelay",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BackupActivityControlOptionEnableAfterDelay { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(int) })]
        int? BackupActivityControlOptionsTimeZoneId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string BackupActivityControlOptionsTimeZoneName { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if content in vmgroup has to be overwritten, by default it will append the content",
        SerializedName = @"overwrite",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ContentOverwrite { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"ruleGroups",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IRuleGroupContent) })]
        Commvault.Powershell.Models.IRuleGroupContent[] ContentRuleGroups { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"virtualMachines",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IVirtualMachinecontent) })]
        Commvault.Powershell.Models.IVirtualMachinecontent[] ContentVirtualMachines { get; set; }
        /// <summary>username to access the network path</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"username to access the network path",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string CredentialsName { get; set; }
        /// <summary>password to access the network path</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"password to access the network path",
        SerializedName = @"password",
        PossibleTypes = new [] { typeof(string) })]
        string CredentialsPassword { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(int) })]
        int? CrossAccountCopyDestinationClientId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string CrossAccountCopyDestinationClientName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"diskFilters",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IVMDiskFilter) })]
        Commvault.Powershell.Models.IVMDiskFilter[] DiskFilters { get; set; }
        /// <summary>True if file indexing needs to be enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if file indexing needs to be enabled",
        SerializedName = @"enableFileIndexing",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnableFileIndexing { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if content in vmgroup has to be overwritten, by default it will append the content",
        SerializedName = @"overwrite",
        PossibleTypes = new [] { typeof(bool) })]
        bool? FilterOverwrite { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"ruleGroups",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IRuleGroupContent) })]
        Commvault.Powershell.Models.IRuleGroupContent[] FilterRuleGroups { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"virtualMachines",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IVirtualMachinecontent) })]
        Commvault.Powershell.Models.IVirtualMachinecontent[] FilterVirtualMachines { get; set; }
        /// <summary>subclient name</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"subclient name ",
        SerializedName = @"newName",
        PossibleTypes = new [] { typeof(string) })]
        string NewName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(int) })]
        int? PlanId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string PlanName { get; set; }
        /// <summary>Delayed by n Hrs</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Delayed by n Hrs",
        SerializedName = @"delayTime",
        PossibleTypes = new [] { typeof(string) })]
        string RestoreActivityControlOptionDelayTime { get; set; }
        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if the activity will be enabled after a delay time interval",
        SerializedName = @"enableAfterDelay",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RestoreActivityControlOptionEnableAfterDelay { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(int) })]
        int? RestoreActivityControlOptionsTimeZoneId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string RestoreActivityControlOptionsTimeZoneName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(int) })]
        int? SavedCredentialsId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string SavedCredentialsName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"securityAssociations",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.ISecurityAssoc) })]
        Commvault.Powershell.Models.ISecurityAssoc[] SecurityAssociations { get; set; }
        /// <summary>True if auto detect VM Owner enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if auto detect VM Owner enabled",
        SerializedName = @"autoDetectVMOwner",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SettingAutoDetectVMOwner { get; set; }
        /// <summary>
        /// True if metadata collection is enabled for intellisnap jobs. Only applicable for Indexing v1
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if metadata collection is enabled for intellisnap jobs. Only applicable for Indexing v1",
        SerializedName = @"collectFileDetailsFromSnapshotCopy",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SettingCollectFileDetailsFromSnapshotCopy { get; set; }
        /// <summary>True if metadata collection is enabled. Only applicable for Indexing v1</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if metadata collection is enabled. Only applicable for Indexing v1",
        SerializedName = @"collectFileDetailsforGranularRecovery",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SettingCollectFileDetailsforGranularRecovery { get; set; }
        /// <summary>Custom snapshot resource group GUID for Azure</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Custom snapshot resource group GUID for Azure",
        SerializedName = @"customSnapshotResourceGroup",
        PossibleTypes = new [] { typeof(string) })]
        string SettingCustomSnapshotResourceGroup { get; set; }
        /// <summary>True if Datastore Free space check is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if Datastore Free space check is enabled",
        SerializedName = @"datastoreFreespaceCheck",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SettingDatastoreFreespaceCheck { get; set; }
        /// <summary>precentage of datastore free space check value</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"precentage of datastore free space check value",
        SerializedName = @"datastoreFreespaceRequired",
        PossibleTypes = new [] { typeof(int) })]
        int? SettingDatastoreFreespaceRequired { get; set; }
        /// <summary>Is the VM App Aware</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Is the VM App Aware",
        SerializedName = @"isApplicationAware",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SettingIsApplicationAware { get; set; }
        /// <summary>Start Time for the VM Group Job</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Start Time for the VM Group Job",
        SerializedName = @"jobStartTime",
        PossibleTypes = new [] { typeof(int) })]
        int? SettingJobStartTime { get; set; }
        /// <summary>Number of readers for backup</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of readers for backup",
        SerializedName = @"noOfReaders",
        PossibleTypes = new [] { typeof(int) })]
        int? SettingNoOfReaders { get; set; }
        /// <summary>transport mode based on environment. Values are case sensitive</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"transport mode based on environment. Values are case sensitive",
        SerializedName = @"transportMode",
        PossibleTypes = new [] { typeof(string) })]
        string SettingTransportMode { get; set; }
        /// <summary>True if Changed Block Tracking is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if Changed Block Tracking is enabled",
        SerializedName = @"useChangedBlockTrackingOnVM",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SettingUseChangedBlockTrackingOnVM { get; set; }
        /// <summary>True if use VM CheckPoint setting is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if use VM CheckPoint setting is enabled",
        SerializedName = @"useVMCheckpointSetting",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SettingUseVMCheckpointSetting { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"vmBackupType",
        PossibleTypes = new [] { typeof(string) })]
        string SettingVMBackupType { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(int) })]
        int? SnapEngineId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string SnapEngineName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(int) })]
        int? SnapMountProxyId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string SnapMountProxyName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"backupCopyInterface",
        PossibleTypes = new [] { typeof(string) })]
        string SnapshotManagementBackupCopyInterface { get; set; }
        /// <summary>True if hardware snapshot is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if hardware snapshot is enabled",
        SerializedName = @"enableHardwareSnapshot",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotManagementEnableHardwareSnapshot { get; set; }
        /// <summary>True if full copy of amazon snapshot to different amazon account is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if full copy of amazon snapshot to different amazon account is enabled",
        SerializedName = @"isCrossAccountCopyEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotManagementIsCrossAccountCopyEnabled { get; set; }
        /// <summary>
        /// True if replicate and copy or sharing of amazon snapshot to different amazon account in same or different geographic location
        /// is enabled
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if replicate and copy or sharing of amazon snapshot to different amazon account in same or different geographic location is enabled",
        SerializedName = @"isCrossAccountEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotManagementIsCrossAccountEnabled { get; set; }
        /// <summary>True if independent disk option is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if independent disk option is enabled",
        SerializedName = @"isIndependentDisksEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotManagementIsIndependentDisksEnabled { get; set; }
        /// <summary>True if raw device maps option is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if raw device maps option is enabled",
        SerializedName = @"isRawDeviceMapsEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotManagementIsRawDeviceMapsEnabled { get; set; }
        /// <summary>Name of ESX Host</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Name of ESX Host",
        SerializedName = @"snapMountESXHost",
        PossibleTypes = new [] { typeof(string) })]
        string SnapshotManagementSnapMountEsxHost { get; set; }
        /// <summary>True if separate proxy client is used for snap to tape</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if separate proxy client is used for snap to tape",
        SerializedName = @"useSeparateProxyForSnapToTape",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotManagementUseSeparateProxyForSnapToTape { get; set; }
        /// <summary>Virtual machine application user name</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Virtual machine application user name",
        SerializedName = @"vmApplicationUserName",
        PossibleTypes = new [] { typeof(string) })]
        string SnapshotManagementVMApplicationUserName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(int) })]
        int? StorageId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string StorageName { get; set; }

    }
    /// UpdatevmGroupReq
    internal partial interface IUpdatevmGroupReqInternal

    {
        Commvault.Powershell.Models.IIdName[] AccessNode { get; set; }

        Commvault.Powershell.Models.IActivityControlOptions ActivityControl { get; set; }

        Commvault.Powershell.Models.IBackupActivityControlOptionsProp ActivityControlBackupActivityControlOptions { get; set; }
        /// <summary>true if Backup is enabled</summary>
        bool? ActivityControlEnableBackup { get; set; }
        /// <summary>true if Restore is enabled</summary>
        bool? ActivityControlEnableRestore { get; set; }

        Commvault.Powershell.Models.IBackupActivityControlOptionsProp ActivityControlRestoreActivityControlOptions { get; set; }
        /// <summary>vmAppValidation</summary>
        Commvault.Powershell.Models.IVMAppValidation ApplicationValidation { get; set; }
        /// <summary>Delayed by n Hrs</summary>
        string BackupActivityControlOptionDelayTime { get; set; }
        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        bool? BackupActivityControlOptionEnableAfterDelay { get; set; }

        Commvault.Powershell.Models.IIdName BackupActivityControlOptionTimeZone { get; set; }

        int? BackupActivityControlOptionsTimeZoneId { get; set; }

        string BackupActivityControlOptionsTimeZoneName { get; set; }
        /// <summary>RuleContent</summary>
        Commvault.Powershell.Models.IVMContent Content { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        bool? ContentOverwrite { get; set; }

        Commvault.Powershell.Models.IRuleGroupContent[] ContentRuleGroups { get; set; }

        Commvault.Powershell.Models.IVirtualMachinecontent[] ContentVirtualMachines { get; set; }
        /// <summary>username to access the network path</summary>
        string CredentialsName { get; set; }
        /// <summary>password to access the network path</summary>
        string CredentialsPassword { get; set; }

        int? CrossAccountCopyDestinationClientId { get; set; }

        string CrossAccountCopyDestinationClientName { get; set; }

        Commvault.Powershell.Models.IVMDiskFilter[] DiskFilters { get; set; }
        /// <summary>True if file indexing needs to be enabled</summary>
        bool? EnableFileIndexing { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        bool? FilterOverwrite { get; set; }

        Commvault.Powershell.Models.IRuleGroupContent[] FilterRuleGroups { get; set; }

        Commvault.Powershell.Models.IVirtualMachinecontent[] FilterVirtualMachines { get; set; }
        /// <summary>RuleContent</summary>
        Commvault.Powershell.Models.IVMContent Filters { get; set; }

        Commvault.Powershell.Models.IUserNamePassword GuestCredentials { get; set; }

        Commvault.Powershell.Models.IIdName GuestCredentialsSavedCredentials { get; set; }
        /// <summary>subclient name</summary>
        string NewName { get; set; }

        Commvault.Powershell.Models.IIdName Plan { get; set; }

        int? PlanId { get; set; }

        string PlanName { get; set; }
        /// <summary>Delayed by n Hrs</summary>
        string RestoreActivityControlOptionDelayTime { get; set; }
        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        bool? RestoreActivityControlOptionEnableAfterDelay { get; set; }

        Commvault.Powershell.Models.IIdName RestoreActivityControlOptionTimeZone { get; set; }

        int? RestoreActivityControlOptionsTimeZoneId { get; set; }

        string RestoreActivityControlOptionsTimeZoneName { get; set; }

        int? SavedCredentialsId { get; set; }

        string SavedCredentialsName { get; set; }

        Commvault.Powershell.Models.ISecurityAssoc[] SecurityAssociations { get; set; }
        /// <summary>True if auto detect VM Owner enabled</summary>
        bool? SettingAutoDetectVMOwner { get; set; }
        /// <summary>
        /// True if metadata collection is enabled for intellisnap jobs. Only applicable for Indexing v1
        /// </summary>
        bool? SettingCollectFileDetailsFromSnapshotCopy { get; set; }
        /// <summary>True if metadata collection is enabled. Only applicable for Indexing v1</summary>
        bool? SettingCollectFileDetailsforGranularRecovery { get; set; }
        /// <summary>Custom snapshot resource group GUID for Azure</summary>
        string SettingCustomSnapshotResourceGroup { get; set; }
        /// <summary>True if Datastore Free space check is enabled</summary>
        bool? SettingDatastoreFreespaceCheck { get; set; }
        /// <summary>precentage of datastore free space check value</summary>
        int? SettingDatastoreFreespaceRequired { get; set; }
        /// <summary>guestCredentialInfo</summary>
        Commvault.Powershell.Models.IGuestCredentialInfo SettingGuestCredentials { get; set; }
        /// <summary>Is the VM App Aware</summary>
        bool? SettingIsApplicationAware { get; set; }
        /// <summary>Start Time for the VM Group Job</summary>
        int? SettingJobStartTime { get; set; }
        /// <summary>Number of readers for backup</summary>
        int? SettingNoOfReaders { get; set; }
        /// <summary>transport mode based on environment. Values are case sensitive</summary>
        string SettingTransportMode { get; set; }
        /// <summary>True if Changed Block Tracking is enabled</summary>
        bool? SettingUseChangedBlockTrackingOnVM { get; set; }
        /// <summary>True if use VM CheckPoint setting is enabled</summary>
        bool? SettingUseVMCheckpointSetting { get; set; }

        string SettingVMBackupType { get; set; }

        Commvault.Powershell.Models.IVMGroupSettings Settings { get; set; }

        int? SnapEngineId { get; set; }

        string SnapEngineName { get; set; }

        int? SnapMountProxyId { get; set; }

        string SnapMountProxyName { get; set; }

        Commvault.Powershell.Models.ISnapCopyInfo SnapshotManagement { get; set; }

        string SnapshotManagementBackupCopyInterface { get; set; }

        Commvault.Powershell.Models.IIdName SnapshotManagementCrossAccountCopyDestinationClient { get; set; }
        /// <summary>True if hardware snapshot is enabled</summary>
        bool? SnapshotManagementEnableHardwareSnapshot { get; set; }
        /// <summary>True if full copy of amazon snapshot to different amazon account is enabled</summary>
        bool? SnapshotManagementIsCrossAccountCopyEnabled { get; set; }
        /// <summary>
        /// True if replicate and copy or sharing of amazon snapshot to different amazon account in same or different geographic location
        /// is enabled
        /// </summary>
        bool? SnapshotManagementIsCrossAccountEnabled { get; set; }
        /// <summary>True if independent disk option is enabled</summary>
        bool? SnapshotManagementIsIndependentDisksEnabled { get; set; }
        /// <summary>True if raw device maps option is enabled</summary>
        bool? SnapshotManagementIsRawDeviceMapsEnabled { get; set; }

        Commvault.Powershell.Models.IIdName SnapshotManagementSnapEngine { get; set; }
        /// <summary>Name of ESX Host</summary>
        string SnapshotManagementSnapMountEsxHost { get; set; }

        Commvault.Powershell.Models.IIdName SnapshotManagementSnapMountProxy { get; set; }
        /// <summary>True if separate proxy client is used for snap to tape</summary>
        bool? SnapshotManagementUseSeparateProxyForSnapToTape { get; set; }
        /// <summary>Virtual machine application user name</summary>
        string SnapshotManagementVMApplicationUserName { get; set; }

        Commvault.Powershell.Models.IIdName Storage { get; set; }

        int? StorageId { get; set; }

        string StorageName { get; set; }

    }
}