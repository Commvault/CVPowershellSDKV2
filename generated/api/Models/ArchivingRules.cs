// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.0.6365, generator: {generator})
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Commvault.Powershell.Models
{
    using static Commvault.Powershell.Runtime.Extensions;

    /// <summary>These rules are enforced only when archiving is set to true</summary>
    public partial class ArchivingRules :
        Commvault.Powershell.Models.IArchivingRules,
        Commvault.Powershell.Models.IArchivingRulesInternal
    {

        /// <summary>Backing field for <see cref="AfterArchiving" /> property.</summary>
        private string _afterArchiving;

        /// <summary>
        /// After an archive job, replace the file that meets the archiving rules with a stub or delete the file that meets the archiving
        /// rules
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string AfterArchiving { get => this._afterArchiving; set => this._afterArchiving = value; }

        /// <summary>Backing field for <see cref="ArchiveReadOnlyFiles" /> property.</summary>
        private bool? _archiveReadOnlyFiles;

        /// <summary>To archive files based on the Read-Only attribute, set to TRUE</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public bool? ArchiveReadOnlyFiles { get => this._archiveReadOnlyFiles; set => this._archiveReadOnlyFiles = value; }

        /// <summary>Backing field for <see cref="FileAccessTimeOlderThan" /> property.</summary>
        private int? _fileAccessTimeOlderThan;

        /// <summary>
        /// To archive files based on the last accessed date of each file within the folder, specify the number of days
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public int? FileAccessTimeOlderThan { get => this._fileAccessTimeOlderThan; set => this._fileAccessTimeOlderThan = value; }

        /// <summary>Backing field for <see cref="FileCreatedTimeOlderThan" /> property.</summary>
        private int? _fileCreatedTimeOlderThan;

        /// <summary>
        /// To archive files based on the time the files were created within the folder, specify the number of days
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public int? FileCreatedTimeOlderThan { get => this._fileCreatedTimeOlderThan; set => this._fileCreatedTimeOlderThan = value; }

        /// <summary>Backing field for <see cref="FileModifiedTimeOlderThan" /> property.</summary>
        private int? _fileModifiedTimeOlderThan;

        /// <summary>
        /// To archive files based on the last modified date of each file within the folder, specify the number of days
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public int? FileModifiedTimeOlderThan { get => this._fileModifiedTimeOlderThan; set => this._fileModifiedTimeOlderThan = value; }

        /// <summary>Backing field for <see cref="FileSizeGreaterThan" /> property.</summary>
        private int? _fileSizeGreaterThan;

        /// <summary>
        /// To archive files based on the size of the file, specify the minimum file size in KB. All files whose size ranges between
        /// the minimum and maximum values are archived.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public int? FileSizeGreaterThan { get => this._fileSizeGreaterThan; set => this._fileSizeGreaterThan = value; }

        /// <summary>Backing field for <see cref="MaximumFileSize" /> property.</summary>
        private int? _maximumFileSize;

        /// <summary>
        /// To archive files based on the size of the file, specify the maximum file size in KB. All files whose size ranges between
        /// the minimum and maximum values are archived.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public int? MaximumFileSize { get => this._maximumFileSize; set => this._maximumFileSize = value; }

        /// <summary>Backing field for <see cref="StartCleaningIfLessThan" /> property.</summary>
        private int? _startCleaningIfLessThan;

        /// <summary>
        /// When free disk space falls below specified amount (in percentage), start cleaning up the disk
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public int? StartCleaningIfLessThan { get => this._startCleaningIfLessThan; set => this._startCleaningIfLessThan = value; }

        /// <summary>Backing field for <see cref="StopCleaningIfupto" /> property.</summary>
        private int? _stopCleaningIfupto;

        /// <summary>
        /// When free disk space more than specified amount (in percentage), stop cleaning up the disk
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public int? StopCleaningIfupto { get => this._stopCleaningIfupto; set => this._stopCleaningIfupto = value; }

        /// <summary>Creates an new <see cref="ArchivingRules" /> instance.</summary>
        public ArchivingRules()
        {

        }
    }
    /// These rules are enforced only when archiving is set to true
    public partial interface IArchivingRules :
        Commvault.Powershell.Runtime.IJsonSerializable
    {
        /// <summary>
        /// After an archive job, replace the file that meets the archiving rules with a stub or delete the file that meets the archiving
        /// rules
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"After an archive job, replace the file that meets the archiving rules with a stub or delete the file that meets the archiving rules",
        SerializedName = @"afterArchiving",
        PossibleTypes = new [] { typeof(string) })]
        string AfterArchiving { get; set; }
        /// <summary>To archive files based on the Read-Only attribute, set to TRUE</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To archive files based on the Read-Only attribute, set to TRUE",
        SerializedName = @"archiveReadOnlyFiles",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ArchiveReadOnlyFiles { get; set; }
        /// <summary>
        /// To archive files based on the last accessed date of each file within the folder, specify the number of days
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To archive files based on the last accessed date of each file within the folder, specify the number of days",
        SerializedName = @"fileAccessTimeOlderThan",
        PossibleTypes = new [] { typeof(int) })]
        int? FileAccessTimeOlderThan { get; set; }
        /// <summary>
        /// To archive files based on the time the files were created within the folder, specify the number of days
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To archive files based on the time the files were created within the folder, specify the number of days",
        SerializedName = @"fileCreatedTimeOlderThan",
        PossibleTypes = new [] { typeof(int) })]
        int? FileCreatedTimeOlderThan { get; set; }
        /// <summary>
        /// To archive files based on the last modified date of each file within the folder, specify the number of days
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To archive files based on the last modified date of each file within the folder, specify the number of days",
        SerializedName = @"fileModifiedTimeOlderThan",
        PossibleTypes = new [] { typeof(int) })]
        int? FileModifiedTimeOlderThan { get; set; }
        /// <summary>
        /// To archive files based on the size of the file, specify the minimum file size in KB. All files whose size ranges between
        /// the minimum and maximum values are archived.
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To archive files based on the size of the file, specify the minimum file size in KB. All files whose size ranges between the minimum and maximum values are archived.",
        SerializedName = @"fileSizeGreaterThan",
        PossibleTypes = new [] { typeof(int) })]
        int? FileSizeGreaterThan { get; set; }
        /// <summary>
        /// To archive files based on the size of the file, specify the maximum file size in KB. All files whose size ranges between
        /// the minimum and maximum values are archived.
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To archive files based on the size of the file, specify the maximum file size in KB. All files whose size ranges between the minimum and maximum values are archived.",
        SerializedName = @"maximumFileSize",
        PossibleTypes = new [] { typeof(int) })]
        int? MaximumFileSize { get; set; }
        /// <summary>
        /// When free disk space falls below specified amount (in percentage), start cleaning up the disk
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"When free disk space falls below specified amount (in percentage), start cleaning up the disk",
        SerializedName = @"startCleaningIfLessThan",
        PossibleTypes = new [] { typeof(int) })]
        int? StartCleaningIfLessThan { get; set; }
        /// <summary>
        /// When free disk space more than specified amount (in percentage), stop cleaning up the disk
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"When free disk space more than specified amount (in percentage), stop cleaning up the disk",
        SerializedName = @"stopCleaningIfupto",
        PossibleTypes = new [] { typeof(int) })]
        int? StopCleaningIfupto { get; set; }

    }
    /// These rules are enforced only when archiving is set to true
    internal partial interface IArchivingRulesInternal

    {
        /// <summary>
        /// After an archive job, replace the file that meets the archiving rules with a stub or delete the file that meets the archiving
        /// rules
        /// </summary>
        string AfterArchiving { get; set; }
        /// <summary>To archive files based on the Read-Only attribute, set to TRUE</summary>
        bool? ArchiveReadOnlyFiles { get; set; }
        /// <summary>
        /// To archive files based on the last accessed date of each file within the folder, specify the number of days
        /// </summary>
        int? FileAccessTimeOlderThan { get; set; }
        /// <summary>
        /// To archive files based on the time the files were created within the folder, specify the number of days
        /// </summary>
        int? FileCreatedTimeOlderThan { get; set; }
        /// <summary>
        /// To archive files based on the last modified date of each file within the folder, specify the number of days
        /// </summary>
        int? FileModifiedTimeOlderThan { get; set; }
        /// <summary>
        /// To archive files based on the size of the file, specify the minimum file size in KB. All files whose size ranges between
        /// the minimum and maximum values are archived.
        /// </summary>
        int? FileSizeGreaterThan { get; set; }
        /// <summary>
        /// To archive files based on the size of the file, specify the maximum file size in KB. All files whose size ranges between
        /// the minimum and maximum values are archived.
        /// </summary>
        int? MaximumFileSize { get; set; }
        /// <summary>
        /// When free disk space falls below specified amount (in percentage), start cleaning up the disk
        /// </summary>
        int? StartCleaningIfLessThan { get; set; }
        /// <summary>
        /// When free disk space more than specified amount (in percentage), stop cleaning up the disk
        /// </summary>
        int? StopCleaningIfupto { get; set; }

    }
}