// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.2, generator: @autorest/powershell@4.0.708)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Commvault.Powershell.Models
{
    using static Commvault.Powershell.Runtime.Extensions;

    /// <summary>AlertDefinitionsDetails</summary>
    public partial class AlertDefinitionsDetails :
        Commvault.Powershell.Models.IAlertDefinitionsDetails,
        Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal
    {

        /// <summary>Backing field for <see cref="AdditionalProperties" /> property.</summary>
        private Commvault.Powershell.Models.IAlertAdditionalProperties _additionalProperties;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IAlertAdditionalProperties AdditionalProperties { get => (this._additionalProperties = this._additionalProperties ?? new Commvault.Powershell.Models.AlertAdditionalProperties()); set => this._additionalProperties = value; }

        /// <summary>Tells status of alert. Can be used to find if alert is enabled or not.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? AdditionalPropertyStatus { get => ((Commvault.Powershell.Models.IAlertAdditionalPropertiesInternal)AdditionalProperties).Status; set => ((Commvault.Powershell.Models.IAlertAdditionalPropertiesInternal)AdditionalProperties).Status = value ?? default(long); }

        /// <summary>List of query parameters</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IQueryParameter> AdditionalQueryInfoQueryParameters { get => ((Commvault.Powershell.Models.ICustomQueryDetailsInternal)CustomQueryDetails).AdditionalQueryInfoQueryParameters; set => ((Commvault.Powershell.Models.ICustomQueryDetailsInternal)CustomQueryDetails).AdditionalQueryInfoQueryParameters = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="AlertSummary" /> property.</summary>
        private Commvault.Powershell.Models.IAlertDetailsSummary _alertSummary;

        /// <summary>AlertDetailsSummary</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IAlertDetailsSummary AlertSummary { get => (this._alertSummary = this._alertSummary ?? new Commvault.Powershell.Models.AlertDetailsSummary()); set => this._alertSummary = value; }

        /// <summary>List of alert criteria</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IAlertCriteriaIdName1> AlertSummaryCriteriaList { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).CriteriaList; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).CriteriaList = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="AlertTarget" /> property.</summary>
        private Commvault.Powershell.Models.IAlertDefinitionsTarget _alertTarget;

        /// <summary>
        /// Please note CONTENT_INDEX will be returned at all times as it is enabled at all times.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IAlertDefinitionsTarget AlertTarget { get => (this._alertTarget = this._alertTarget ?? new Commvault.Powershell.Models.AlertDefinitionsTarget()); set => this._alertTarget = value; }

        /// <summary>
        /// Allows adding to, overwriting and deleting existing recipients. default is adding to existing recipients
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string AlertTargetRecipientsOperationType { get => ((Commvault.Powershell.Models.IAlertDefinitionsTargetInternal)AlertTarget).RecipientsOperationType; set => ((Commvault.Powershell.Models.IAlertDefinitionsTargetInternal)AlertTarget).RecipientsOperationType = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> AlertTargetSendAlertTo { get => ((Commvault.Powershell.Models.IAlertDefinitionsTargetInternal)AlertTarget).SendAlertTo; set => ((Commvault.Powershell.Models.IAlertDefinitionsTargetInternal)AlertTarget).SendAlertTo = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="Associations" /> property.</summary>
        private System.Collections.Generic.List<Commvault.Powershell.Models.IAlertAssociationIdNameType1> _associations;

        /// <summary>AlertDefinitionsAssociations</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IAlertAssociationIdNameType1> Associations { get => this._associations; set => this._associations = value; }

        /// <summary>id of the category of the alert definition</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? CategoryId { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).CategoryId; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).CategoryId = value ?? default(long); }

        /// <summary>category of the alert definition</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string CategoryName { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).CategoryName; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).CategoryName = value ?? null; }

        /// <summary>Internal Acessors for AdditionalProperties</summary>
        Commvault.Powershell.Models.IAlertAdditionalProperties Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.AdditionalProperties { get => (this._additionalProperties = this._additionalProperties ?? new Commvault.Powershell.Models.AlertAdditionalProperties()); set { {_additionalProperties = value;} } }

        /// <summary>Internal Acessors for AlertSummary</summary>
        Commvault.Powershell.Models.IAlertDetailsSummary Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.AlertSummary { get => (this._alertSummary = this._alertSummary ?? new Commvault.Powershell.Models.AlertDetailsSummary()); set { {_alertSummary = value;} } }

        /// <summary>Internal Acessors for AlertSummaryCategory</summary>
        Commvault.Powershell.Models.IAlertCategoryIdName1 Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.AlertSummaryCategory { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).Category; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).Category = value; }

        /// <summary>Internal Acessors for AlertSummaryCriteria</summary>
        Commvault.Powershell.Models.IAlertCriteriaIdName1 Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.AlertSummaryCriteria { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).Criteria; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).Criteria = value; }

        /// <summary>Internal Acessors for AlertSummaryType</summary>
        Commvault.Powershell.Models.IAlertTypeIdName1 Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.AlertSummaryType { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).Type; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).Type = value; }

        /// <summary>Internal Acessors for AlertTarget</summary>
        Commvault.Powershell.Models.IAlertDefinitionsTarget Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.AlertTarget { get => (this._alertTarget = this._alertTarget ?? new Commvault.Powershell.Models.AlertDefinitionsTarget()); set { {_alertTarget = value;} } }

        /// <summary>Internal Acessors for AlertTargetRecipients</summary>
        Commvault.Powershell.Models.IAlertDefinitionsTargetRecipients Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.AlertTargetRecipients { get => ((Commvault.Powershell.Models.IAlertDefinitionsTargetInternal)AlertTarget).Recipients; set => ((Commvault.Powershell.Models.IAlertDefinitionsTargetInternal)AlertTarget).Recipients = value; }

        /// <summary>Internal Acessors for CriterionNotificationCriteria</summary>
        Commvault.Powershell.Models.INotificationCriteriaOptions Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.CriterionNotificationCriteria { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).CriterionNotificationCriteria; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).CriterionNotificationCriteria = value; }

        /// <summary>Internal Acessors for CustomQueryDetailAdditionalQueryInfo</summary>
        Commvault.Powershell.Models.IQueryAdditionalInfo Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.CustomQueryDetailAdditionalQueryInfo { get => ((Commvault.Powershell.Models.ICustomQueryDetailsInternal)CustomQueryDetails).AdditionalQueryInfo; set => ((Commvault.Powershell.Models.ICustomQueryDetailsInternal)CustomQueryDetails).AdditionalQueryInfo = value; }

        /// <summary>Internal Acessors for CustomQueryDetails</summary>
        Commvault.Powershell.Models.ICustomQueryDetails Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.CustomQueryDetails { get => (this._customQueryDetails = this._customQueryDetails ?? new Commvault.Powershell.Models.CustomQueryDetails()); set { {_customQueryDetails = value;} } }

        /// <summary>Internal Acessors for EventCriteriaDetails</summary>
        Commvault.Powershell.Models.IEventCriteriaDetails Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.EventCriteriaDetails { get => (this._eventCriteriaDetails = this._eventCriteriaDetails ?? new Commvault.Powershell.Models.EventCriteriaDetails()); set { {_eventCriteriaDetails = value;} } }

        /// <summary>Internal Acessors for GlobalConfigInfo</summary>
        Commvault.Powershell.Models.IGlobalConfigInfo Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.GlobalConfigInfo { get => (this._globalConfigInfo = this._globalConfigInfo ?? new Commvault.Powershell.Models.GlobalConfigInfo()); set { {_globalConfigInfo = value;} } }

        /// <summary>Internal Acessors for TemplateLocale</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.TemplateLocale { get => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).Locale; set => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).Locale = value; }

        /// <summary>Internal Acessors for TemplateWorkflow</summary>
        Commvault.Powershell.Models.IWorkflowEntity Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.TemplateWorkflow { get => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).Workflow; set => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).Workflow = value; }

        /// <summary>Internal Acessors for Templates</summary>
        Commvault.Powershell.Models.IAlertDefinitionsTemplate Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.Templates { get => (this._templates = this._templates ?? new Commvault.Powershell.Models.AlertDefinitionsTemplate()); set { {_templates = value;} } }

        /// <summary>Internal Acessors for Tokens</summary>
        Commvault.Powershell.Models.ITokenRuleGroups Commvault.Powershell.Models.IAlertDefinitionsDetailsInternal.Tokens { get => (this._tokens = this._tokens ?? new Commvault.Powershell.Models.TokenRuleGroups()); set { {_tokens = value;} } }

        /// <summary>id of the criteria of detection for the alert definition</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? CriterionId { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).CriterionId; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).CriterionId = value ?? default(long); }

        /// <summary>criteria of detection for the alert definition</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string CriterionName { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).CriterionName; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).CriterionName = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IAlertDefinitionsCriteriaParams> CriterionParamsList { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).CriterionParamsList; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).CriterionParamsList = value ?? null /* arrayOf */; }

        /// <summary>Unique id for the custom alert rule associated with the alert definition</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? CustomQueryDetailQueryId { get => ((Commvault.Powershell.Models.ICustomQueryDetailsInternal)CustomQueryDetails).QueryId; set => ((Commvault.Powershell.Models.ICustomQueryDetailsInternal)CustomQueryDetails).QueryId = value ?? default(long); }

        /// <summary>Backing field for <see cref="CustomQueryDetails" /> property.</summary>
        private Commvault.Powershell.Models.ICustomQueryDetails _customQueryDetails;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.ICustomQueryDetails CustomQueryDetails { get => (this._customQueryDetails = this._customQueryDetails ?? new Commvault.Powershell.Models.CustomQueryDetails()); set => this._customQueryDetails = value; }

        /// <summary>Backing field for <see cref="EventCriteriaDetails" /> property.</summary>
        private Commvault.Powershell.Models.IEventCriteriaDetails _eventCriteriaDetails;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IEventCriteriaDetails EventCriteriaDetails { get => (this._eventCriteriaDetails = this._eventCriteriaDetails ?? new Commvault.Powershell.Models.EventCriteriaDetails()); set => this._eventCriteriaDetails = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IConditionDetails> EventCriterionDetailConditions { get => ((Commvault.Powershell.Models.IEventCriteriaDetailsInternal)EventCriteriaDetails).Conditions; set => ((Commvault.Powershell.Models.IEventCriteriaDetailsInternal)EventCriteriaDetails).Conditions = value ?? null /* arrayOf */; }

        /// <summary>Alert criteria name</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string EventCriterionDetailCriteriaName { get => ((Commvault.Powershell.Models.IEventCriteriaDetailsInternal)EventCriteriaDetails).CriteriaName; set => ((Commvault.Powershell.Models.IEventCriteriaDetailsInternal)EventCriteriaDetails).CriteriaName = value ?? null; }

        /// <summary>Integer value for the operation type between conditions</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? EventCriterionDetailOpBetweenConditions { get => ((Commvault.Powershell.Models.IEventCriteriaDetailsInternal)EventCriteriaDetails).OpBetweenConditions; set => ((Commvault.Powershell.Models.IEventCriteriaDetailsInternal)EventCriteriaDetails).OpBetweenConditions = value ?? default(long); }

        /// <summary>Backing field for <see cref="GlobalConfigInfo" /> property.</summary>
        private Commvault.Powershell.Models.IGlobalConfigInfo _globalConfigInfo;

        /// <summary>Only applicable on Global CommCells</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IGlobalConfigInfo GlobalConfigInfo { get => (this._globalConfigInfo = this._globalConfigInfo ?? new Commvault.Powershell.Models.GlobalConfigInfo()); set => this._globalConfigInfo = value; }

        /// <summary>
        /// Decides whether the global configuration should be applied to all the Service commcells, including the newly created ones
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? GlobalConfigInfoApplyOnAllCommCells { get => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).ApplyOnAllCommCells; set => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).ApplyOnAllCommCells = value ?? default(bool); }

        /// <summary>List of Service CommCells where the global configuration is applied</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IGlobalConfigCommcellInfo> GlobalConfigInfoCommcells { get => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).Commcells; set => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).Commcells = value ?? null /* arrayOf */; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string GlobalConfigInfoId { get => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).Id; set => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).Id = value ?? null; }

        /// <summary>Indicates whether global configuration deletion has been started.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? GlobalConfigInfoIsMarkedForDeletion { get => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).IsMarkedForDeletion; set => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).IsMarkedForDeletion = value ?? default(bool); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string GlobalConfigInfoName { get => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).Name; set => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).Name = value ?? null; }

        /// <summary>The entity level at which the config is applied.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string GlobalConfigInfoScope { get => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).Scope; set => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).Scope = value ?? null; }

        /// <summary>CommCellEntityCache filter query string used for filtering the scope</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string GlobalConfigInfoScopeFilterQuery { get => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).ScopeFilterQuery; set => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).ScopeFilterQuery = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string GlobalConfigInfoStatus { get => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).Status; set => ((Commvault.Powershell.Models.IGlobalConfigInfoInternal)GlobalConfigInfo).Status = value ?? null; }

        /// <summary>Backing field for <see cref="Id" /> property.</summary>
        private long? _id;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public long? Id { get => this._id; set => this._id = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? LocaleId { get => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).LocaleId; set => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).LocaleId = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string LocaleName { get => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).LocaleName; set => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).LocaleName = value ?? null; }

        /// <summary>Backing field for <see cref="Name" /> property.</summary>
        private string _name;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string Name { get => this._name; set => this._name = value; }

        /// <summary>
        /// Delayed time in seconds when the notification criteria value contains delayed flag
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? NotificationCriterionDelayTime { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).NotificationCriterionDelayTime; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).NotificationCriterionDelayTime = value ?? default(long); }

        /// <summary>
        /// Persisting time in seconds when the notification criteria value contains repeated flag
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? NotificationCriterionPersistTime { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).NotificationCriterionPersistTime; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).NotificationCriterionPersistTime = value ?? default(long); }

        /// <summary>
        /// Bit flag indicating notification criteria value. 1 means immediate, 2 means repeated and 8 means delayed
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? NotificationCriterionValue { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).NotificationCriterionValue; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).NotificationCriterionValue = value ?? default(long); }

        /// <summary>Backing field for <see cref="ProcessDiscoveredVMS" /> property.</summary>
        private bool? _processDiscoveredVMS;

        /// <summary>
        /// True if individual notifications for each discovered virtual machine are enabled for the alert definition
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public bool? ProcessDiscoveredVMS { get => this._processDiscoveredVMS; set => this._processDiscoveredVMS = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IAlertTargetIdNameType1> RecipientBcc { get => ((Commvault.Powershell.Models.IAlertDefinitionsTargetInternal)AlertTarget).RecipientBcc; set => ((Commvault.Powershell.Models.IAlertDefinitionsTargetInternal)AlertTarget).RecipientBcc = value ?? null /* arrayOf */; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IAlertTargetIdNameType1> RecipientCc { get => ((Commvault.Powershell.Models.IAlertDefinitionsTargetInternal)AlertTarget).RecipientCc; set => ((Commvault.Powershell.Models.IAlertDefinitionsTargetInternal)AlertTarget).RecipientCc = value ?? null /* arrayOf */; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IAlertTargetIdNameType1> RecipientTo { get => ((Commvault.Powershell.Models.IAlertDefinitionsTargetInternal)AlertTarget).RecipientTo; set => ((Commvault.Powershell.Models.IAlertDefinitionsTargetInternal)AlertTarget).RecipientTo = value ?? null /* arrayOf */; }

        /// <summary>
        /// id of the webhook to be associated with the alert definition. Only needed incase of webhook notif selected. To get a list
        /// of webhooks, use api GET Webhook
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? RecipientWebHookId { get => ((Commvault.Powershell.Models.IAlertDefinitionsTargetInternal)AlertTarget).RecipientWebHookId; set => ((Commvault.Powershell.Models.IAlertDefinitionsTargetInternal)AlertTarget).RecipientWebHookId = value ?? default(long); }

        /// <summary>Backing field for <see cref="SendIndividualNotifications" /> property.</summary>
        private bool? _sendIndividualNotifications;

        /// <summary>true if individual notifications are on for the alert definitions</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public bool? SendIndividualNotifications { get => this._sendIndividualNotifications; set => this._sendIndividualNotifications = value; }

        /// <summary>Backing field for <see cref="SubscriptionBasedAlert" /> property.</summary>
        private bool? _subscriptionBasedAlert;

        /// <summary>Flag to indicate whether its a subscription based alert.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public bool? SubscriptionBasedAlert { get => this._subscriptionBasedAlert; set => this._subscriptionBasedAlert = value; }

        /// <summary>the message template for the console notification</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string TemplateConsole { get => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).Console; set => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).Console = value ?? null; }

        /// <summary>
        /// the message template for the email notification. Contains both email subject as well as body
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string TemplateEmail { get => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).Email; set => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).Email = value ?? null; }

        /// <summary>the message template for the event viewer notification</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string TemplateEventViewer { get => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).EventViewer; set => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).EventViewer = value ?? null; }

        /// <summary>the message template for the webhook notification</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string TemplateWebhook { get => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).Webhook; set => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).Webhook = value ?? null; }

        /// <summary>
        /// the template for the workflow input entries values (empty value means the configured workflow does not need any inputs
        /// value)
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string TemplateWorkflowInputDetails { get => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).WorkflowInputDetails; set => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).WorkflowInputDetails = value ?? null; }

        /// <summary>Backing field for <see cref="Templates" /> property.</summary>
        private Commvault.Powershell.Models.IAlertDefinitionsTemplate _templates;

        /// <summary>AlertDefinitionsTemplate</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IAlertDefinitionsTemplate Templates { get => (this._templates = this._templates ?? new Commvault.Powershell.Models.AlertDefinitionsTemplate()); set => this._templates = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string TokenMatch { get => ((Commvault.Powershell.Models.ITokenRuleGroupsInternal)Tokens).Match; set => ((Commvault.Powershell.Models.ITokenRuleGroupsInternal)Tokens).Match = value ?? null; }

        /// <summary>List of rule groups</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.ITokenRuleGroup> TokenRuleGroups { get => ((Commvault.Powershell.Models.ITokenRuleGroupsInternal)Tokens).RuleGroups; set => ((Commvault.Powershell.Models.ITokenRuleGroupsInternal)Tokens).RuleGroups = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="Tokens" /> property.</summary>
        private Commvault.Powershell.Models.ITokenRuleGroups _tokens;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.ITokenRuleGroups Tokens { get => (this._tokens = this._tokens ?? new Commvault.Powershell.Models.TokenRuleGroups()); set => this._tokens = value; }

        /// <summary>id of the alert definition</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? TypeId { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).TypeId; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).TypeId = value ?? default(long); }

        /// <summary>type of the alert definitions</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string TypeName { get => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).TypeName; set => ((Commvault.Powershell.Models.IAlertDetailsSummaryInternal)AlertSummary).TypeName = value ?? null; }

        /// <summary>
        /// id of the client on which the workflow runs (zero value means it can run on any workflow engine)
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? WorkflowClientId { get => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).WorkflowClientId; set => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).WorkflowClientId = value ?? default(long); }

        /// <summary>
        /// name of the client on which the workflow runs (empty value means it can run on any workflow engine)
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string WorkflowClientName { get => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).WorkflowClientName; set => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).WorkflowClientName = value ?? null; }

        /// <summary>id of the workflow which runs when the alert is triggered</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? WorkflowId { get => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).WorkflowId; set => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).WorkflowId = value ?? default(long); }

        /// <summary>name of the workflow which runs when the alert is triggered</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string WorkflowName { get => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).WorkflowName; set => ((Commvault.Powershell.Models.IAlertDefinitionsTemplateInternal)Templates).WorkflowName = value ?? null; }

        /// <summary>Creates an new <see cref="AlertDefinitionsDetails" /> instance.</summary>
        public AlertDefinitionsDetails()
        {

        }
    }
    /// AlertDefinitionsDetails
    public partial interface IAlertDefinitionsDetails :
        Commvault.Powershell.Runtime.IJsonSerializable
    {
        /// <summary>Tells status of alert. Can be used to find if alert is enabled or not.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Tells status of alert. Can be used to find if alert is enabled or not.",
        SerializedName = @"status",
        PossibleTypes = new [] { typeof(long) })]
        long? AdditionalPropertyStatus { get; set; }
        /// <summary>List of query parameters</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"List of query parameters",
        SerializedName = @"queryParameters",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IQueryParameter) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IQueryParameter> AdditionalQueryInfoQueryParameters { get; set; }
        /// <summary>List of alert criteria</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"List of alert criteria",
        SerializedName = @"criteriaList",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IAlertCriteriaIdName1) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IAlertCriteriaIdName1> AlertSummaryCriteriaList { get; set; }
        /// <summary>
        /// Allows adding to, overwriting and deleting existing recipients. default is adding to existing recipients
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Allows adding to, overwriting and deleting existing recipients. default is adding to existing recipients",
        SerializedName = @"recipientsOperationType",
        PossibleTypes = new [] { typeof(string) })]
        string AlertTargetRecipientsOperationType { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"sendAlertTo",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> AlertTargetSendAlertTo { get; set; }
        /// <summary>AlertDefinitionsAssociations</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"AlertDefinitionsAssociations",
        SerializedName = @"associations",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IAlertAssociationIdNameType1) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IAlertAssociationIdNameType1> Associations { get; set; }
        /// <summary>id of the category of the alert definition</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"id of the category of the alert definition",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? CategoryId { get; set; }
        /// <summary>category of the alert definition</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"category of the alert definition",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string CategoryName { get; set; }
        /// <summary>id of the criteria of detection for the alert definition</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"id of the criteria of detection for the alert definition",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? CriterionId { get; set; }
        /// <summary>criteria of detection for the alert definition</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"criteria of detection for the alert definition",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string CriterionName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"paramsList",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IAlertDefinitionsCriteriaParams) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IAlertDefinitionsCriteriaParams> CriterionParamsList { get; set; }
        /// <summary>Unique id for the custom alert rule associated with the alert definition</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Unique id for the custom alert rule associated with the alert definition",
        SerializedName = @"queryId",
        PossibleTypes = new [] { typeof(long) })]
        long? CustomQueryDetailQueryId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"conditions",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IConditionDetails) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IConditionDetails> EventCriterionDetailConditions { get; set; }
        /// <summary>Alert criteria name</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Alert criteria name",
        SerializedName = @"criteriaName",
        PossibleTypes = new [] { typeof(string) })]
        string EventCriterionDetailCriteriaName { get; set; }
        /// <summary>Integer value for the operation type between conditions</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Integer value for the operation type between conditions",
        SerializedName = @"opBetweenConditions",
        PossibleTypes = new [] { typeof(long) })]
        long? EventCriterionDetailOpBetweenConditions { get; set; }
        /// <summary>
        /// Decides whether the global configuration should be applied to all the Service commcells, including the newly created ones
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Decides whether the global configuration should be applied to all the Service commcells, including the newly created ones",
        SerializedName = @"applyOnAllCommCells",
        PossibleTypes = new [] { typeof(bool) })]
        bool? GlobalConfigInfoApplyOnAllCommCells { get; set; }
        /// <summary>List of Service CommCells where the global configuration is applied</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"List of Service CommCells where the global configuration is applied",
        SerializedName = @"commcells",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IGlobalConfigCommcellInfo) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IGlobalConfigCommcellInfo> GlobalConfigInfoCommcells { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string GlobalConfigInfoId { get; set; }
        /// <summary>Indicates whether global configuration deletion has been started.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Indicates whether global configuration deletion has been started.",
        SerializedName = @"isMarkedForDeletion",
        PossibleTypes = new [] { typeof(bool) })]
        bool? GlobalConfigInfoIsMarkedForDeletion { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string GlobalConfigInfoName { get; set; }
        /// <summary>The entity level at which the config is applied.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The entity level at which the config is applied.",
        SerializedName = @"scope",
        PossibleTypes = new [] { typeof(string) })]
        string GlobalConfigInfoScope { get; set; }
        /// <summary>CommCellEntityCache filter query string used for filtering the scope</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"CommCellEntityCache filter query string used for filtering the scope",
        SerializedName = @"scopeFilterQuery",
        PossibleTypes = new [] { typeof(string) })]
        string GlobalConfigInfoScopeFilterQuery { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"status",
        PossibleTypes = new [] { typeof(string) })]
        string GlobalConfigInfoStatus { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? Id { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? LocaleId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string LocaleName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string Name { get; set; }
        /// <summary>
        /// Delayed time in seconds when the notification criteria value contains delayed flag
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Delayed time in seconds when the notification criteria value contains delayed flag",
        SerializedName = @"delayTime",
        PossibleTypes = new [] { typeof(long) })]
        long? NotificationCriterionDelayTime { get; set; }
        /// <summary>
        /// Persisting time in seconds when the notification criteria value contains repeated flag
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Persisting time in seconds when the notification criteria value contains repeated flag",
        SerializedName = @"persistTime",
        PossibleTypes = new [] { typeof(long) })]
        long? NotificationCriterionPersistTime { get; set; }
        /// <summary>
        /// Bit flag indicating notification criteria value. 1 means immediate, 2 means repeated and 8 means delayed
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Bit flag indicating notification criteria value. 1 means immediate, 2 means repeated and 8 means delayed",
        SerializedName = @"value",
        PossibleTypes = new [] { typeof(long) })]
        long? NotificationCriterionValue { get; set; }
        /// <summary>
        /// True if individual notifications for each discovered virtual machine are enabled for the alert definition
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if individual notifications for each discovered virtual machine are enabled for the alert definition",
        SerializedName = @"processDiscoveredVMs",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ProcessDiscoveredVMS { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"bcc",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IAlertTargetIdNameType1) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IAlertTargetIdNameType1> RecipientBcc { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"cc",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IAlertTargetIdNameType1) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IAlertTargetIdNameType1> RecipientCc { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"to",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IAlertTargetIdNameType1) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IAlertTargetIdNameType1> RecipientTo { get; set; }
        /// <summary>
        /// id of the webhook to be associated with the alert definition. Only needed incase of webhook notif selected. To get a list
        /// of webhooks, use api GET Webhook
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"id of the webhook to be associated with the alert definition. Only needed incase of webhook notif selected. To get a list of webhooks, use api GET Webhook",
        SerializedName = @"webHookId",
        PossibleTypes = new [] { typeof(long) })]
        long? RecipientWebHookId { get; set; }
        /// <summary>true if individual notifications are on for the alert definitions</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"true if individual notifications are on for the alert definitions",
        SerializedName = @"sendIndividualNotifications",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SendIndividualNotifications { get; set; }
        /// <summary>Flag to indicate whether its a subscription based alert.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Flag to indicate whether its a subscription based alert.",
        SerializedName = @"subscriptionBasedAlert",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SubscriptionBasedAlert { get; set; }
        /// <summary>the message template for the console notification</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"the message template for the console notification",
        SerializedName = @"console",
        PossibleTypes = new [] { typeof(string) })]
        string TemplateConsole { get; set; }
        /// <summary>
        /// the message template for the email notification. Contains both email subject as well as body
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"the message template for the email notification. Contains both email subject as well as body",
        SerializedName = @"email",
        PossibleTypes = new [] { typeof(string) })]
        string TemplateEmail { get; set; }
        /// <summary>the message template for the event viewer notification</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"the message template for the event viewer notification",
        SerializedName = @"eventViewer",
        PossibleTypes = new [] { typeof(string) })]
        string TemplateEventViewer { get; set; }
        /// <summary>the message template for the webhook notification</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"the message template for the webhook notification",
        SerializedName = @"webhook",
        PossibleTypes = new [] { typeof(string) })]
        string TemplateWebhook { get; set; }
        /// <summary>
        /// the template for the workflow input entries values (empty value means the configured workflow does not need any inputs
        /// value)
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"the template for the workflow input entries values (empty value means the configured workflow does not need any inputs value)",
        SerializedName = @"workflowInputDetails",
        PossibleTypes = new [] { typeof(string) })]
        string TemplateWorkflowInputDetails { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"match",
        PossibleTypes = new [] { typeof(string) })]
        string TokenMatch { get; set; }
        /// <summary>List of rule groups</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"List of rule groups",
        SerializedName = @"ruleGroups",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.ITokenRuleGroup) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.ITokenRuleGroup> TokenRuleGroups { get; set; }
        /// <summary>id of the alert definition</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"id of the alert definition",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? TypeId { get; set; }
        /// <summary>type of the alert definitions</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"type of the alert definitions",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string TypeName { get; set; }
        /// <summary>
        /// id of the client on which the workflow runs (zero value means it can run on any workflow engine)
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"id of the client on which the workflow runs (zero value means it can run on any workflow engine)",
        SerializedName = @"clientId",
        PossibleTypes = new [] { typeof(long) })]
        long? WorkflowClientId { get; set; }
        /// <summary>
        /// name of the client on which the workflow runs (empty value means it can run on any workflow engine)
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"name of the client on which the workflow runs (empty value means it can run on any workflow engine)",
        SerializedName = @"clientName",
        PossibleTypes = new [] { typeof(string) })]
        string WorkflowClientName { get; set; }
        /// <summary>id of the workflow which runs when the alert is triggered</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"id of the workflow which runs when the alert is triggered",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? WorkflowId { get; set; }
        /// <summary>name of the workflow which runs when the alert is triggered</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"name of the workflow which runs when the alert is triggered",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string WorkflowName { get; set; }

    }
    /// AlertDefinitionsDetails
    internal partial interface IAlertDefinitionsDetailsInternal

    {
        Commvault.Powershell.Models.IAlertAdditionalProperties AdditionalProperties { get; set; }
        /// <summary>Tells status of alert. Can be used to find if alert is enabled or not.</summary>
        long? AdditionalPropertyStatus { get; set; }
        /// <summary>List of query parameters</summary>
        System.Collections.Generic.List<Commvault.Powershell.Models.IQueryParameter> AdditionalQueryInfoQueryParameters { get; set; }
        /// <summary>AlertDetailsSummary</summary>
        Commvault.Powershell.Models.IAlertDetailsSummary AlertSummary { get; set; }

        Commvault.Powershell.Models.IAlertCategoryIdName1 AlertSummaryCategory { get; set; }

        Commvault.Powershell.Models.IAlertCriteriaIdName1 AlertSummaryCriteria { get; set; }
        /// <summary>List of alert criteria</summary>
        System.Collections.Generic.List<Commvault.Powershell.Models.IAlertCriteriaIdName1> AlertSummaryCriteriaList { get; set; }

        Commvault.Powershell.Models.IAlertTypeIdName1 AlertSummaryType { get; set; }
        /// <summary>
        /// Please note CONTENT_INDEX will be returned at all times as it is enabled at all times.
        /// </summary>
        Commvault.Powershell.Models.IAlertDefinitionsTarget AlertTarget { get; set; }
        /// <summary>AlertDefinitionsTargetRecipients</summary>
        Commvault.Powershell.Models.IAlertDefinitionsTargetRecipients AlertTargetRecipients { get; set; }
        /// <summary>
        /// Allows adding to, overwriting and deleting existing recipients. default is adding to existing recipients
        /// </summary>
        string AlertTargetRecipientsOperationType { get; set; }

        System.Collections.Generic.List<string> AlertTargetSendAlertTo { get; set; }
        /// <summary>AlertDefinitionsAssociations</summary>
        System.Collections.Generic.List<Commvault.Powershell.Models.IAlertAssociationIdNameType1> Associations { get; set; }
        /// <summary>id of the category of the alert definition</summary>
        long? CategoryId { get; set; }
        /// <summary>category of the alert definition</summary>
        string CategoryName { get; set; }
        /// <summary>id of the criteria of detection for the alert definition</summary>
        long? CriterionId { get; set; }
        /// <summary>criteria of detection for the alert definition</summary>
        string CriterionName { get; set; }
        /// <summary>NotificationCriteriaOptions</summary>
        Commvault.Powershell.Models.INotificationCriteriaOptions CriterionNotificationCriteria { get; set; }

        System.Collections.Generic.List<Commvault.Powershell.Models.IAlertDefinitionsCriteriaParams> CriterionParamsList { get; set; }

        Commvault.Powershell.Models.IQueryAdditionalInfo CustomQueryDetailAdditionalQueryInfo { get; set; }
        /// <summary>Unique id for the custom alert rule associated with the alert definition</summary>
        long? CustomQueryDetailQueryId { get; set; }

        Commvault.Powershell.Models.ICustomQueryDetails CustomQueryDetails { get; set; }

        Commvault.Powershell.Models.IEventCriteriaDetails EventCriteriaDetails { get; set; }

        System.Collections.Generic.List<Commvault.Powershell.Models.IConditionDetails> EventCriterionDetailConditions { get; set; }
        /// <summary>Alert criteria name</summary>
        string EventCriterionDetailCriteriaName { get; set; }
        /// <summary>Integer value for the operation type between conditions</summary>
        long? EventCriterionDetailOpBetweenConditions { get; set; }
        /// <summary>Only applicable on Global CommCells</summary>
        Commvault.Powershell.Models.IGlobalConfigInfo GlobalConfigInfo { get; set; }
        /// <summary>
        /// Decides whether the global configuration should be applied to all the Service commcells, including the newly created ones
        /// </summary>
        bool? GlobalConfigInfoApplyOnAllCommCells { get; set; }
        /// <summary>List of Service CommCells where the global configuration is applied</summary>
        System.Collections.Generic.List<Commvault.Powershell.Models.IGlobalConfigCommcellInfo> GlobalConfigInfoCommcells { get; set; }

        string GlobalConfigInfoId { get; set; }
        /// <summary>Indicates whether global configuration deletion has been started.</summary>
        bool? GlobalConfigInfoIsMarkedForDeletion { get; set; }

        string GlobalConfigInfoName { get; set; }
        /// <summary>The entity level at which the config is applied.</summary>
        string GlobalConfigInfoScope { get; set; }
        /// <summary>CommCellEntityCache filter query string used for filtering the scope</summary>
        string GlobalConfigInfoScopeFilterQuery { get; set; }

        string GlobalConfigInfoStatus { get; set; }

        long? Id { get; set; }

        long? LocaleId { get; set; }

        string LocaleName { get; set; }

        string Name { get; set; }
        /// <summary>
        /// Delayed time in seconds when the notification criteria value contains delayed flag
        /// </summary>
        long? NotificationCriterionDelayTime { get; set; }
        /// <summary>
        /// Persisting time in seconds when the notification criteria value contains repeated flag
        /// </summary>
        long? NotificationCriterionPersistTime { get; set; }
        /// <summary>
        /// Bit flag indicating notification criteria value. 1 means immediate, 2 means repeated and 8 means delayed
        /// </summary>
        long? NotificationCriterionValue { get; set; }
        /// <summary>
        /// True if individual notifications for each discovered virtual machine are enabled for the alert definition
        /// </summary>
        bool? ProcessDiscoveredVMS { get; set; }

        System.Collections.Generic.List<Commvault.Powershell.Models.IAlertTargetIdNameType1> RecipientBcc { get; set; }

        System.Collections.Generic.List<Commvault.Powershell.Models.IAlertTargetIdNameType1> RecipientCc { get; set; }

        System.Collections.Generic.List<Commvault.Powershell.Models.IAlertTargetIdNameType1> RecipientTo { get; set; }
        /// <summary>
        /// id of the webhook to be associated with the alert definition. Only needed incase of webhook notif selected. To get a list
        /// of webhooks, use api GET Webhook
        /// </summary>
        long? RecipientWebHookId { get; set; }
        /// <summary>true if individual notifications are on for the alert definitions</summary>
        bool? SendIndividualNotifications { get; set; }
        /// <summary>Flag to indicate whether its a subscription based alert.</summary>
        bool? SubscriptionBasedAlert { get; set; }
        /// <summary>the message template for the console notification</summary>
        string TemplateConsole { get; set; }
        /// <summary>
        /// the message template for the email notification. Contains both email subject as well as body
        /// </summary>
        string TemplateEmail { get; set; }
        /// <summary>the message template for the event viewer notification</summary>
        string TemplateEventViewer { get; set; }

        Commvault.Powershell.Models.IIdName TemplateLocale { get; set; }
        /// <summary>the message template for the webhook notification</summary>
        string TemplateWebhook { get; set; }
        /// <summary>WorkflowEntity</summary>
        Commvault.Powershell.Models.IWorkflowEntity TemplateWorkflow { get; set; }
        /// <summary>
        /// the template for the workflow input entries values (empty value means the configured workflow does not need any inputs
        /// value)
        /// </summary>
        string TemplateWorkflowInputDetails { get; set; }
        /// <summary>AlertDefinitionsTemplate</summary>
        Commvault.Powershell.Models.IAlertDefinitionsTemplate Templates { get; set; }

        string TokenMatch { get; set; }
        /// <summary>List of rule groups</summary>
        System.Collections.Generic.List<Commvault.Powershell.Models.ITokenRuleGroup> TokenRuleGroups { get; set; }

        Commvault.Powershell.Models.ITokenRuleGroups Tokens { get; set; }
        /// <summary>id of the alert definition</summary>
        long? TypeId { get; set; }
        /// <summary>type of the alert definitions</summary>
        string TypeName { get; set; }
        /// <summary>
        /// id of the client on which the workflow runs (zero value means it can run on any workflow engine)
        /// </summary>
        long? WorkflowClientId { get; set; }
        /// <summary>
        /// name of the client on which the workflow runs (empty value means it can run on any workflow engine)
        /// </summary>
        string WorkflowClientName { get; set; }
        /// <summary>id of the workflow which runs when the alert is triggered</summary>
        long? WorkflowId { get; set; }
        /// <summary>name of the workflow which runs when the alert is triggered</summary>
        string WorkflowName { get; set; }

    }
}