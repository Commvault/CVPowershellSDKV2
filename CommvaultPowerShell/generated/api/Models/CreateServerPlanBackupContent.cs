// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.2, generator: @autorest/powershell@4.0.708)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Commvault.Powershell.Models
{
    using static Commvault.Powershell.Runtime.Extensions;

    public partial class CreateServerPlanBackupContent :
        Commvault.Powershell.Models.ICreateServerPlanBackupContent,
        Commvault.Powershell.Models.ICreateServerPlanBackupContentInternal
    {

        /// <summary>Backing field for <see cref="BackupContent" /> property.</summary>
        private Commvault.Powershell.Models.IPlanContent _backupContent;

        /// <summary>This feature applies only to file system agents</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IPlanContent BackupContent { get => (this._backupContent = this._backupContent ?? new Commvault.Powershell.Models.PlanContent()); set => this._backupContent = value; }

        /// <summary>Do you want to back up the system state? Applicable only for Windows</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? BackupContentBackupSystemState { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).BackupSystemState; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).BackupSystemState = value ?? default(bool); }

        /// <summary>
        /// Do you want to back up system state only with full backup? Applicable only if the value of backupSystemState is true
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? BackupContentBackupSystemStateOnlyWithFullBackup { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).BackupSystemStateOnlyWithFullBackup; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).BackupSystemStateOnlyWithFullBackup = value ?? default(bool); }

        /// <summary>
        /// Do you want to sync properties on associated subclients even if properties are overriden at subclient level?
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? BackupContentForceUpdateProperties { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).ForceUpdateProperties; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).ForceUpdateProperties = value ?? default(bool); }

        /// <summary>Paths to exclude for Mac</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> BackupContentMacExcludedPaths { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).MacExcludedPaths; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).MacExcludedPaths = value ?? null /* arrayOf */; }

        /// <summary>Paths that are exception to excluded paths for Mac</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> BackupContentMacFilterToExcludePaths { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).MacFilterToExcludePaths; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).MacFilterToExcludePaths = value ?? null /* arrayOf */; }

        /// <summary>Paths to include for Mac</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> BackupContentMacIncludedPaths { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).MacIncludedPaths; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).MacIncludedPaths = value ?? null /* arrayOf */; }

        /// <summary>Paths to exclude for UNIX</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> BackupContentUnixExcludedPaths { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).UnixExcludedPaths; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).UnixExcludedPaths = value ?? null /* arrayOf */; }

        /// <summary>Paths that are exception to excluded paths for Unix</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> BackupContentUnixFilterToExcludePaths { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).UnixFilterToExcludePaths; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).UnixFilterToExcludePaths = value ?? null /* arrayOf */; }

        /// <summary>Paths to include for UNIX</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> BackupContentUnixIncludedPaths { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).UnixIncludedPaths; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).UnixIncludedPaths = value ?? null /* arrayOf */; }

        /// <summary>
        /// Do you want to back up system state with VSS? Applicable only if the value of backupSystemState is true
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? BackupContentUseVssForSystemState { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).UseVssForSystemState; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).UseVssForSystemState = value ?? default(bool); }

        /// <summary>Paths to exclude for Windows</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> BackupContentWindowsExcludedPaths { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).WindowsExcludedPaths; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).WindowsExcludedPaths = value ?? null /* arrayOf */; }

        /// <summary>Paths that are exception to excluded paths for Windows</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> BackupContentWindowsFilterToExcludePaths { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).WindowsFilterToExcludePaths; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).WindowsFilterToExcludePaths = value ?? null /* arrayOf */; }

        /// <summary>Paths to include for Windows</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> BackupContentWindowsIncludedPaths { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).WindowsIncludedPaths; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).WindowsIncludedPaths = value ?? null /* arrayOf */; }

        /// <summary>Internal Acessors for BackupContent</summary>
        Commvault.Powershell.Models.IPlanContent Commvault.Powershell.Models.ICreateServerPlanBackupContentInternal.BackupContent { get => (this._backupContent = this._backupContent ?? new Commvault.Powershell.Models.PlanContent()); set { {_backupContent = value;} } }

        /// <summary>Internal Acessors for BackupContentMacNumberOfDataReaders</summary>
        Commvault.Powershell.Models.IPlanContentDataReaders Commvault.Powershell.Models.ICreateServerPlanBackupContentInternal.BackupContentMacNumberOfDataReaders { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).MacNumberOfDataReaders; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).MacNumberOfDataReaders = value; }

        /// <summary>Internal Acessors for BackupContentUnixNumberOfDataReaders</summary>
        Commvault.Powershell.Models.IPlanContentDataReaders Commvault.Powershell.Models.ICreateServerPlanBackupContentInternal.BackupContentUnixNumberOfDataReaders { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).UnixNumberOfDataReaders; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).UnixNumberOfDataReaders = value; }

        /// <summary>Internal Acessors for BackupContentWindowsNumberOfDataReaders</summary>
        Commvault.Powershell.Models.IPlanContentDataReaders Commvault.Powershell.Models.ICreateServerPlanBackupContentInternal.BackupContentWindowsNumberOfDataReaders { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).WindowsNumberOfDataReaders; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).WindowsNumberOfDataReaders = value; }

        /// <summary>Number of data readers.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? MacNumberOfDataReaderCount { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).MacNumberOfDataReaderCount; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).MacNumberOfDataReaderCount = value ?? default(long); }

        /// <summary>
        /// Set optimal number of data readers. if it is set to true, count will be ignored.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? MacNumberOfDataReaderUseOptimal { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).MacNumberOfDataReaderUseOptimal; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).MacNumberOfDataReaderUseOptimal = value ?? default(bool); }

        /// <summary>Number of data readers.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? UnixNumberOfDataReaderCount { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).UnixNumberOfDataReaderCount; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).UnixNumberOfDataReaderCount = value ?? default(long); }

        /// <summary>
        /// Set optimal number of data readers. if it is set to true, count will be ignored.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? UnixNumberOfDataReaderUseOptimal { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).UnixNumberOfDataReaderUseOptimal; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).UnixNumberOfDataReaderUseOptimal = value ?? default(bool); }

        /// <summary>Number of data readers.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? WindowNumberOfDataReaderCount { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).WindowNumberOfDataReaderCount; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).WindowNumberOfDataReaderCount = value ?? default(long); }

        /// <summary>
        /// Set optimal number of data readers. if it is set to true, count will be ignored.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? WindowNumberOfDataReaderUseOptimal { get => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).WindowNumberOfDataReaderUseOptimal; set => ((Commvault.Powershell.Models.IPlanContentInternal)BackupContent).WindowNumberOfDataReaderUseOptimal = value ?? default(bool); }

        /// <summary>Creates an new <see cref="CreateServerPlanBackupContent" /> instance.</summary>
        public CreateServerPlanBackupContent()
        {

        }
    }
    public partial interface ICreateServerPlanBackupContent :
        Commvault.Powershell.Runtime.IJsonSerializable
    {
        /// <summary>Do you want to back up the system state? Applicable only for Windows</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Do you want to back up the system state? Applicable only for Windows",
        SerializedName = @"backupSystemState",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BackupContentBackupSystemState { get; set; }
        /// <summary>
        /// Do you want to back up system state only with full backup? Applicable only if the value of backupSystemState is true
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Do you want to back up system state only with full backup? Applicable only if the value of backupSystemState is true",
        SerializedName = @"backupSystemStateOnlyWithFullBackup",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BackupContentBackupSystemStateOnlyWithFullBackup { get; set; }
        /// <summary>
        /// Do you want to sync properties on associated subclients even if properties are overriden at subclient level?
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Do you want to sync properties on associated subclients even if properties are overriden at subclient level?",
        SerializedName = @"forceUpdateProperties",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BackupContentForceUpdateProperties { get; set; }
        /// <summary>Paths to exclude for Mac</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Paths to exclude for Mac",
        SerializedName = @"macExcludedPaths",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> BackupContentMacExcludedPaths { get; set; }
        /// <summary>Paths that are exception to excluded paths for Mac</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Paths that are exception to excluded paths for Mac",
        SerializedName = @"macFilterToExcludePaths",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> BackupContentMacFilterToExcludePaths { get; set; }
        /// <summary>Paths to include for Mac</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Paths to include for Mac",
        SerializedName = @"macIncludedPaths",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> BackupContentMacIncludedPaths { get; set; }
        /// <summary>Paths to exclude for UNIX</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Paths to exclude for UNIX",
        SerializedName = @"unixExcludedPaths",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> BackupContentUnixExcludedPaths { get; set; }
        /// <summary>Paths that are exception to excluded paths for Unix</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Paths that are exception to excluded paths for Unix",
        SerializedName = @"unixFilterToExcludePaths",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> BackupContentUnixFilterToExcludePaths { get; set; }
        /// <summary>Paths to include for UNIX</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Paths to include for UNIX",
        SerializedName = @"unixIncludedPaths",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> BackupContentUnixIncludedPaths { get; set; }
        /// <summary>
        /// Do you want to back up system state with VSS? Applicable only if the value of backupSystemState is true
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Do you want to back up system state with VSS? Applicable only if the value of backupSystemState is true",
        SerializedName = @"useVSSForSystemState",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BackupContentUseVssForSystemState { get; set; }
        /// <summary>Paths to exclude for Windows</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Paths to exclude for Windows",
        SerializedName = @"windowsExcludedPaths",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> BackupContentWindowsExcludedPaths { get; set; }
        /// <summary>Paths that are exception to excluded paths for Windows</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Paths that are exception to excluded paths for Windows",
        SerializedName = @"windowsFilterToExcludePaths",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> BackupContentWindowsFilterToExcludePaths { get; set; }
        /// <summary>Paths to include for Windows</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Paths to include for Windows",
        SerializedName = @"windowsIncludedPaths",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> BackupContentWindowsIncludedPaths { get; set; }
        /// <summary>Number of data readers.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Number of data readers.",
        SerializedName = @"count",
        PossibleTypes = new [] { typeof(long) })]
        long? MacNumberOfDataReaderCount { get; set; }
        /// <summary>
        /// Set optimal number of data readers. if it is set to true, count will be ignored.
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Set optimal number of data readers. if it is set to true, count will be ignored.",
        SerializedName = @"useOptimal",
        PossibleTypes = new [] { typeof(bool) })]
        bool? MacNumberOfDataReaderUseOptimal { get; set; }
        /// <summary>Number of data readers.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Number of data readers.",
        SerializedName = @"count",
        PossibleTypes = new [] { typeof(long) })]
        long? UnixNumberOfDataReaderCount { get; set; }
        /// <summary>
        /// Set optimal number of data readers. if it is set to true, count will be ignored.
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Set optimal number of data readers. if it is set to true, count will be ignored.",
        SerializedName = @"useOptimal",
        PossibleTypes = new [] { typeof(bool) })]
        bool? UnixNumberOfDataReaderUseOptimal { get; set; }
        /// <summary>Number of data readers.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Number of data readers.",
        SerializedName = @"count",
        PossibleTypes = new [] { typeof(long) })]
        long? WindowNumberOfDataReaderCount { get; set; }
        /// <summary>
        /// Set optimal number of data readers. if it is set to true, count will be ignored.
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Set optimal number of data readers. if it is set to true, count will be ignored.",
        SerializedName = @"useOptimal",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WindowNumberOfDataReaderUseOptimal { get; set; }

    }
    internal partial interface ICreateServerPlanBackupContentInternal

    {
        /// <summary>This feature applies only to file system agents</summary>
        Commvault.Powershell.Models.IPlanContent BackupContent { get; set; }
        /// <summary>Do you want to back up the system state? Applicable only for Windows</summary>
        bool? BackupContentBackupSystemState { get; set; }
        /// <summary>
        /// Do you want to back up system state only with full backup? Applicable only if the value of backupSystemState is true
        /// </summary>
        bool? BackupContentBackupSystemStateOnlyWithFullBackup { get; set; }
        /// <summary>
        /// Do you want to sync properties on associated subclients even if properties are overriden at subclient level?
        /// </summary>
        bool? BackupContentForceUpdateProperties { get; set; }
        /// <summary>Paths to exclude for Mac</summary>
        System.Collections.Generic.List<string> BackupContentMacExcludedPaths { get; set; }
        /// <summary>Paths that are exception to excluded paths for Mac</summary>
        System.Collections.Generic.List<string> BackupContentMacFilterToExcludePaths { get; set; }
        /// <summary>Paths to include for Mac</summary>
        System.Collections.Generic.List<string> BackupContentMacIncludedPaths { get; set; }

        Commvault.Powershell.Models.IPlanContentDataReaders BackupContentMacNumberOfDataReaders { get; set; }
        /// <summary>Paths to exclude for UNIX</summary>
        System.Collections.Generic.List<string> BackupContentUnixExcludedPaths { get; set; }
        /// <summary>Paths that are exception to excluded paths for Unix</summary>
        System.Collections.Generic.List<string> BackupContentUnixFilterToExcludePaths { get; set; }
        /// <summary>Paths to include for UNIX</summary>
        System.Collections.Generic.List<string> BackupContentUnixIncludedPaths { get; set; }

        Commvault.Powershell.Models.IPlanContentDataReaders BackupContentUnixNumberOfDataReaders { get; set; }
        /// <summary>
        /// Do you want to back up system state with VSS? Applicable only if the value of backupSystemState is true
        /// </summary>
        bool? BackupContentUseVssForSystemState { get; set; }
        /// <summary>Paths to exclude for Windows</summary>
        System.Collections.Generic.List<string> BackupContentWindowsExcludedPaths { get; set; }
        /// <summary>Paths that are exception to excluded paths for Windows</summary>
        System.Collections.Generic.List<string> BackupContentWindowsFilterToExcludePaths { get; set; }
        /// <summary>Paths to include for Windows</summary>
        System.Collections.Generic.List<string> BackupContentWindowsIncludedPaths { get; set; }

        Commvault.Powershell.Models.IPlanContentDataReaders BackupContentWindowsNumberOfDataReaders { get; set; }
        /// <summary>Number of data readers.</summary>
        long? MacNumberOfDataReaderCount { get; set; }
        /// <summary>
        /// Set optimal number of data readers. if it is set to true, count will be ignored.
        /// </summary>
        bool? MacNumberOfDataReaderUseOptimal { get; set; }
        /// <summary>Number of data readers.</summary>
        long? UnixNumberOfDataReaderCount { get; set; }
        /// <summary>
        /// Set optimal number of data readers. if it is set to true, count will be ignored.
        /// </summary>
        bool? UnixNumberOfDataReaderUseOptimal { get; set; }
        /// <summary>Number of data readers.</summary>
        long? WindowNumberOfDataReaderCount { get; set; }
        /// <summary>
        /// Set optimal number of data readers. if it is set to true, count will be ignored.
        /// </summary>
        bool? WindowNumberOfDataReaderUseOptimal { get; set; }

    }
}