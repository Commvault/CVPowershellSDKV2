// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.2, generator: @autorest/powershell@4.0.708)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Commvault.Powershell.Models
{
    using static Commvault.Powershell.Runtime.Extensions;

    /// <summary>UpdatevmGroupReq</summary>
    public partial class UpdatevmGroupReq :
        Commvault.Powershell.Models.IUpdatevmGroupReq,
        Commvault.Powershell.Models.IUpdatevmGroupReqInternal
    {

        /// <summary>Backing field for <see cref="AccessNode" /> property.</summary>
        private System.Collections.Generic.List<Commvault.Powershell.Models.IAccessNodeModel> _accessNode;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IAccessNodeModel> AccessNode { get => this._accessNode; set => this._accessNode = value; }

        /// <summary>Backing field for <see cref="ActivityControl" /> property.</summary>
        private Commvault.Powershell.Models.IActivityControlOptions _activityControl;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IActivityControlOptions ActivityControl { get => (this._activityControl = this._activityControl ?? new Commvault.Powershell.Models.ActivityControlOptions()); set => this._activityControl = value; }

        /// <summary>true if Backup is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? ActivityControlEnableBackup { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).EnableBackup; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).EnableBackup = value ?? default(bool); }

        /// <summary>true if Restore is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? ActivityControlEnableRestore { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).EnableRestore; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).EnableRestore = value ?? default(bool); }

        /// <summary>Backing field for <see cref="ApplicationValidation" /> property.</summary>
        private Commvault.Powershell.Models.IVMAppValidation _applicationValidation;

        /// <summary>vmAppValidation</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public Commvault.Powershell.Models.IVMAppValidation ApplicationValidation { get => (this._applicationValidation = this._applicationValidation ?? new Commvault.Powershell.Models.VMAppValidation()); set => this._applicationValidation = value; }

        /// <summary>denotes the activity type being considered</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string BackupActivityControlOptionActivityType { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionActivityType; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionActivityType = value ?? null; }

        /// <summary>True if the activity type is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? BackupActivityControlOptionEnableActivityType { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionEnableActivityType; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionEnableActivityType = value ?? default(bool); }

        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? BackupActivityControlOptionEnableAfterADelay { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionEnableAfterADelay; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionEnableAfterADelay = value ?? default(bool); }

        /// <summary>delay time in unix timestamp</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? BackupActivityControlOptionsDelayTime { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsDelayTimeTime; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsDelayTimeTime = value ?? default(long); }

        /// <summary>actual delay time value in string format according to the timezone</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string BackupActivityControlOptionsDelayTimeValue { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsDelayTimeValue; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsDelayTimeValue = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? BackupActivityControlOptionsDelayTimeZoneId { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsDelayTimeTimeZoneId; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsDelayTimeTimeZoneId = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string BackupActivityControlOptionsDelayTimeZoneName { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsDelayTimeTimeZoneName; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsDelayTimeTimeZoneName = value ?? null; }

        /// <summary>Internal Acessors for ActivityControl</summary>
        Commvault.Powershell.Models.IActivityControlOptions Commvault.Powershell.Models.IUpdatevmGroupReqInternal.ActivityControl { get => (this._activityControl = this._activityControl ?? new Commvault.Powershell.Models.ActivityControlOptions()); set { {_activityControl = value;} } }

        /// <summary>Internal Acessors for ActivityControlBackupActivityControlOptions</summary>
        Commvault.Powershell.Models.IActivityControlOptionsProp Commvault.Powershell.Models.IUpdatevmGroupReqInternal.ActivityControlBackupActivityControlOptions { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptions; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptions = value; }

        /// <summary>Internal Acessors for ActivityControlRestoreActivityControlOptions</summary>
        Commvault.Powershell.Models.IActivityControlOptionsProp Commvault.Powershell.Models.IUpdatevmGroupReqInternal.ActivityControlRestoreActivityControlOptions { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptions; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptions = value; }

        /// <summary>Internal Acessors for BackupActivityControlOptionDelayTime</summary>
        Commvault.Powershell.Models.IActivityControlTileDelayTime Commvault.Powershell.Models.IUpdatevmGroupReqInternal.BackupActivityControlOptionDelayTime { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionDelayTime; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionDelayTime = value; }

        /// <summary>Internal Acessors for BackupActivityControlOptionsDelayTimeZone</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.BackupActivityControlOptionsDelayTimeZone { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsDelayTimeTimeZone; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsDelayTimeTimeZone = value; }

        /// <summary>Internal Acessors for Content</summary>
        Commvault.Powershell.Models.IVMContent Commvault.Powershell.Models.IUpdatevmGroupReqInternal.Content { get => (this._content = this._content ?? new Commvault.Powershell.Models.VMContent()); set { {_content = value;} } }

        /// <summary>Internal Acessors for DiskFilters</summary>
        Commvault.Powershell.Models.IVMDiskFilterProp Commvault.Powershell.Models.IUpdatevmGroupReqInternal.DiskFilters { get => (this._diskFilters = this._diskFilters ?? new Commvault.Powershell.Models.VMDiskFilterProp()); set { {_diskFilters = value;} } }

        /// <summary>Internal Acessors for Filters</summary>
        Commvault.Powershell.Models.IVMContent Commvault.Powershell.Models.IUpdatevmGroupReqInternal.Filters { get => (this._filters = this._filters ?? new Commvault.Powershell.Models.VMContent()); set { {_filters = value;} } }

        /// <summary>Internal Acessors for MeditechSystemUserAccount</summary>
        Commvault.Powershell.Models.IUserNamePassword Commvault.Powershell.Models.IUpdatevmGroupReqInternal.MeditechSystemUserAccount { get => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).UserAccount; set => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).UserAccount = value; }

        /// <summary>Internal Acessors for MeditechSystems</summary>
        Commvault.Powershell.Models.IMeditechPropResp Commvault.Powershell.Models.IUpdatevmGroupReqInternal.MeditechSystems { get => (this._meditechSystems = this._meditechSystems ?? new Commvault.Powershell.Models.MeditechPropResp()); set { {_meditechSystems = value;} } }

        /// <summary>Internal Acessors for Plan</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.Plan { get => (this._plan = this._plan ?? new Commvault.Powershell.Models.IdName()); set { {_plan = value;} } }

        /// <summary>Internal Acessors for RestoreActivityControlOptionDelayTime</summary>
        Commvault.Powershell.Models.IActivityControlTileDelayTime Commvault.Powershell.Models.IUpdatevmGroupReqInternal.RestoreActivityControlOptionDelayTime { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionDelayTime; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionDelayTime = value; }

        /// <summary>Internal Acessors for RestoreActivityControlOptionsDelayTimeZone</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.RestoreActivityControlOptionsDelayTimeZone { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsDelayTimeTimeZone; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsDelayTimeTimeZone = value; }

        /// <summary>Internal Acessors for SnapshotManagement</summary>
        Commvault.Powershell.Models.ISnapCopyInfo Commvault.Powershell.Models.IUpdatevmGroupReqInternal.SnapshotManagement { get => (this._snapshotManagement = this._snapshotManagement ?? new Commvault.Powershell.Models.SnapCopyInfo()); set { {_snapshotManagement = value;} } }

        /// <summary>Internal Acessors for SnapshotManagementSnapEngine</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.SnapshotManagementSnapEngine { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngine; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngine = value; }

        /// <summary>Internal Acessors for SnapshotManagementSnapMountProxy</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.SnapshotManagementSnapMountProxy { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxy; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxy = value; }

        /// <summary>Internal Acessors for Storage</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.Storage { get => (this._storage = this._storage ?? new Commvault.Powershell.Models.IdName()); set { {_storage = value;} } }

        /// <summary>Internal Acessors for TimeZone</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.TimeZone { get => (this._timeZone = this._timeZone ?? new Commvault.Powershell.Models.IdName()); set { {_timeZone = value;} } }

        /// <summary>Backing field for <see cref="Content" /> property.</summary>
        private Commvault.Powershell.Models.IVMContent _content;

        /// <summary>RuleContent</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IVMContent Content { get => (this._content = this._content ?? new Commvault.Powershell.Models.VMContent()); set => this._content = value; }

        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? ContentOverwrite { get => ((Commvault.Powershell.Models.IVMContentInternal)Content).Overwrite; set => ((Commvault.Powershell.Models.IVMContentInternal)Content).Overwrite = value ?? default(bool); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IRuleGroupContent> ContentRuleGroups { get => ((Commvault.Powershell.Models.IVMContentInternal)Content).RuleGroups; set => ((Commvault.Powershell.Models.IVMContentInternal)Content).RuleGroups = value ?? null /* arrayOf */; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IVirtualMachinecontent> ContentVirtualMachines { get => ((Commvault.Powershell.Models.IVMContentInternal)Content).VirtualMachines; set => ((Commvault.Powershell.Models.IVMContentInternal)Content).VirtualMachines = value ?? null /* arrayOf */; }

        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? DiskFilterOverwrite { get => ((Commvault.Powershell.Models.IVMDiskFilterPropInternal)DiskFilters).Overwrite; set => ((Commvault.Powershell.Models.IVMDiskFilterPropInternal)DiskFilters).Overwrite = value ?? default(bool); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IVMDiskFilter> DiskFilterRules { get => ((Commvault.Powershell.Models.IVMDiskFilterPropInternal)DiskFilters).Rules; set => ((Commvault.Powershell.Models.IVMDiskFilterPropInternal)DiskFilters).Rules = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="DiskFilters" /> property.</summary>
        private Commvault.Powershell.Models.IVMDiskFilterProp _diskFilters;

        /// <summary>vmDiskFilterProp</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IVMDiskFilterProp DiskFilters { get => (this._diskFilters = this._diskFilters ?? new Commvault.Powershell.Models.VMDiskFilterProp()); set => this._diskFilters = value; }

        /// <summary>Backing field for <see cref="EnableFileIndexing" /> property.</summary>
        private bool? _enableFileIndexing;

        /// <summary>True if file indexing needs to be enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public bool? EnableFileIndexing { get => this._enableFileIndexing; set => this._enableFileIndexing = value; }

        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? FilterOverwrite { get => ((Commvault.Powershell.Models.IVMContentInternal)Filters).Overwrite; set => ((Commvault.Powershell.Models.IVMContentInternal)Filters).Overwrite = value ?? default(bool); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IRuleGroupContent> FilterRuleGroups { get => ((Commvault.Powershell.Models.IVMContentInternal)Filters).RuleGroups; set => ((Commvault.Powershell.Models.IVMContentInternal)Filters).RuleGroups = value ?? null /* arrayOf */; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.IVirtualMachinecontent> FilterVirtualMachines { get => ((Commvault.Powershell.Models.IVMContentInternal)Filters).VirtualMachines; set => ((Commvault.Powershell.Models.IVMContentInternal)Filters).VirtualMachines = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="Filters" /> property.</summary>
        private Commvault.Powershell.Models.IVMContent _filters;

        /// <summary>RuleContent</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IVMContent Filters { get => (this._filters = this._filters ?? new Commvault.Powershell.Models.VMContent()); set => this._filters = value; }

        /// <summary>Meditech Listener IP of FQDN name</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string MeditechSystemListenerIP { get => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).ListenerIP; set => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).ListenerIP = value ?? null; }

        /// <summary>Meditech Listener Port</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? MeditechSystemListenerPort { get => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).ListenerPort; set => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).ListenerPort = value ?? default(long); }

        /// <summary>MBF timeout (in seconds)</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? MeditechSystemMbFtimeout { get => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).MbFtimeout; set => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).MbFtimeout = value ?? default(long); }

        /// <summary>Meditech system name</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string MeditechSystemName { get => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).SystemName; set => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).SystemName = value ?? null; }

        /// <summary>Backing field for <see cref="MeditechSystems" /> property.</summary>
        private Commvault.Powershell.Models.IMeditechPropResp _meditechSystems;

        /// <summary>meditechPropResp</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IMeditechPropResp MeditechSystems { get => (this._meditechSystems = this._meditechSystems ?? new Commvault.Powershell.Models.MeditechPropResp()); set => this._meditechSystems = value; }

        /// <summary>Backing field for <see cref="NewName" /> property.</summary>
        private string _newName;

        /// <summary>subclient name</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string NewName { get => this._newName; set => this._newName = value; }

        /// <summary>Backing field for <see cref="Plan" /> property.</summary>
        private Commvault.Powershell.Models.IIdName _plan;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IIdName Plan { get => (this._plan = this._plan ?? new Commvault.Powershell.Models.IdName()); set => this._plan = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? PlanId { get => ((Commvault.Powershell.Models.IIdNameInternal)Plan).Id; set => ((Commvault.Powershell.Models.IIdNameInternal)Plan).Id = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string PlanName { get => ((Commvault.Powershell.Models.IIdNameInternal)Plan).Name; set => ((Commvault.Powershell.Models.IIdNameInternal)Plan).Name = value ?? null; }

        /// <summary>denotes the activity type being considered</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string RestoreActivityControlOptionActivityType { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionActivityType; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionActivityType = value ?? null; }

        /// <summary>True if the activity type is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? RestoreActivityControlOptionEnableActivityType { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionEnableActivityType; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionEnableActivityType = value ?? default(bool); }

        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? RestoreActivityControlOptionEnableAfterADelay { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionEnableAfterADelay; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionEnableAfterADelay = value ?? default(bool); }

        /// <summary>delay time in unix timestamp</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? RestoreActivityControlOptionsDelayTime { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsDelayTimeTime; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsDelayTimeTime = value ?? default(long); }

        /// <summary>actual delay time value in string format according to the timezone</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string RestoreActivityControlOptionsDelayTimeValue { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsDelayTimeValue; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsDelayTimeValue = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? RestoreActivityControlOptionsDelayTimeZoneId { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsDelayTimeTimeZoneId; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsDelayTimeTimeZoneId = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string RestoreActivityControlOptionsDelayTimeZoneName { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsDelayTimeTimeZoneName; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsDelayTimeTimeZoneName = value ?? null; }

        /// <summary>Backing field for <see cref="SecurityAssociations" /> property.</summary>
        private System.Collections.Generic.List<Commvault.Powershell.Models.ISecurityAssoc> _securityAssociations;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public System.Collections.Generic.List<Commvault.Powershell.Models.ISecurityAssoc> SecurityAssociations { get => this._securityAssociations; set => this._securityAssociations = value; }

        /// <summary>Backing field for <see cref="Settings" /> property.</summary>
        private Commvault.Powershell.Models.IVMGroupSettings _settings;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public Commvault.Powershell.Models.IVMGroupSettings Settings { get => (this._settings = this._settings ?? new Commvault.Powershell.Models.VMGroupSettings()); set => this._settings = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? SnapEngineId { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngineId; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngineId = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapEngineName { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngineName; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngineName = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? SnapMountProxyId { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxyId; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxyId = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapMountProxyName { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxyName; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxyName = value ?? null; }

        /// <summary>Backing field for <see cref="SnapshotManagement" /> property.</summary>
        private Commvault.Powershell.Models.ISnapCopyInfo _snapshotManagement;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.ISnapCopyInfo SnapshotManagement { get => (this._snapshotManagement = this._snapshotManagement ?? new Commvault.Powershell.Models.SnapCopyInfo()); set => this._snapshotManagement = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapshotManagementBackupCopyInterface { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).BackupCopyInterface; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).BackupCopyInterface = value ?? null; }

        /// <summary>True if hardware snapshot is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SnapshotManagementEnableHardwareSnapshot { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).EnableHardwareSnapshot; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).EnableHardwareSnapshot = value ?? default(bool); }

        /// <summary>True if independent disk option is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SnapshotManagementIsIndependentDisksEnabled { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsIndependentDisksEnabled; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsIndependentDisksEnabled = value ?? default(bool); }

        /// <summary>True if raw device maps option is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SnapshotManagementIsRawDeviceMapsEnabled { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsRawDeviceMapsEnabled; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsRawDeviceMapsEnabled = value ?? default(bool); }

        /// <summary>Name of ESX Host</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapshotManagementSnapMountEsxHost { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountEsxHost; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountEsxHost = value ?? null; }

        /// <summary>True if separate proxy client is used for snap to tape</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SnapshotManagementUseSeparateProxyForSnapToTape { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).UseSeparateProxyForSnapToTape; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).UseSeparateProxyForSnapToTape = value ?? default(bool); }

        /// <summary>Virtual machine application user name</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapshotManagementVMApplicationUserName { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).VMApplicationUserName; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).VMApplicationUserName = value ?? null; }

        /// <summary>Backing field for <see cref="Storage" /> property.</summary>
        private Commvault.Powershell.Models.IIdName _storage;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IIdName Storage { get => (this._storage = this._storage ?? new Commvault.Powershell.Models.IdName()); set => this._storage = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? StorageId { get => ((Commvault.Powershell.Models.IIdNameInternal)Storage).Id; set => ((Commvault.Powershell.Models.IIdNameInternal)Storage).Id = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string StorageName { get => ((Commvault.Powershell.Models.IIdNameInternal)Storage).Name; set => ((Commvault.Powershell.Models.IIdNameInternal)Storage).Name = value ?? null; }

        /// <summary>Backing field for <see cref="TimeZone" /> property.</summary>
        private Commvault.Powershell.Models.IIdName _timeZone;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IIdName TimeZone { get => (this._timeZone = this._timeZone ?? new Commvault.Powershell.Models.IdName()); set => this._timeZone = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? TimeZoneId { get => ((Commvault.Powershell.Models.IIdNameInternal)TimeZone).Id; set => ((Commvault.Powershell.Models.IIdNameInternal)TimeZone).Id = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string TimeZoneName { get => ((Commvault.Powershell.Models.IIdNameInternal)TimeZone).Name; set => ((Commvault.Powershell.Models.IIdNameInternal)TimeZone).Name = value ?? null; }

        /// <summary>username to access the network path</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string UserAccountName { get => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).UserAccountName; set => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).UserAccountName = value ?? null; }

        /// <summary>password to access the network path</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string UserAccountPassword { get => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).UserAccountPassword; set => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).UserAccountPassword = value ?? null; }

        /// <summary>Creates an new <see cref="UpdatevmGroupReq" /> instance.</summary>
        public UpdatevmGroupReq()
        {

        }
    }
    /// UpdatevmGroupReq
    public partial interface IUpdatevmGroupReq :
        Commvault.Powershell.Runtime.IJsonSerializable
    {
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"accessNode",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IAccessNodeModel) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IAccessNodeModel> AccessNode { get; set; }
        /// <summary>true if Backup is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"true if Backup is enabled",
        SerializedName = @"enableBackup",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ActivityControlEnableBackup { get; set; }
        /// <summary>true if Restore is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"true if Restore is enabled",
        SerializedName = @"enableRestore",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ActivityControlEnableRestore { get; set; }
        /// <summary>vmAppValidation</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"vmAppValidation",
        SerializedName = @"applicationValidation",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IVMAppValidation) })]
        Commvault.Powershell.Models.IVMAppValidation ApplicationValidation { get; set; }
        /// <summary>denotes the activity type being considered</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"denotes the activity type being considered",
        SerializedName = @"activityType",
        PossibleTypes = new [] { typeof(string) })]
        string BackupActivityControlOptionActivityType { get; set; }
        /// <summary>True if the activity type is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if the activity type is enabled",
        SerializedName = @"enableActivityType",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BackupActivityControlOptionEnableActivityType { get; set; }
        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if the activity will be enabled after a delay time interval",
        SerializedName = @"enableAfterADelay",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BackupActivityControlOptionEnableAfterADelay { get; set; }
        /// <summary>delay time in unix timestamp</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"delay time in unix timestamp",
        SerializedName = @"time",
        PossibleTypes = new [] { typeof(long) })]
        long? BackupActivityControlOptionsDelayTime { get; set; }
        /// <summary>actual delay time value in string format according to the timezone</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"actual delay time value in string format according to the timezone",
        SerializedName = @"value",
        PossibleTypes = new [] { typeof(string) })]
        string BackupActivityControlOptionsDelayTimeValue { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? BackupActivityControlOptionsDelayTimeZoneId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string BackupActivityControlOptionsDelayTimeZoneName { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if content in vmgroup has to be overwritten, by default it will append the content",
        SerializedName = @"overwrite",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ContentOverwrite { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"ruleGroups",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IRuleGroupContent) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IRuleGroupContent> ContentRuleGroups { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"virtualMachines",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IVirtualMachinecontent) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IVirtualMachinecontent> ContentVirtualMachines { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if content in vmgroup has to be overwritten, by default it will append the content",
        SerializedName = @"overwrite",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DiskFilterOverwrite { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"rules",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IVMDiskFilter) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IVMDiskFilter> DiskFilterRules { get; set; }
        /// <summary>True if file indexing needs to be enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if file indexing needs to be enabled",
        SerializedName = @"enableFileIndexing",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnableFileIndexing { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if content in vmgroup has to be overwritten, by default it will append the content",
        SerializedName = @"overwrite",
        PossibleTypes = new [] { typeof(bool) })]
        bool? FilterOverwrite { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"ruleGroups",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IRuleGroupContent) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IRuleGroupContent> FilterRuleGroups { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"virtualMachines",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IVirtualMachinecontent) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.IVirtualMachinecontent> FilterVirtualMachines { get; set; }
        /// <summary>Meditech Listener IP of FQDN name</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Meditech Listener IP of FQDN name",
        SerializedName = @"listenerIP",
        PossibleTypes = new [] { typeof(string) })]
        string MeditechSystemListenerIP { get; set; }
        /// <summary>Meditech Listener Port</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Meditech Listener Port",
        SerializedName = @"listenerPort",
        PossibleTypes = new [] { typeof(long) })]
        long? MeditechSystemListenerPort { get; set; }
        /// <summary>MBF timeout (in seconds)</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"MBF timeout (in seconds)",
        SerializedName = @"MBFtimeout",
        PossibleTypes = new [] { typeof(long) })]
        long? MeditechSystemMbFtimeout { get; set; }
        /// <summary>Meditech system name</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Meditech system name",
        SerializedName = @"systemName",
        PossibleTypes = new [] { typeof(string) })]
        string MeditechSystemName { get; set; }
        /// <summary>subclient name</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"subclient name ",
        SerializedName = @"newName",
        PossibleTypes = new [] { typeof(string) })]
        string NewName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? PlanId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string PlanName { get; set; }
        /// <summary>denotes the activity type being considered</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"denotes the activity type being considered",
        SerializedName = @"activityType",
        PossibleTypes = new [] { typeof(string) })]
        string RestoreActivityControlOptionActivityType { get; set; }
        /// <summary>True if the activity type is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if the activity type is enabled",
        SerializedName = @"enableActivityType",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RestoreActivityControlOptionEnableActivityType { get; set; }
        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if the activity will be enabled after a delay time interval",
        SerializedName = @"enableAfterADelay",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RestoreActivityControlOptionEnableAfterADelay { get; set; }
        /// <summary>delay time in unix timestamp</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"delay time in unix timestamp",
        SerializedName = @"time",
        PossibleTypes = new [] { typeof(long) })]
        long? RestoreActivityControlOptionsDelayTime { get; set; }
        /// <summary>actual delay time value in string format according to the timezone</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"actual delay time value in string format according to the timezone",
        SerializedName = @"value",
        PossibleTypes = new [] { typeof(string) })]
        string RestoreActivityControlOptionsDelayTimeValue { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? RestoreActivityControlOptionsDelayTimeZoneId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string RestoreActivityControlOptionsDelayTimeZoneName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"securityAssociations",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.ISecurityAssoc) })]
        System.Collections.Generic.List<Commvault.Powershell.Models.ISecurityAssoc> SecurityAssociations { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"settings",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IVMGroupSettings) })]
        Commvault.Powershell.Models.IVMGroupSettings Settings { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? SnapEngineId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string SnapEngineName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? SnapMountProxyId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string SnapMountProxyName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"backupCopyInterface",
        PossibleTypes = new [] { typeof(string) })]
        string SnapshotManagementBackupCopyInterface { get; set; }
        /// <summary>True if hardware snapshot is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if hardware snapshot is enabled",
        SerializedName = @"enableHardwareSnapshot",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotManagementEnableHardwareSnapshot { get; set; }
        /// <summary>True if independent disk option is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if independent disk option is enabled",
        SerializedName = @"isIndependentDisksEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotManagementIsIndependentDisksEnabled { get; set; }
        /// <summary>True if raw device maps option is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if raw device maps option is enabled",
        SerializedName = @"isRawDeviceMapsEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotManagementIsRawDeviceMapsEnabled { get; set; }
        /// <summary>Name of ESX Host</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Name of ESX Host",
        SerializedName = @"snapMountESXHost",
        PossibleTypes = new [] { typeof(string) })]
        string SnapshotManagementSnapMountEsxHost { get; set; }
        /// <summary>True if separate proxy client is used for snap to tape</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if separate proxy client is used for snap to tape",
        SerializedName = @"useSeparateProxyForSnapToTape",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotManagementUseSeparateProxyForSnapToTape { get; set; }
        /// <summary>Virtual machine application user name</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Virtual machine application user name",
        SerializedName = @"vmApplicationUserName",
        PossibleTypes = new [] { typeof(string) })]
        string SnapshotManagementVMApplicationUserName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? StorageId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string StorageName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? TimeZoneId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string TimeZoneName { get; set; }
        /// <summary>username to access the network path</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"username to access the network path",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string UserAccountName { get; set; }
        /// <summary>password to access the network path</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"password to access the network path",
        SerializedName = @"password",
        PossibleTypes = new [] { typeof(string) })]
        string UserAccountPassword { get; set; }

    }
    /// UpdatevmGroupReq
    internal partial interface IUpdatevmGroupReqInternal

    {
        System.Collections.Generic.List<Commvault.Powershell.Models.IAccessNodeModel> AccessNode { get; set; }

        Commvault.Powershell.Models.IActivityControlOptions ActivityControl { get; set; }

        Commvault.Powershell.Models.IActivityControlOptionsProp ActivityControlBackupActivityControlOptions { get; set; }
        /// <summary>true if Backup is enabled</summary>
        bool? ActivityControlEnableBackup { get; set; }
        /// <summary>true if Restore is enabled</summary>
        bool? ActivityControlEnableRestore { get; set; }

        Commvault.Powershell.Models.IActivityControlOptionsProp ActivityControlRestoreActivityControlOptions { get; set; }
        /// <summary>vmAppValidation</summary>
        Commvault.Powershell.Models.IVMAppValidation ApplicationValidation { get; set; }
        /// <summary>denotes the activity type being considered</summary>
        string BackupActivityControlOptionActivityType { get; set; }
        /// <summary>ActivityControlTileDelayTime</summary>
        Commvault.Powershell.Models.IActivityControlTileDelayTime BackupActivityControlOptionDelayTime { get; set; }
        /// <summary>True if the activity type is enabled</summary>
        bool? BackupActivityControlOptionEnableActivityType { get; set; }
        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        bool? BackupActivityControlOptionEnableAfterADelay { get; set; }
        /// <summary>delay time in unix timestamp</summary>
        long? BackupActivityControlOptionsDelayTime { get; set; }
        /// <summary>actual delay time value in string format according to the timezone</summary>
        string BackupActivityControlOptionsDelayTimeValue { get; set; }

        Commvault.Powershell.Models.IIdName BackupActivityControlOptionsDelayTimeZone { get; set; }

        long? BackupActivityControlOptionsDelayTimeZoneId { get; set; }

        string BackupActivityControlOptionsDelayTimeZoneName { get; set; }
        /// <summary>RuleContent</summary>
        Commvault.Powershell.Models.IVMContent Content { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        bool? ContentOverwrite { get; set; }

        System.Collections.Generic.List<Commvault.Powershell.Models.IRuleGroupContent> ContentRuleGroups { get; set; }

        System.Collections.Generic.List<Commvault.Powershell.Models.IVirtualMachinecontent> ContentVirtualMachines { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        bool? DiskFilterOverwrite { get; set; }

        System.Collections.Generic.List<Commvault.Powershell.Models.IVMDiskFilter> DiskFilterRules { get; set; }
        /// <summary>vmDiskFilterProp</summary>
        Commvault.Powershell.Models.IVMDiskFilterProp DiskFilters { get; set; }
        /// <summary>True if file indexing needs to be enabled</summary>
        bool? EnableFileIndexing { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        bool? FilterOverwrite { get; set; }

        System.Collections.Generic.List<Commvault.Powershell.Models.IRuleGroupContent> FilterRuleGroups { get; set; }

        System.Collections.Generic.List<Commvault.Powershell.Models.IVirtualMachinecontent> FilterVirtualMachines { get; set; }
        /// <summary>RuleContent</summary>
        Commvault.Powershell.Models.IVMContent Filters { get; set; }
        /// <summary>Meditech Listener IP of FQDN name</summary>
        string MeditechSystemListenerIP { get; set; }
        /// <summary>Meditech Listener Port</summary>
        long? MeditechSystemListenerPort { get; set; }
        /// <summary>MBF timeout (in seconds)</summary>
        long? MeditechSystemMbFtimeout { get; set; }
        /// <summary>Meditech system name</summary>
        string MeditechSystemName { get; set; }

        Commvault.Powershell.Models.IUserNamePassword MeditechSystemUserAccount { get; set; }
        /// <summary>meditechPropResp</summary>
        Commvault.Powershell.Models.IMeditechPropResp MeditechSystems { get; set; }
        /// <summary>subclient name</summary>
        string NewName { get; set; }

        Commvault.Powershell.Models.IIdName Plan { get; set; }

        long? PlanId { get; set; }

        string PlanName { get; set; }
        /// <summary>denotes the activity type being considered</summary>
        string RestoreActivityControlOptionActivityType { get; set; }
        /// <summary>ActivityControlTileDelayTime</summary>
        Commvault.Powershell.Models.IActivityControlTileDelayTime RestoreActivityControlOptionDelayTime { get; set; }
        /// <summary>True if the activity type is enabled</summary>
        bool? RestoreActivityControlOptionEnableActivityType { get; set; }
        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        bool? RestoreActivityControlOptionEnableAfterADelay { get; set; }
        /// <summary>delay time in unix timestamp</summary>
        long? RestoreActivityControlOptionsDelayTime { get; set; }
        /// <summary>actual delay time value in string format according to the timezone</summary>
        string RestoreActivityControlOptionsDelayTimeValue { get; set; }

        Commvault.Powershell.Models.IIdName RestoreActivityControlOptionsDelayTimeZone { get; set; }

        long? RestoreActivityControlOptionsDelayTimeZoneId { get; set; }

        string RestoreActivityControlOptionsDelayTimeZoneName { get; set; }

        System.Collections.Generic.List<Commvault.Powershell.Models.ISecurityAssoc> SecurityAssociations { get; set; }

        Commvault.Powershell.Models.IVMGroupSettings Settings { get; set; }

        long? SnapEngineId { get; set; }

        string SnapEngineName { get; set; }

        long? SnapMountProxyId { get; set; }

        string SnapMountProxyName { get; set; }

        Commvault.Powershell.Models.ISnapCopyInfo SnapshotManagement { get; set; }

        string SnapshotManagementBackupCopyInterface { get; set; }
        /// <summary>True if hardware snapshot is enabled</summary>
        bool? SnapshotManagementEnableHardwareSnapshot { get; set; }
        /// <summary>True if independent disk option is enabled</summary>
        bool? SnapshotManagementIsIndependentDisksEnabled { get; set; }
        /// <summary>True if raw device maps option is enabled</summary>
        bool? SnapshotManagementIsRawDeviceMapsEnabled { get; set; }

        Commvault.Powershell.Models.IIdName SnapshotManagementSnapEngine { get; set; }
        /// <summary>Name of ESX Host</summary>
        string SnapshotManagementSnapMountEsxHost { get; set; }

        Commvault.Powershell.Models.IIdName SnapshotManagementSnapMountProxy { get; set; }
        /// <summary>True if separate proxy client is used for snap to tape</summary>
        bool? SnapshotManagementUseSeparateProxyForSnapToTape { get; set; }
        /// <summary>Virtual machine application user name</summary>
        string SnapshotManagementVMApplicationUserName { get; set; }

        Commvault.Powershell.Models.IIdName Storage { get; set; }

        long? StorageId { get; set; }

        string StorageName { get; set; }

        Commvault.Powershell.Models.IIdName TimeZone { get; set; }

        long? TimeZoneId { get; set; }

        string TimeZoneName { get; set; }
        /// <summary>username to access the network path</summary>
        string UserAccountName { get; set; }
        /// <summary>password to access the network path</summary>
        string UserAccountPassword { get; set; }

    }
}