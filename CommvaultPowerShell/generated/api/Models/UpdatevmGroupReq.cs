// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.4, generator: @autorest/powershell@3.0.415)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Commvault.Powershell.Models
{
    using static Commvault.Powershell.Runtime.Extensions;

    /// <summary>UpdatevmGroupReq</summary>
    public partial class UpdatevmGroupReq :
        Commvault.Powershell.Models.IUpdatevmGroupReq,
        Commvault.Powershell.Models.IUpdatevmGroupReqInternal
    {

        /// <summary>Backing field for <see cref="AccessNode" /> property.</summary>
        private Commvault.Powershell.Models.IIdName[] _accessNode;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public Commvault.Powershell.Models.IIdName[] AccessNode { get => this._accessNode; set => this._accessNode = value; }

        /// <summary>Backing field for <see cref="ActivityControl" /> property.</summary>
        private Commvault.Powershell.Models.IActivityControlOptions _activityControl;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IActivityControlOptions ActivityControl { get => (this._activityControl = this._activityControl ?? new Commvault.Powershell.Models.ActivityControlOptions()); set => this._activityControl = value; }

        /// <summary>true if Backup is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? ActivityControlEnableBackup { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).EnableBackup; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).EnableBackup = value ?? default(bool); }

        /// <summary>true if Restore is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? ActivityControlEnableRestore { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).EnableRestore; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).EnableRestore = value ?? default(bool); }

        /// <summary>Backing field for <see cref="ApplicationValidation" /> property.</summary>
        private Commvault.Powershell.Models.IVMAppValidation _applicationValidation;

        /// <summary>vmAppValidation</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public Commvault.Powershell.Models.IVMAppValidation ApplicationValidation { get => (this._applicationValidation = this._applicationValidation ?? new Commvault.Powershell.Models.VMAppValidation()); set => this._applicationValidation = value; }

        /// <summary>Delayed by n Hrs</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string BackupActivityControlOptionDelayTime { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionDelayTime; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionDelayTime = value ?? null; }

        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? BackupActivityControlOptionEnableAfterDelay { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionEnableAfterDelay; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionEnableAfterDelay = value ?? default(bool); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? BackupActivityControlOptionsTimeZoneId { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsTimeZoneId; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsTimeZoneId = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string BackupActivityControlOptionsTimeZoneName { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsTimeZoneName; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionsTimeZoneName = value ?? null; }

        /// <summary>Internal Acessors for ActivityControl</summary>
        Commvault.Powershell.Models.IActivityControlOptions Commvault.Powershell.Models.IUpdatevmGroupReqInternal.ActivityControl { get => (this._activityControl = this._activityControl ?? new Commvault.Powershell.Models.ActivityControlOptions()); set { {_activityControl = value;} } }

        /// <summary>Internal Acessors for ActivityControlBackupActivityControlOptions</summary>
        Commvault.Powershell.Models.IBackupActivityControlOptionsProp Commvault.Powershell.Models.IUpdatevmGroupReqInternal.ActivityControlBackupActivityControlOptions { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptions; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptions = value; }

        /// <summary>Internal Acessors for ActivityControlRestoreActivityControlOptions</summary>
        Commvault.Powershell.Models.IBackupActivityControlOptionsProp Commvault.Powershell.Models.IUpdatevmGroupReqInternal.ActivityControlRestoreActivityControlOptions { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptions; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptions = value; }

        /// <summary>Internal Acessors for BackupActivityControlOptionTimeZone</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.BackupActivityControlOptionTimeZone { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionTimeZone; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).BackupActivityControlOptionTimeZone = value; }

        /// <summary>Internal Acessors for Content</summary>
        Commvault.Powershell.Models.IVMContent Commvault.Powershell.Models.IUpdatevmGroupReqInternal.Content { get => (this._content = this._content ?? new Commvault.Powershell.Models.VMContent()); set { {_content = value;} } }

        /// <summary>Internal Acessors for DiskFilters</summary>
        Commvault.Powershell.Models.IVMDiskFilterProp Commvault.Powershell.Models.IUpdatevmGroupReqInternal.DiskFilters { get => (this._diskFilters = this._diskFilters ?? new Commvault.Powershell.Models.VMDiskFilterProp()); set { {_diskFilters = value;} } }

        /// <summary>Internal Acessors for Filters</summary>
        Commvault.Powershell.Models.IVMContent Commvault.Powershell.Models.IUpdatevmGroupReqInternal.Filters { get => (this._filters = this._filters ?? new Commvault.Powershell.Models.VMContent()); set { {_filters = value;} } }

        /// <summary>Internal Acessors for MeditechSystemUserAccount</summary>
        Commvault.Powershell.Models.IUserNamePassword Commvault.Powershell.Models.IUpdatevmGroupReqInternal.MeditechSystemUserAccount { get => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).UserAccount; set => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).UserAccount = value; }

        /// <summary>Internal Acessors for MeditechSystems</summary>
        Commvault.Powershell.Models.IMeditechPropResp Commvault.Powershell.Models.IUpdatevmGroupReqInternal.MeditechSystems { get => (this._meditechSystems = this._meditechSystems ?? new Commvault.Powershell.Models.MeditechPropResp()); set { {_meditechSystems = value;} } }

        /// <summary>Internal Acessors for Plan</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.Plan { get => (this._plan = this._plan ?? new Commvault.Powershell.Models.IdName()); set { {_plan = value;} } }

        /// <summary>Internal Acessors for RestoreActivityControlOptionTimeZone</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.RestoreActivityControlOptionTimeZone { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionTimeZone; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionTimeZone = value; }

        /// <summary>Internal Acessors for SnapshotManagement</summary>
        Commvault.Powershell.Models.ISnapCopyInfo Commvault.Powershell.Models.IUpdatevmGroupReqInternal.SnapshotManagement { get => (this._snapshotManagement = this._snapshotManagement ?? new Commvault.Powershell.Models.SnapCopyInfo()); set { {_snapshotManagement = value;} } }

        /// <summary>Internal Acessors for SnapshotManagementSnapEngine</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.SnapshotManagementSnapEngine { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngine; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngine = value; }

        /// <summary>Internal Acessors for SnapshotManagementSnapMountProxy</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.SnapshotManagementSnapMountProxy { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxy; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxy = value; }

        /// <summary>Internal Acessors for Storage</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdatevmGroupReqInternal.Storage { get => (this._storage = this._storage ?? new Commvault.Powershell.Models.IdName()); set { {_storage = value;} } }

        /// <summary>Backing field for <see cref="Content" /> property.</summary>
        private Commvault.Powershell.Models.IVMContent _content;

        /// <summary>RuleContent</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IVMContent Content { get => (this._content = this._content ?? new Commvault.Powershell.Models.VMContent()); set => this._content = value; }

        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? ContentOverwrite { get => ((Commvault.Powershell.Models.IVMContentInternal)Content).Overwrite; set => ((Commvault.Powershell.Models.IVMContentInternal)Content).Overwrite = value ?? default(bool); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public Commvault.Powershell.Models.IRuleGroupContent[] ContentRuleGroups { get => ((Commvault.Powershell.Models.IVMContentInternal)Content).RuleGroups; set => ((Commvault.Powershell.Models.IVMContentInternal)Content).RuleGroups = value ?? null /* arrayOf */; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public Commvault.Powershell.Models.IVirtualMachinecontent[] ContentVirtualMachines { get => ((Commvault.Powershell.Models.IVMContentInternal)Content).VirtualMachines; set => ((Commvault.Powershell.Models.IVMContentInternal)Content).VirtualMachines = value ?? null /* arrayOf */; }

        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? DiskFilterOverwrite { get => ((Commvault.Powershell.Models.IVMDiskFilterPropInternal)DiskFilters).Overwrite; set => ((Commvault.Powershell.Models.IVMDiskFilterPropInternal)DiskFilters).Overwrite = value ?? default(bool); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public Commvault.Powershell.Models.IVMDiskFilter[] DiskFilterRules { get => ((Commvault.Powershell.Models.IVMDiskFilterPropInternal)DiskFilters).Rules; set => ((Commvault.Powershell.Models.IVMDiskFilterPropInternal)DiskFilters).Rules = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="DiskFilters" /> property.</summary>
        private Commvault.Powershell.Models.IVMDiskFilterProp _diskFilters;

        /// <summary>vmDiskFilterProp</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IVMDiskFilterProp DiskFilters { get => (this._diskFilters = this._diskFilters ?? new Commvault.Powershell.Models.VMDiskFilterProp()); set => this._diskFilters = value; }

        /// <summary>Backing field for <see cref="EnableFileIndexing" /> property.</summary>
        private bool? _enableFileIndexing;

        /// <summary>True if file indexing needs to be enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public bool? EnableFileIndexing { get => this._enableFileIndexing; set => this._enableFileIndexing = value; }

        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? FilterOverwrite { get => ((Commvault.Powershell.Models.IVMContentInternal)Filters).Overwrite; set => ((Commvault.Powershell.Models.IVMContentInternal)Filters).Overwrite = value ?? default(bool); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public Commvault.Powershell.Models.IRuleGroupContent[] FilterRuleGroups { get => ((Commvault.Powershell.Models.IVMContentInternal)Filters).RuleGroups; set => ((Commvault.Powershell.Models.IVMContentInternal)Filters).RuleGroups = value ?? null /* arrayOf */; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public Commvault.Powershell.Models.IVirtualMachinecontent[] FilterVirtualMachines { get => ((Commvault.Powershell.Models.IVMContentInternal)Filters).VirtualMachines; set => ((Commvault.Powershell.Models.IVMContentInternal)Filters).VirtualMachines = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="Filters" /> property.</summary>
        private Commvault.Powershell.Models.IVMContent _filters;

        /// <summary>RuleContent</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IVMContent Filters { get => (this._filters = this._filters ?? new Commvault.Powershell.Models.VMContent()); set => this._filters = value; }

        /// <summary>Meditech Listener IP of FQDN name</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string MeditechSystemListenerIP { get => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).ListenerIP; set => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).ListenerIP = value ?? null; }

        /// <summary>Meditech Listener Port</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? MeditechSystemListenerPort { get => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).ListenerPort; set => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).ListenerPort = value ?? default(long); }

        /// <summary>MBF timeout (in seconds)</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? MeditechSystemMbFtimeout { get => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).MbFtimeout; set => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).MbFtimeout = value ?? default(long); }

        /// <summary>Meditech system name</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string MeditechSystemName { get => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).SystemName; set => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).SystemName = value ?? null; }

        /// <summary>Backing field for <see cref="MeditechSystems" /> property.</summary>
        private Commvault.Powershell.Models.IMeditechPropResp _meditechSystems;

        /// <summary>meditechPropResp</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IMeditechPropResp MeditechSystems { get => (this._meditechSystems = this._meditechSystems ?? new Commvault.Powershell.Models.MeditechPropResp()); set => this._meditechSystems = value; }

        /// <summary>Backing field for <see cref="NewName" /> property.</summary>
        private string _newName;

        /// <summary>subclient name</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string NewName { get => this._newName; set => this._newName = value; }

        /// <summary>Backing field for <see cref="Plan" /> property.</summary>
        private Commvault.Powershell.Models.IIdName _plan;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IIdName Plan { get => (this._plan = this._plan ?? new Commvault.Powershell.Models.IdName()); set => this._plan = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? PlanId { get => ((Commvault.Powershell.Models.IIdNameInternal)Plan).Id; set => ((Commvault.Powershell.Models.IIdNameInternal)Plan).Id = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string PlanName { get => ((Commvault.Powershell.Models.IIdNameInternal)Plan).Name; set => ((Commvault.Powershell.Models.IIdNameInternal)Plan).Name = value ?? null; }

        /// <summary>Delayed by n Hrs</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string RestoreActivityControlOptionDelayTime { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionDelayTime; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionDelayTime = value ?? null; }

        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? RestoreActivityControlOptionEnableAfterDelay { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionEnableAfterDelay; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionEnableAfterDelay = value ?? default(bool); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? RestoreActivityControlOptionsTimeZoneId { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsTimeZoneId; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsTimeZoneId = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string RestoreActivityControlOptionsTimeZoneName { get => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsTimeZoneName; set => ((Commvault.Powershell.Models.IActivityControlOptionsInternal)ActivityControl).RestoreActivityControlOptionsTimeZoneName = value ?? null; }

        /// <summary>Backing field for <see cref="SecurityAssociations" /> property.</summary>
        private Commvault.Powershell.Models.ISecurityAssoc[] _securityAssociations;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public Commvault.Powershell.Models.ISecurityAssoc[] SecurityAssociations { get => this._securityAssociations; set => this._securityAssociations = value; }

        /// <summary>Backing field for <see cref="Settings" /> property.</summary>
        private Commvault.Powershell.Models.IVMGroupSettings _settings;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public Commvault.Powershell.Models.IVMGroupSettings Settings { get => (this._settings = this._settings ?? new Commvault.Powershell.Models.VMGroupSettings()); set => this._settings = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? SnapEngineId { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngineId; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngineId = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapEngineName { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngineName; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapEngineName = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? SnapMountProxyId { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxyId; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxyId = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapMountProxyName { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxyName; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountProxyName = value ?? null; }

        /// <summary>Backing field for <see cref="SnapshotManagement" /> property.</summary>
        private Commvault.Powershell.Models.ISnapCopyInfo _snapshotManagement;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.ISnapCopyInfo SnapshotManagement { get => (this._snapshotManagement = this._snapshotManagement ?? new Commvault.Powershell.Models.SnapCopyInfo()); set => this._snapshotManagement = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapshotManagementBackupCopyInterface { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).BackupCopyInterface; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).BackupCopyInterface = value ?? null; }

        /// <summary>True if hardware snapshot is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SnapshotManagementEnableHardwareSnapshot { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).EnableHardwareSnapshot; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).EnableHardwareSnapshot = value ?? default(bool); }

        /// <summary>True if independent disk option is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SnapshotManagementIsIndependentDisksEnabled { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsIndependentDisksEnabled; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsIndependentDisksEnabled = value ?? default(bool); }

        /// <summary>True if raw device maps option is enabled</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SnapshotManagementIsRawDeviceMapsEnabled { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsRawDeviceMapsEnabled; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).IsRawDeviceMapsEnabled = value ?? default(bool); }

        /// <summary>Name of ESX Host</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapshotManagementSnapMountEsxHost { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountEsxHost; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).SnapMountEsxHost = value ?? null; }

        /// <summary>True if separate proxy client is used for snap to tape</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SnapshotManagementUseSeparateProxyForSnapToTape { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).UseSeparateProxyForSnapToTape; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).UseSeparateProxyForSnapToTape = value ?? default(bool); }

        /// <summary>Virtual machine application user name</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SnapshotManagementVMApplicationUserName { get => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).VMApplicationUserName; set => ((Commvault.Powershell.Models.ISnapCopyInfoInternal)SnapshotManagement).VMApplicationUserName = value ?? null; }

        /// <summary>Backing field for <see cref="Storage" /> property.</summary>
        private Commvault.Powershell.Models.IIdName _storage;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IIdName Storage { get => (this._storage = this._storage ?? new Commvault.Powershell.Models.IdName()); set => this._storage = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? StorageId { get => ((Commvault.Powershell.Models.IIdNameInternal)Storage).Id; set => ((Commvault.Powershell.Models.IIdNameInternal)Storage).Id = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string StorageName { get => ((Commvault.Powershell.Models.IIdNameInternal)Storage).Name; set => ((Commvault.Powershell.Models.IIdNameInternal)Storage).Name = value ?? null; }

        /// <summary>username to access the network path</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string UserAccountName { get => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).UserAccountName; set => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).UserAccountName = value ?? null; }

        /// <summary>password to access the network path</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string UserAccountPassword { get => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).UserAccountPassword; set => ((Commvault.Powershell.Models.IMeditechPropRespInternal)MeditechSystems).UserAccountPassword = value ?? null; }

        /// <summary>Creates an new <see cref="UpdatevmGroupReq" /> instance.</summary>
        public UpdatevmGroupReq()
        {

        }
    }
    /// UpdatevmGroupReq
    public partial interface IUpdatevmGroupReq :
        Commvault.Powershell.Runtime.IJsonSerializable
    {
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"accessNode",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IIdName) })]
        Commvault.Powershell.Models.IIdName[] AccessNode { get; set; }
        /// <summary>true if Backup is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"true if Backup is enabled",
        SerializedName = @"enableBackup",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ActivityControlEnableBackup { get; set; }
        /// <summary>true if Restore is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"true if Restore is enabled",
        SerializedName = @"enableRestore",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ActivityControlEnableRestore { get; set; }
        /// <summary>vmAppValidation</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"vmAppValidation",
        SerializedName = @"applicationValidation",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IVMAppValidation) })]
        Commvault.Powershell.Models.IVMAppValidation ApplicationValidation { get; set; }
        /// <summary>Delayed by n Hrs</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Delayed by n Hrs",
        SerializedName = @"delayTime",
        PossibleTypes = new [] { typeof(string) })]
        string BackupActivityControlOptionDelayTime { get; set; }
        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if the activity will be enabled after a delay time interval",
        SerializedName = @"enableAfterDelay",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BackupActivityControlOptionEnableAfterDelay { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? BackupActivityControlOptionsTimeZoneId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string BackupActivityControlOptionsTimeZoneName { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if content in vmgroup has to be overwritten, by default it will append the content",
        SerializedName = @"overwrite",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ContentOverwrite { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"ruleGroups",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IRuleGroupContent) })]
        Commvault.Powershell.Models.IRuleGroupContent[] ContentRuleGroups { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"virtualMachines",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IVirtualMachinecontent) })]
        Commvault.Powershell.Models.IVirtualMachinecontent[] ContentVirtualMachines { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if content in vmgroup has to be overwritten, by default it will append the content",
        SerializedName = @"overwrite",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DiskFilterOverwrite { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"rules",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IVMDiskFilter) })]
        Commvault.Powershell.Models.IVMDiskFilter[] DiskFilterRules { get; set; }
        /// <summary>True if file indexing needs to be enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if file indexing needs to be enabled",
        SerializedName = @"enableFileIndexing",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnableFileIndexing { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if content in vmgroup has to be overwritten, by default it will append the content",
        SerializedName = @"overwrite",
        PossibleTypes = new [] { typeof(bool) })]
        bool? FilterOverwrite { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"ruleGroups",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IRuleGroupContent) })]
        Commvault.Powershell.Models.IRuleGroupContent[] FilterRuleGroups { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"virtualMachines",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IVirtualMachinecontent) })]
        Commvault.Powershell.Models.IVirtualMachinecontent[] FilterVirtualMachines { get; set; }
        /// <summary>Meditech Listener IP of FQDN name</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Meditech Listener IP of FQDN name",
        SerializedName = @"listenerIP",
        PossibleTypes = new [] { typeof(string) })]
        string MeditechSystemListenerIP { get; set; }
        /// <summary>Meditech Listener Port</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Meditech Listener Port",
        SerializedName = @"listenerPort",
        PossibleTypes = new [] { typeof(long) })]
        long? MeditechSystemListenerPort { get; set; }
        /// <summary>MBF timeout (in seconds)</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"MBF timeout (in seconds)",
        SerializedName = @"MBFtimeout",
        PossibleTypes = new [] { typeof(long) })]
        long? MeditechSystemMbFtimeout { get; set; }
        /// <summary>Meditech system name</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Meditech system name",
        SerializedName = @"systemName",
        PossibleTypes = new [] { typeof(string) })]
        string MeditechSystemName { get; set; }
        /// <summary>subclient name</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"subclient name ",
        SerializedName = @"newName",
        PossibleTypes = new [] { typeof(string) })]
        string NewName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? PlanId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string PlanName { get; set; }
        /// <summary>Delayed by n Hrs</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Delayed by n Hrs",
        SerializedName = @"delayTime",
        PossibleTypes = new [] { typeof(string) })]
        string RestoreActivityControlOptionDelayTime { get; set; }
        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if the activity will be enabled after a delay time interval",
        SerializedName = @"enableAfterDelay",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RestoreActivityControlOptionEnableAfterDelay { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? RestoreActivityControlOptionsTimeZoneId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string RestoreActivityControlOptionsTimeZoneName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"securityAssociations",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.ISecurityAssoc) })]
        Commvault.Powershell.Models.ISecurityAssoc[] SecurityAssociations { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"settings",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IVMGroupSettings) })]
        Commvault.Powershell.Models.IVMGroupSettings Settings { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? SnapEngineId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string SnapEngineName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? SnapMountProxyId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string SnapMountProxyName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"backupCopyInterface",
        PossibleTypes = new [] { typeof(string) })]
        string SnapshotManagementBackupCopyInterface { get; set; }
        /// <summary>True if hardware snapshot is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if hardware snapshot is enabled",
        SerializedName = @"enableHardwareSnapshot",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotManagementEnableHardwareSnapshot { get; set; }
        /// <summary>True if independent disk option is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if independent disk option is enabled",
        SerializedName = @"isIndependentDisksEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotManagementIsIndependentDisksEnabled { get; set; }
        /// <summary>True if raw device maps option is enabled</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if raw device maps option is enabled",
        SerializedName = @"isRawDeviceMapsEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotManagementIsRawDeviceMapsEnabled { get; set; }
        /// <summary>Name of ESX Host</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Name of ESX Host",
        SerializedName = @"snapMountESXHost",
        PossibleTypes = new [] { typeof(string) })]
        string SnapshotManagementSnapMountEsxHost { get; set; }
        /// <summary>True if separate proxy client is used for snap to tape</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"True if separate proxy client is used for snap to tape",
        SerializedName = @"useSeparateProxyForSnapToTape",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotManagementUseSeparateProxyForSnapToTape { get; set; }
        /// <summary>Virtual machine application user name</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Virtual machine application user name",
        SerializedName = @"vmApplicationUserName",
        PossibleTypes = new [] { typeof(string) })]
        string SnapshotManagementVMApplicationUserName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? StorageId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string StorageName { get; set; }
        /// <summary>username to access the network path</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"username to access the network path",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string UserAccountName { get; set; }
        /// <summary>password to access the network path</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"password to access the network path",
        SerializedName = @"password",
        PossibleTypes = new [] { typeof(string) })]
        string UserAccountPassword { get; set; }

    }
    /// UpdatevmGroupReq
    internal partial interface IUpdatevmGroupReqInternal

    {
        Commvault.Powershell.Models.IIdName[] AccessNode { get; set; }

        Commvault.Powershell.Models.IActivityControlOptions ActivityControl { get; set; }

        Commvault.Powershell.Models.IBackupActivityControlOptionsProp ActivityControlBackupActivityControlOptions { get; set; }
        /// <summary>true if Backup is enabled</summary>
        bool? ActivityControlEnableBackup { get; set; }
        /// <summary>true if Restore is enabled</summary>
        bool? ActivityControlEnableRestore { get; set; }

        Commvault.Powershell.Models.IBackupActivityControlOptionsProp ActivityControlRestoreActivityControlOptions { get; set; }
        /// <summary>vmAppValidation</summary>
        Commvault.Powershell.Models.IVMAppValidation ApplicationValidation { get; set; }
        /// <summary>Delayed by n Hrs</summary>
        string BackupActivityControlOptionDelayTime { get; set; }
        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        bool? BackupActivityControlOptionEnableAfterDelay { get; set; }

        Commvault.Powershell.Models.IIdName BackupActivityControlOptionTimeZone { get; set; }

        long? BackupActivityControlOptionsTimeZoneId { get; set; }

        string BackupActivityControlOptionsTimeZoneName { get; set; }
        /// <summary>RuleContent</summary>
        Commvault.Powershell.Models.IVMContent Content { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        bool? ContentOverwrite { get; set; }

        Commvault.Powershell.Models.IRuleGroupContent[] ContentRuleGroups { get; set; }

        Commvault.Powershell.Models.IVirtualMachinecontent[] ContentVirtualMachines { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        bool? DiskFilterOverwrite { get; set; }

        Commvault.Powershell.Models.IVMDiskFilter[] DiskFilterRules { get; set; }
        /// <summary>vmDiskFilterProp</summary>
        Commvault.Powershell.Models.IVMDiskFilterProp DiskFilters { get; set; }
        /// <summary>True if file indexing needs to be enabled</summary>
        bool? EnableFileIndexing { get; set; }
        /// <summary>
        /// True if content in vmgroup has to be overwritten, by default it will append the content
        /// </summary>
        bool? FilterOverwrite { get; set; }

        Commvault.Powershell.Models.IRuleGroupContent[] FilterRuleGroups { get; set; }

        Commvault.Powershell.Models.IVirtualMachinecontent[] FilterVirtualMachines { get; set; }
        /// <summary>RuleContent</summary>
        Commvault.Powershell.Models.IVMContent Filters { get; set; }
        /// <summary>Meditech Listener IP of FQDN name</summary>
        string MeditechSystemListenerIP { get; set; }
        /// <summary>Meditech Listener Port</summary>
        long? MeditechSystemListenerPort { get; set; }
        /// <summary>MBF timeout (in seconds)</summary>
        long? MeditechSystemMbFtimeout { get; set; }
        /// <summary>Meditech system name</summary>
        string MeditechSystemName { get; set; }

        Commvault.Powershell.Models.IUserNamePassword MeditechSystemUserAccount { get; set; }
        /// <summary>meditechPropResp</summary>
        Commvault.Powershell.Models.IMeditechPropResp MeditechSystems { get; set; }
        /// <summary>subclient name</summary>
        string NewName { get; set; }

        Commvault.Powershell.Models.IIdName Plan { get; set; }

        long? PlanId { get; set; }

        string PlanName { get; set; }
        /// <summary>Delayed by n Hrs</summary>
        string RestoreActivityControlOptionDelayTime { get; set; }
        /// <summary>True if the activity will be enabled after a delay time interval</summary>
        bool? RestoreActivityControlOptionEnableAfterDelay { get; set; }

        Commvault.Powershell.Models.IIdName RestoreActivityControlOptionTimeZone { get; set; }

        long? RestoreActivityControlOptionsTimeZoneId { get; set; }

        string RestoreActivityControlOptionsTimeZoneName { get; set; }

        Commvault.Powershell.Models.ISecurityAssoc[] SecurityAssociations { get; set; }

        Commvault.Powershell.Models.IVMGroupSettings Settings { get; set; }

        long? SnapEngineId { get; set; }

        string SnapEngineName { get; set; }

        long? SnapMountProxyId { get; set; }

        string SnapMountProxyName { get; set; }

        Commvault.Powershell.Models.ISnapCopyInfo SnapshotManagement { get; set; }

        string SnapshotManagementBackupCopyInterface { get; set; }
        /// <summary>True if hardware snapshot is enabled</summary>
        bool? SnapshotManagementEnableHardwareSnapshot { get; set; }
        /// <summary>True if independent disk option is enabled</summary>
        bool? SnapshotManagementIsIndependentDisksEnabled { get; set; }
        /// <summary>True if raw device maps option is enabled</summary>
        bool? SnapshotManagementIsRawDeviceMapsEnabled { get; set; }

        Commvault.Powershell.Models.IIdName SnapshotManagementSnapEngine { get; set; }
        /// <summary>Name of ESX Host</summary>
        string SnapshotManagementSnapMountEsxHost { get; set; }

        Commvault.Powershell.Models.IIdName SnapshotManagementSnapMountProxy { get; set; }
        /// <summary>True if separate proxy client is used for snap to tape</summary>
        bool? SnapshotManagementUseSeparateProxyForSnapToTape { get; set; }
        /// <summary>Virtual machine application user name</summary>
        string SnapshotManagementVMApplicationUserName { get; set; }

        Commvault.Powershell.Models.IIdName Storage { get; set; }

        long? StorageId { get; set; }

        string StorageName { get; set; }
        /// <summary>username to access the network path</summary>
        string UserAccountName { get; set; }
        /// <summary>password to access the network path</summary>
        string UserAccountPassword { get; set; }

    }
}