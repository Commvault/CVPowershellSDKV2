// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.4, generator: @autorest/powershell@3.0.415)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Commvault.Powershell.Models
{
    using static Commvault.Powershell.Runtime.Extensions;

    public partial class UpdateArchivePlan :
        Commvault.Powershell.Models.IUpdateArchivePlan,
        Commvault.Powershell.Models.IUpdateArchivePlanInternal
    {

        /// <summary>Backing field for <see cref="AllowPlanOverride" /> property.</summary>
        private bool? _allowPlanOverride;

        /// <summary>Flag to enable overriding of plan. Once enabled, cannot be disabled.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public bool? AllowPlanOverride { get => this._allowPlanOverride; set => this._allowPlanOverride = value; }

        /// <summary>
        /// After an archive job, replace the file that meets the archiving rules with a stub or delete the file that meets the archiving
        /// rules
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string ArchivingRuleAfterArchiving { get => ((Commvault.Powershell.Models.IArchivePlanArchivingRulesInternal)ArchivingRules).AfterArchiving; set => ((Commvault.Powershell.Models.IArchivePlanArchivingRulesInternal)ArchivingRules).AfterArchiving = value ?? null; }

        /// <summary>
        /// To archive files based on the size of the file, specify the minimum file size in KB.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? ArchivingRuleFileSize { get => ((Commvault.Powershell.Models.IArchivePlanArchivingRulesInternal)ArchivingRules).FileSize; set => ((Commvault.Powershell.Models.IArchivePlanArchivingRulesInternal)ArchivingRules).FileSize = value ?? default(long); }

        /// <summary>
        /// To archive files based on the last accessed or modified date of each file within the folder, specify the number of days.
        /// Should be supplied with fileTimestampMethod.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? ArchivingRuleFileTimestamp { get => ((Commvault.Powershell.Models.IArchivePlanArchivingRulesInternal)ArchivingRules).FileTimestamp; set => ((Commvault.Powershell.Models.IArchivePlanArchivingRulesInternal)ArchivingRules).FileTimestamp = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string ArchivingRuleFileTimestampMethod { get => ((Commvault.Powershell.Models.IArchivePlanArchivingRulesInternal)ArchivingRules).FileTimestampMethod; set => ((Commvault.Powershell.Models.IArchivePlanArchivingRulesInternal)ArchivingRules).FileTimestampMethod = value ?? null; }

        /// <summary>Backing field for <see cref="ArchivingRules" /> property.</summary>
        private Commvault.Powershell.Models.IArchivePlanArchivingRules _archivingRules;

        /// <summary>Files which meet both time stamp and file size rules will be archived</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IArchivePlanArchivingRules ArchivingRules { get => (this._archivingRules = this._archivingRules ?? new Commvault.Powershell.Models.ArchivePlanArchivingRules()); set => this._archivingRules = value; }

        /// <summary>
        /// Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes,
        /// for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? BackupFrequency { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyFrequency; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyFrequency = value ?? default(long); }

        /// <summary>Day on which to run the schedule, applicable for monthly, yearly</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? BackupFrequencyDayOfMonth { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyDayOfMonth; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyDayOfMonth = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string BackupFrequencyDayOfWeek { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyDayOfWeek; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyDayOfWeek = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string BackupFrequencyMonthOfYear { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyMonthOfYear; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyMonthOfYear = value ?? null; }

        /// <summary>schedule frequency type</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string BackupFrequencyScheduleFrequencyType { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyScheduleFrequencyType; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyScheduleFrequencyType = value ?? null; }

        /// <summary>start time of schedule in seconds for daily, weekly, monthly, yearly frequency</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? BackupFrequencyStartTime { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyStartTime; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyStartTime = value ?? default(long); }

        /// <summary>Specific week of a month</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string BackupFrequencyWeekOfMonth { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyWeekOfMonth; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyWeekOfMonth = value ?? null; }

        /// <summary>Days of the week for weekly frequency</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string[] BackupFrequencyWeeklyDays { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyWeeklyDays; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequencyWeeklyDays = value ?? null /* arrayOf */; }

        /// <summary>Internal Acessors for ArchivingRules</summary>
        Commvault.Powershell.Models.IArchivePlanArchivingRules Commvault.Powershell.Models.IUpdateArchivePlanInternal.ArchivingRules { get => (this._archivingRules = this._archivingRules ?? new Commvault.Powershell.Models.ArchivePlanArchivingRules()); set { {_archivingRules = value;} } }

        /// <summary>Internal Acessors for OverrideRestrictions</summary>
        Commvault.Powershell.Models.IArchivePlanOverrideSettings Commvault.Powershell.Models.IUpdateArchivePlanInternal.OverrideRestrictions { get => (this._overrideRestrictions = this._overrideRestrictions ?? new Commvault.Powershell.Models.ArchivePlanOverrideSettings()); set { {_overrideRestrictions = value;} } }

        /// <summary>Internal Acessors for RegionToConfigure</summary>
        Commvault.Powershell.Models.IIdName Commvault.Powershell.Models.IUpdateArchivePlanInternal.RegionToConfigure { get => (this._regionToConfigure = this._regionToConfigure ?? new Commvault.Powershell.Models.IdName()); set { {_regionToConfigure = value;} } }

        /// <summary>Internal Acessors for Rpo</summary>
        Commvault.Powershell.Models.IArchivePlanUpdateRpo Commvault.Powershell.Models.IUpdateArchivePlanInternal.Rpo { get => (this._rpo = this._rpo ?? new Commvault.Powershell.Models.ArchivePlanUpdateRpo()); set { {_rpo = value;} } }

        /// <summary>Internal Acessors for RpoBackupFrequency</summary>
        Commvault.Powershell.Models.IBackupFrequencyPattern Commvault.Powershell.Models.IUpdateArchivePlanInternal.RpoBackupFrequency { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequency; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupFrequency = value; }

        /// <summary>Internal Acessors for RpoSla</summary>
        Commvault.Powershell.Models.ISlaUpdateOptions Commvault.Powershell.Models.IUpdateArchivePlanInternal.RpoSla { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).Sla; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).Sla = value; }

        /// <summary>Backing field for <see cref="NewName" /> property.</summary>
        private string _newName;

        /// <summary>New plan name to update</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        public string NewName { get => this._newName; set => this._newName = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string OverrideRestrictionArchivingRules { get => ((Commvault.Powershell.Models.IArchivePlanOverrideSettingsInternal)OverrideRestrictions).ArchivingRules; set => ((Commvault.Powershell.Models.IArchivePlanOverrideSettingsInternal)OverrideRestrictions).ArchivingRules = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string OverrideRestrictionRpo { get => ((Commvault.Powershell.Models.IArchivePlanOverrideSettingsInternal)OverrideRestrictions).Rpo; set => ((Commvault.Powershell.Models.IArchivePlanOverrideSettingsInternal)OverrideRestrictions).Rpo = value ?? null; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string OverrideRestrictionStoragePool { get => ((Commvault.Powershell.Models.IArchivePlanOverrideSettingsInternal)OverrideRestrictions).StoragePool; set => ((Commvault.Powershell.Models.IArchivePlanOverrideSettingsInternal)OverrideRestrictions).StoragePool = value ?? null; }

        /// <summary>Backing field for <see cref="OverrideRestrictions" /> property.</summary>
        private Commvault.Powershell.Models.IArchivePlanOverrideSettings _overrideRestrictions;

        /// <summary>
        /// To allow the derived plans that use this plan as the base plan to override the settings, property allowPlanOverride must
        /// be true, and then select one of the options for Storage pool, RPO and Archiving rules.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IArchivePlanOverrideSettings OverrideRestrictions { get => (this._overrideRestrictions = this._overrideRestrictions ?? new Commvault.Powershell.Models.ArchivePlanOverrideSettings()); set => this._overrideRestrictions = value; }

        /// <summary>Backing field for <see cref="RegionToConfigure" /> property.</summary>
        private Commvault.Powershell.Models.IIdName _regionToConfigure;

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IIdName RegionToConfigure { get => (this._regionToConfigure = this._regionToConfigure ?? new Commvault.Powershell.Models.IdName()); set => this._regionToConfigure = value; }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? RegionToConfigureId { get => ((Commvault.Powershell.Models.IIdNameInternal)RegionToConfigure).Id; set => ((Commvault.Powershell.Models.IIdNameInternal)RegionToConfigure).Id = value ?? default(long); }

        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string RegionToConfigureName { get => ((Commvault.Powershell.Models.IIdNameInternal)RegionToConfigure).Name; set => ((Commvault.Powershell.Models.IIdNameInternal)RegionToConfigure).Name = value ?? null; }

        /// <summary>Backing field for <see cref="Rpo" /> property.</summary>
        private Commvault.Powershell.Models.IArchivePlanUpdateRpo _rpo;

        /// <summary>
        /// Recovery Point Objective (RPO) is the maximum amount of time that data can be lost during a service disruption. Your RPO
        /// determines the frequency of your backup jobs.
        /// </summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Owned)]
        internal Commvault.Powershell.Models.IArchivePlanUpdateRpo Rpo { get => (this._rpo = this._rpo ?? new Commvault.Powershell.Models.ArchivePlanUpdateRpo()); set => this._rpo = value; }

        /// <summary>Archive job will run only in the specified archive window</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public Commvault.Powershell.Models.IDayAndTime[] RpoBackupWindow { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupWindow; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).BackupWindow = value ?? null /* arrayOf */; }

        /// <summary>Time provided in Unix format. Give 0 to reset any existing delay.</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? SlaEnableAfterDelay { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).SlaEnableAfterDelay; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).SlaEnableAfterDelay = value ?? default(long); }

        /// <summary>Flag to set to exclude plan from SLA</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SlaExcludeFromSla { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).SlaExcludeFromSla; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).SlaExcludeFromSla = value ?? default(bool); }

        /// <summary>Reason for exclusion from SLA</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public string SlaExclusionReason { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).SlaExclusionReason; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).SlaExclusionReason = value ?? null; }

        /// <summary>Database log SLA period in Minutes</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? SlaLogSlaMinutes { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).SlaLogSlaMinutes; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).SlaLogSlaMinutes = value ?? default(long); }

        /// <summary>SLA Period in Days</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public long? SlaPeriod { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).SlaPeriod; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).SlaPeriod = value ?? default(long); }

        /// <summary>Flag to set to use System Default Service Level Agreement</summary>
        [Commvault.Powershell.Origin(Commvault.Powershell.PropertyOrigin.Inlined)]
        public bool? SlaUseSystemDefaultSla { get => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).SlaUseSystemDefaultSla; set => ((Commvault.Powershell.Models.IArchivePlanUpdateRpoInternal)Rpo).SlaUseSystemDefaultSla = value ?? default(bool); }

        /// <summary>Creates an new <see cref="UpdateArchivePlan" /> instance.</summary>
        public UpdateArchivePlan()
        {

        }
    }
    public partial interface IUpdateArchivePlan :
        Commvault.Powershell.Runtime.IJsonSerializable
    {
        /// <summary>Flag to enable overriding of plan. Once enabled, cannot be disabled.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Flag to enable overriding of plan. Once enabled, cannot be disabled.",
        SerializedName = @"allowPlanOverride",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AllowPlanOverride { get; set; }
        /// <summary>
        /// After an archive job, replace the file that meets the archiving rules with a stub or delete the file that meets the archiving
        /// rules
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"After an archive job, replace the file that meets the archiving rules with a stub or delete the file that meets the archiving rules",
        SerializedName = @"afterArchiving",
        PossibleTypes = new [] { typeof(string) })]
        string ArchivingRuleAfterArchiving { get; set; }
        /// <summary>
        /// To archive files based on the size of the file, specify the minimum file size in KB.
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To archive files based on the size of the file, specify the minimum file size in KB.",
        SerializedName = @"fileSize",
        PossibleTypes = new [] { typeof(long) })]
        long? ArchivingRuleFileSize { get; set; }
        /// <summary>
        /// To archive files based on the last accessed or modified date of each file within the folder, specify the number of days.
        /// Should be supplied with fileTimestampMethod.
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To archive files based on the last accessed or modified date of each file within the folder, specify the number of days. Should be supplied with fileTimestampMethod.",
        SerializedName = @"fileTimestamp",
        PossibleTypes = new [] { typeof(long) })]
        long? ArchivingRuleFileTimestamp { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"fileTimestampMethod",
        PossibleTypes = new [] { typeof(string) })]
        string ArchivingRuleFileTimestampMethod { get; set; }
        /// <summary>
        /// Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes,
        /// for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
        /// </summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months",
        SerializedName = @"frequency",
        PossibleTypes = new [] { typeof(long) })]
        long? BackupFrequency { get; set; }
        /// <summary>Day on which to run the schedule, applicable for monthly, yearly</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Day on which to run the schedule, applicable for monthly, yearly",
        SerializedName = @"dayOfMonth",
        PossibleTypes = new [] { typeof(long) })]
        long? BackupFrequencyDayOfMonth { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"dayOfWeek",
        PossibleTypes = new [] { typeof(string) })]
        string BackupFrequencyDayOfWeek { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"monthOfYear",
        PossibleTypes = new [] { typeof(string) })]
        string BackupFrequencyMonthOfYear { get; set; }
        /// <summary>schedule frequency type</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"schedule frequency type",
        SerializedName = @"scheduleFrequencyType",
        PossibleTypes = new [] { typeof(string) })]
        string BackupFrequencyScheduleFrequencyType { get; set; }
        /// <summary>start time of schedule in seconds for daily, weekly, monthly, yearly frequency</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"start time of schedule in seconds for daily, weekly, monthly, yearly frequency",
        SerializedName = @"startTime",
        PossibleTypes = new [] { typeof(long) })]
        long? BackupFrequencyStartTime { get; set; }
        /// <summary>Specific week of a month</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specific week of a month",
        SerializedName = @"weekOfMonth",
        PossibleTypes = new [] { typeof(string) })]
        string BackupFrequencyWeekOfMonth { get; set; }
        /// <summary>Days of the week for weekly frequency</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Days of the week for weekly frequency",
        SerializedName = @"weeklyDays",
        PossibleTypes = new [] { typeof(string) })]
        string[] BackupFrequencyWeeklyDays { get; set; }
        /// <summary>New plan name to update</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"New plan name to update",
        SerializedName = @"newName",
        PossibleTypes = new [] { typeof(string) })]
        string NewName { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"archivingRules",
        PossibleTypes = new [] { typeof(string) })]
        string OverrideRestrictionArchivingRules { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"RPO",
        PossibleTypes = new [] { typeof(string) })]
        string OverrideRestrictionRpo { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"storagePool",
        PossibleTypes = new [] { typeof(string) })]
        string OverrideRestrictionStoragePool { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        long? RegionToConfigureId { get; set; }

        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string RegionToConfigureName { get; set; }
        /// <summary>Archive job will run only in the specified archive window</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Archive job will run only in the specified archive window",
        SerializedName = @"backupWindow",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IDayAndTime) })]
        Commvault.Powershell.Models.IDayAndTime[] RpoBackupWindow { get; set; }
        /// <summary>Time provided in Unix format. Give 0 to reset any existing delay.</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Time provided in Unix format. Give 0 to reset any existing delay.",
        SerializedName = @"enableAfterDelay",
        PossibleTypes = new [] { typeof(long) })]
        long? SlaEnableAfterDelay { get; set; }
        /// <summary>Flag to set to exclude plan from SLA</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Flag to set to exclude plan from SLA",
        SerializedName = @"excludeFromSLA",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SlaExcludeFromSla { get; set; }
        /// <summary>Reason for exclusion from SLA</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Reason for exclusion from SLA",
        SerializedName = @"exclusionReason",
        PossibleTypes = new [] { typeof(string) })]
        string SlaExclusionReason { get; set; }
        /// <summary>Database log SLA period in Minutes</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Database log SLA period in Minutes",
        SerializedName = @"logSLAMinutes",
        PossibleTypes = new [] { typeof(long) })]
        long? SlaLogSlaMinutes { get; set; }
        /// <summary>SLA Period in Days</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SLA Period in Days",
        SerializedName = @"SLAPeriod",
        PossibleTypes = new [] { typeof(long) })]
        long? SlaPeriod { get; set; }
        /// <summary>Flag to set to use System Default Service Level Agreement</summary>
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Flag to set to use System Default Service Level Agreement",
        SerializedName = @"useSystemDefaultSLA",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SlaUseSystemDefaultSla { get; set; }

    }
    internal partial interface IUpdateArchivePlanInternal

    {
        /// <summary>Flag to enable overriding of plan. Once enabled, cannot be disabled.</summary>
        bool? AllowPlanOverride { get; set; }
        /// <summary>
        /// After an archive job, replace the file that meets the archiving rules with a stub or delete the file that meets the archiving
        /// rules
        /// </summary>
        string ArchivingRuleAfterArchiving { get; set; }
        /// <summary>
        /// To archive files based on the size of the file, specify the minimum file size in KB.
        /// </summary>
        long? ArchivingRuleFileSize { get; set; }
        /// <summary>
        /// To archive files based on the last accessed or modified date of each file within the folder, specify the number of days.
        /// Should be supplied with fileTimestampMethod.
        /// </summary>
        long? ArchivingRuleFileTimestamp { get; set; }

        string ArchivingRuleFileTimestampMethod { get; set; }
        /// <summary>Files which meet both time stamp and file size rules will be archived</summary>
        Commvault.Powershell.Models.IArchivePlanArchivingRules ArchivingRules { get; set; }
        /// <summary>
        /// Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes,
        /// for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
        /// </summary>
        long? BackupFrequency { get; set; }
        /// <summary>Day on which to run the schedule, applicable for monthly, yearly</summary>
        long? BackupFrequencyDayOfMonth { get; set; }

        string BackupFrequencyDayOfWeek { get; set; }

        string BackupFrequencyMonthOfYear { get; set; }
        /// <summary>schedule frequency type</summary>
        string BackupFrequencyScheduleFrequencyType { get; set; }
        /// <summary>start time of schedule in seconds for daily, weekly, monthly, yearly frequency</summary>
        long? BackupFrequencyStartTime { get; set; }
        /// <summary>Specific week of a month</summary>
        string BackupFrequencyWeekOfMonth { get; set; }
        /// <summary>Days of the week for weekly frequency</summary>
        string[] BackupFrequencyWeeklyDays { get; set; }
        /// <summary>New plan name to update</summary>
        string NewName { get; set; }

        string OverrideRestrictionArchivingRules { get; set; }

        string OverrideRestrictionRpo { get; set; }

        string OverrideRestrictionStoragePool { get; set; }
        /// <summary>
        /// To allow the derived plans that use this plan as the base plan to override the settings, property allowPlanOverride must
        /// be true, and then select one of the options for Storage pool, RPO and Archiving rules.
        /// </summary>
        Commvault.Powershell.Models.IArchivePlanOverrideSettings OverrideRestrictions { get; set; }

        Commvault.Powershell.Models.IIdName RegionToConfigure { get; set; }

        long? RegionToConfigureId { get; set; }

        string RegionToConfigureName { get; set; }
        /// <summary>
        /// Recovery Point Objective (RPO) is the maximum amount of time that data can be lost during a service disruption. Your RPO
        /// determines the frequency of your backup jobs.
        /// </summary>
        Commvault.Powershell.Models.IArchivePlanUpdateRpo Rpo { get; set; }
        /// <summary>Used to describe the frequency of backup</summary>
        Commvault.Powershell.Models.IBackupFrequencyPattern RpoBackupFrequency { get; set; }
        /// <summary>Archive job will run only in the specified archive window</summary>
        Commvault.Powershell.Models.IDayAndTime[] RpoBackupWindow { get; set; }
        /// <summary>
        /// A server meets SLA (Service Level Agreement) when all of its subclients have at least one successful backup during the
        /// number of days specified at the CommCell, Server Group or plan level.
        /// </summary>
        Commvault.Powershell.Models.ISlaUpdateOptions RpoSla { get; set; }
        /// <summary>Time provided in Unix format. Give 0 to reset any existing delay.</summary>
        long? SlaEnableAfterDelay { get; set; }
        /// <summary>Flag to set to exclude plan from SLA</summary>
        bool? SlaExcludeFromSla { get; set; }
        /// <summary>Reason for exclusion from SLA</summary>
        string SlaExclusionReason { get; set; }
        /// <summary>Database log SLA period in Minutes</summary>
        long? SlaLogSlaMinutes { get; set; }
        /// <summary>SLA Period in Days</summary>
        long? SlaPeriod { get; set; }
        /// <summary>Flag to set to use System Default Service Level Agreement</summary>
        bool? SlaUseSystemDefaultSla { get; set; }

    }
}