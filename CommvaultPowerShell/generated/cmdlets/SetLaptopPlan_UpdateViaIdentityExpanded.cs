// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.8.4, generator: @autorest/powershell@3.0.415)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Commvault.Powershell.Cmdlets
{
    using static Commvault.Powershell.Runtime.Extensions;

    /// <summary>Modify existing laptop plan details</summary>
    /// <remarks>
    /// [OpenAPI] UpdateLaptopPlanById=>PUT:"/V4/LaptopPlan/{planId}"
    /// </remarks>
    [global::System.Management.Automation.Cmdlet(global::System.Management.Automation.VerbsCommon.Set, @"LaptopPlan_UpdateViaIdentityExpanded", SupportsShouldProcess = true)]
    [global::System.Management.Automation.OutputType(typeof(Commvault.Powershell.Models.IGenericResp))]
    [global::Commvault.Powershell.Description(@"Modify existing laptop plan details")]
    [global::Commvault.Powershell.Generated]
    public partial class SetLaptopPlan_UpdateViaIdentityExpanded : global::System.Management.Automation.PSCmdlet,
        Commvault.Powershell.Runtime.IEventListener
    {
        /// <summary>A copy of the Invocation Info (necessary to allow asJob to clone this cmdlet)</summary>
        private global::System.Management.Automation.InvocationInfo __invocationInfo;

        /// <summary>
        /// The <see cref="global::System.Threading.CancellationTokenSource" /> for this operation.
        /// </summary>
        private global::System.Threading.CancellationTokenSource _cancellationTokenSource = new global::System.Threading.CancellationTokenSource();

        /// <summary>.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = ".")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @".",
        SerializedName = @"alerts",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IIdName) })]
        public Commvault.Powershell.Models.IIdName[] Alerts { get => Body.Alerts ?? null /* arrayOf */; set => Body.Alerts = value; }

        /// <summary>Flag to enable overriding of plan</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Flag to enable overriding of plan")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Flag to enable overriding of plan",
        SerializedName = @"allowPlanOverride",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AllowPlanOverride { get => Body.AllowPlanOverride ?? default(global::System.Management.Automation.SwitchParameter); set => Body.AllowPlanOverride = value; }

        /// <summary>Create/modify allowed features of laptop plan</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Create/modify allowed features of laptop plan")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Create/modify allowed features of laptop plan",
        SerializedName = @"allowedFeatures",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.ILaptopPlanAllowedFeatures) })]
        public Commvault.Powershell.Models.ILaptopPlanAllowedFeatures AllowedFeatures { get => Body.AllowedFeatures ?? null /* object */; set => Body.AllowedFeatures = value; }

        /// <summary>.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = ".")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @".",
        SerializedName = @"associatedUsersAndUserGroups",
        PossibleTypes = new [] { typeof(Commvault.Powershell.Models.IPlanUserOrGroups) })]
        public Commvault.Powershell.Models.IPlanUserOrGroups[] AssociatedUsersAndUserGroups { get => Body.AssociatedUsersAndUserGroups ?? null /* arrayOf */; set => Body.AssociatedUsersAndUserGroups = value; }

        /// <summary>
        /// Maximum number of gigabytes that you can store in the File System. Giving value as -1 means infinite file system quota.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Maximum number of gigabytes that you can store in the File System. Giving value as -1 means infinite file system quota.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum number of gigabytes that you can store in the File System. Giving value as -1 means infinite file system quota.",
        SerializedName = @"fileSystemQuota",
        PossibleTypes = new [] { typeof(long) })]
        public long BackupContentFileSystemQuota { get => Body.BackupContentFileSystemQuota ?? default(long); set => Body.BackupContentFileSystemQuota = value; }

        /// <summary>Paths to exclude for Mac</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Paths to exclude for Mac")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Paths to exclude for Mac",
        SerializedName = @"macExcludedPaths",
        PossibleTypes = new [] { typeof(string) })]
        public string[] BackupContentMacExcludedPaths { get => Body.BackupContentMacExcludedPaths ?? null /* arrayOf */; set => Body.BackupContentMacExcludedPaths = value; }

        /// <summary>Paths to include for Mac</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Paths to include for Mac")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Paths to include for Mac",
        SerializedName = @"macIncludedPaths",
        PossibleTypes = new [] { typeof(string) })]
        public string[] BackupContentMacIncludedPaths { get => Body.BackupContentMacIncludedPaths ?? null /* arrayOf */; set => Body.BackupContentMacIncludedPaths = value; }

        /// <summary>Paths to exclude for UNIX</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Paths to exclude for UNIX")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Paths to exclude for UNIX",
        SerializedName = @"unixExcludedPaths",
        PossibleTypes = new [] { typeof(string) })]
        public string[] BackupContentUnixExcludedPaths { get => Body.BackupContentUnixExcludedPaths ?? null /* arrayOf */; set => Body.BackupContentUnixExcludedPaths = value; }

        /// <summary>Paths to include for UNIX</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Paths to include for UNIX")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Paths to include for UNIX",
        SerializedName = @"unixIncludedPaths",
        PossibleTypes = new [] { typeof(string) })]
        public string[] BackupContentUnixIncludedPaths { get => Body.BackupContentUnixIncludedPaths ?? null /* arrayOf */; set => Body.BackupContentUnixIncludedPaths = value; }

        /// <summary>Paths to exclude for Windows</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Paths to exclude for Windows")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Paths to exclude for Windows",
        SerializedName = @"windowsExcludedPaths",
        PossibleTypes = new [] { typeof(string) })]
        public string[] BackupContentWindowsExcludedPaths { get => Body.BackupContentWindowsExcludedPaths ?? null /* arrayOf */; set => Body.BackupContentWindowsExcludedPaths = value; }

        /// <summary>Paths to include for Windows</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Paths to include for Windows")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Paths to include for Windows",
        SerializedName = @"windowsIncludedPaths",
        PossibleTypes = new [] { typeof(string) })]
        public string[] BackupContentWindowsIncludedPaths { get => Body.BackupContentWindowsIncludedPaths ?? null /* arrayOf */; set => Body.BackupContentWindowsIncludedPaths = value; }

        /// <summary>Backing field for <see cref="Body" /> property.</summary>
        private Commvault.Powershell.Models.IUpdateLaptopPlan _body= new Commvault.Powershell.Models.UpdateLaptopPlan();

        private Commvault.Powershell.Models.IUpdateLaptopPlan Body { get => this._body; set => this._body = value; }

        /// <summary>Wait for .NET debugger to attach</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Wait for .NET debugger to attach")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter Break { get; set; }

        /// <summary>The reference to the client API class.</summary>
        public Commvault.Powershell.CommvaultPowerShell Client => Commvault.Powershell.Module.Instance.ClientAPI;

        /// <summary>Custom version rule: Retain daily versions for this many day(s)</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Custom version rule: Retain daily versions for this many day(s)")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Custom version rule: Retain daily versions for this many day(s)",
        SerializedName = @"dailyVersions",
        PossibleTypes = new [] { typeof(long) })]
        public long FileVersionDailyVersions { get => Body.FileVersionDailyVersions ?? default(long); set => Body.FileVersionDailyVersions = value; }

        /// <summary>
        /// Retain files for this many days. Year(s) or month(s) need to be converted to day(s)
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Retain files for this many days. Year(s) or month(s) need to be converted to day(s)")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Retain files for this many days. Year(s) or month(s) need to be converted to day(s)",
        SerializedName = @"days",
        PossibleTypes = new [] { typeof(long) })]
        public long FileVersionDays { get => Body.FileVersionDays ?? default(long); set => Body.FileVersionDays = value; }

        /// <summary>Custom version rule: Retain monthly versions for this many month(s)</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Custom version rule: Retain monthly versions for this many month(s)")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Custom version rule: Retain monthly versions for this many month(s)",
        SerializedName = @"monthlyVersions",
        PossibleTypes = new [] { typeof(long) })]
        public long FileVersionMonthlyVersions { get => Body.FileVersionMonthlyVersions ?? default(long); set => Body.FileVersionMonthlyVersions = value; }

        /// <summary>
        /// Retain this many file versions. This is considered as default if no file retention rule is specified.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Retain this many file versions. This is considered as default if no file retention rule is specified.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Retain this many file versions. This is considered as default if no file retention rule is specified.",
        SerializedName = @"versions",
        PossibleTypes = new [] { typeof(long) })]
        public long FileVersionVersions { get => Body.FileVersionVersions ?? default(long); set => Body.FileVersionVersions = value; }

        /// <summary>Custom version rule: Retain weekly versions for this many week(s)</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Custom version rule: Retain weekly versions for this many week(s)")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Custom version rule: Retain weekly versions for this many week(s)",
        SerializedName = @"weeklyVersions",
        PossibleTypes = new [] { typeof(long) })]
        public long FileVersionWeeklyVersions { get => Body.FileVersionWeeklyVersions ?? default(long); set => Body.FileVersionWeeklyVersions = value; }

        /// <summary>
        /// This feature allows laptops to write backup directly to the cloud storage. It helps to optimize scale by reducing server
        /// dependency and extra data hops. Once the feature is enabled, the existing and the newly-added laptops use optimized backups.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This feature allows laptops to write backup directly to the cloud storage. It helps to optimize scale by reducing server dependency and extra data hops. Once the feature is enabled, the existing and the newly-added laptops use optimized backups.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This feature allows laptops to write backup directly to the cloud storage. It helps to optimize scale by reducing server dependency and extra data hops. Once the feature is enabled, the existing and the newly-added laptops use optimized backups.",
        SerializedName = @"optimizedForCloudBackups",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter GeneralOptimizedForCloudBackups { get => Body.GeneralOptimizedForCloudBackups ?? default(global::System.Management.Automation.SwitchParameter); set => Body.GeneralOptimizedForCloudBackups = value; }

        /// <summary>SendAsync Pipeline Steps to be appended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be appended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Runtime)]
        public Commvault.Powershell.Runtime.SendAsyncStep[] HttpPipelineAppend { get; set; }

        /// <summary>SendAsync Pipeline Steps to be prepended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be prepended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Runtime)]
        public Commvault.Powershell.Runtime.SendAsyncStep[] HttpPipelinePrepend { get; set; }

        /// <summary>Backing field for <see cref="InputObject" /> property.</summary>
        private Commvault.Powershell.Models.ICommvaultPowerShellIdentity _inputObject;

        /// <summary>Identity Parameter</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "Identity Parameter", ValueFromPipeline = true)]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Path)]
        public Commvault.Powershell.Models.ICommvaultPowerShellIdentity InputObject { get => this._inputObject; set => this._inputObject = value; }

        /// <summary>Accessor for our copy of the InvocationInfo.</summary>
        public global::System.Management.Automation.InvocationInfo InvocationInformation { get => __invocationInfo = __invocationInfo ?? this.MyInvocation ; set { __invocationInfo = value; } }

        /// <summary>
        /// <see cref="IEventListener" /> cancellation delegate. Stops the cmdlet when called.
        /// </summary>
        global::System.Action Commvault.Powershell.Runtime.IEventListener.Cancel => _cancellationTokenSource.Cancel;

        /// <summary><see cref="IEventListener" /> cancellation token.</summary>
        global::System.Threading.CancellationToken Commvault.Powershell.Runtime.IEventListener.Token => _cancellationTokenSource.Token;

        /// <summary>
        /// Maximum kilobits per second to throttle the receiving speed of data. Giving value as -1 means infinite throttle send speed
        /// i.e. no limit
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Maximum kilobits per second to throttle the receiving speed of data. Giving value as -1 means infinite throttle send speed i.e. no limit")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum kilobits per second to throttle the receiving speed of data. Giving value as -1 means infinite throttle send speed i.e. no limit",
        SerializedName = @"throttleReceive",
        PossibleTypes = new [] { typeof(long) })]
        public long NetworkResourceThrottleReceive { get => Body.NetworkResourceThrottleReceive ?? default(long); set => Body.NetworkResourceThrottleReceive = value; }

        /// <summary>
        /// Maximum kilobits per second to throttle the emitting speed of data. Giving value as -1 means infinite throttle send speed
        /// i.e. no limit
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Maximum kilobits per second to throttle the emitting speed of data. Giving value as -1 means infinite throttle send speed i.e. no limit")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum kilobits per second to throttle the emitting speed of data. Giving value as -1 means infinite throttle send speed i.e. no limit",
        SerializedName = @"throttleSend",
        PossibleTypes = new [] { typeof(long) })]
        public long NetworkResourceThrottleSend { get => Body.NetworkResourceThrottleSend ?? default(long); set => Body.NetworkResourceThrottleSend = value; }

        /// <summary>New plan name to update</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "New plan name to update")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"New plan name to update",
        SerializedName = @"newName",
        PossibleTypes = new [] { typeof(string) })]
        public string NewName { get => Body.NewName ?? null; set => Body.NewName = value; }

        /// <summary>
        /// The offline laptops are automatically deleted when the number of days are met. -1 means never.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The offline laptops are automatically deleted when the number of days are met. -1 means never.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The offline laptops are automatically deleted when the number of days are met. -1 means never.",
        SerializedName = @"deleteAfterDays",
        PossibleTypes = new [] { typeof(long) })]
        public long OfflineLaptopDeleteAfterDays { get => Body.OfflineLaptopDeleteAfterDays ?? default(long); set => Body.OfflineLaptopDeleteAfterDays = value; }

        /// <summary>
        /// The offline laptops are retired when the number of days are met. -1 means never.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The offline laptops are retired when the number of days are met. -1 means never.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The offline laptops are retired when the number of days are met. -1 means never.",
        SerializedName = @"retireAfterDays",
        PossibleTypes = new [] { typeof(long) })]
        public long OfflineLaptopRetireAfterDays { get => Body.OfflineLaptopRetireAfterDays ?? default(long); set => Body.OfflineLaptopRetireAfterDays = value; }

        /// <summary>.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = ".")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @".",
        SerializedName = @"backupContent",
        PossibleTypes = new [] { typeof(string) })]
        public string OverrideRestrictionBackupContent { get => Body.OverrideRestrictionBackupContent ?? null; set => Body.OverrideRestrictionBackupContent = value; }

        /// <summary>.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = ".")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @".",
        SerializedName = @"retention",
        PossibleTypes = new [] { typeof(string) })]
        public string OverrideRestrictionRetention { get => Body.OverrideRestrictionRetention ?? null; set => Body.OverrideRestrictionRetention = value; }

        /// <summary>.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = ".")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @".",
        SerializedName = @"RPO",
        PossibleTypes = new [] { typeof(string) })]
        public string OverrideRestrictionRpo { get => Body.OverrideRestrictionRpo ?? null; set => Body.OverrideRestrictionRpo = value; }

        /// <summary>.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = ".")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @".",
        SerializedName = @"storagePool",
        PossibleTypes = new [] { typeof(string) })]
        public string OverrideRestrictionStoragePool { get => Body.OverrideRestrictionStoragePool ?? null; set => Body.OverrideRestrictionStoragePool = value; }

        /// <summary>
        /// The instance of the <see cref="Commvault.Powershell.Runtime.HttpPipeline" /> that the remote call will use.
        /// </summary>
        private Commvault.Powershell.Runtime.HttpPipeline Pipeline { get; set; }

        /// <summary>The URI for the proxy server to use</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "The URI for the proxy server to use")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Runtime)]
        public global::System.Uri Proxy { get; set; }

        /// <summary>Credentials for a proxy server to use for the remote call</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Credentials for a proxy server to use for the remote call")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Runtime)]
        public global::System.Management.Automation.PSCredential ProxyCredential { get; set; }

        /// <summary>Use the default credentials for the proxy</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Use the default credentials for the proxy")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter ProxyUseDefaultCredentials { get; set; }

        /// <summary>.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = ".")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @".",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(long) })]
        public long RegionToConfigureId { get => Body.RegionToConfigureId ?? default(long); set => Body.RegionToConfigureId = value; }

        /// <summary>.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = ".")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @".",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        public string RegionToConfigureName { get => Body.RegionToConfigureName ?? null; set => Body.RegionToConfigureName = value; }

        /// <summary>
        /// Amount of days after deletion of files to keep the items. Giving value as -1 means to retain files indefinitely.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Amount of days after deletion of files to keep the items. Giving value as -1 means to retain files indefinitely.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Amount of days after deletion of files to keep the items. Giving value as -1 means to retain files indefinitely.",
        SerializedName = @"deletedItemRetention",
        PossibleTypes = new [] { typeof(long) })]
        public long RetentionDeletedItemRetention { get => Body.RetentionDeletedItemRetention ?? default(long); set => Body.RetentionDeletedItemRetention = value; }

        /// <summary>
        /// Specify incremental backup frequency in minutes. Backup operation will start as per the time zone of the associated server.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specify incremental backup frequency in minutes. Backup operation will start as per the time zone of the associated server.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specify incremental backup frequency in minutes. Backup operation will start as per the time zone of the associated server.",
        SerializedName = @"backupFrequency",
        PossibleTypes = new [] { typeof(long) })]
        public long RpoBackupFrequency { get => Body.RpoBackupFrequency ?? default(long); set => Body.RpoBackupFrequency = value; }

        /// <summary>Time provided in Unix format. Give 0 to reset any existing delay.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Time provided in Unix format. Give 0 to reset any existing delay.")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Time provided in Unix format. Give 0 to reset any existing delay.",
        SerializedName = @"enableAfterDelay",
        PossibleTypes = new [] { typeof(long) })]
        public long SlaEnableAfterDelay { get => Body.SlaEnableAfterDelay ?? default(long); set => Body.SlaEnableAfterDelay = value; }

        /// <summary>Flag to set to exclude plan from SLA</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Flag to set to exclude plan from SLA")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Flag to set to exclude plan from SLA",
        SerializedName = @"excludeFromSLA",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter SlaExcludeFromSla { get => Body.SlaExcludeFromSla ?? default(global::System.Management.Automation.SwitchParameter); set => Body.SlaExcludeFromSla = value; }

        /// <summary>Reason for exclusion from SLA</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Reason for exclusion from SLA")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Reason for exclusion from SLA",
        SerializedName = @"exclusionReason",
        PossibleTypes = new [] { typeof(string) })]
        public string SlaExclusionReason { get => Body.SlaExclusionReason ?? null; set => Body.SlaExclusionReason = value; }

        /// <summary>SLA Period in Days</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "SLA Period in Days")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SLA Period in Days",
        SerializedName = @"SLAPeriod",
        PossibleTypes = new [] { typeof(long) })]
        public long SlaPeriod { get => Body.SlaPeriod ?? default(long); set => Body.SlaPeriod = value; }

        /// <summary>Flag to set to use System Default Service Level Agreement</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Flag to set to use System Default Service Level Agreement")]
        [global::Commvault.Powershell.Category(global::Commvault.Powershell.ParameterCategory.Body)]
        [Commvault.Powershell.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Flag to set to use System Default Service Level Agreement",
        SerializedName = @"useSystemDefaultSLA",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter SlaUseSystemDefaultSla { get => Body.SlaUseSystemDefaultSla ?? default(global::System.Management.Automation.SwitchParameter); set => Body.SlaUseSystemDefaultSla = value; }

        /// <summary>
        /// <c>overrideOnInternalServerError</c> will be called before the regular onInternalServerError has been processed, allowing
        /// customization of what happens on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Commvault.Powershell.Models.IGenericResp" /> from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onInternalServerError method should be processed, or if the
        /// method should return immediately (set to true to skip further processing )</param>

        partial void overrideOnInternalServerError(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// <c>overrideOnNotFound</c> will be called before the regular onNotFound has been processed, allowing customization of what
        /// happens on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Commvault.Powershell.Models.IGenericResp" /> from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onNotFound method should be processed, or if the method should
        /// return immediately (set to true to skip further processing )</param>

        partial void overrideOnNotFound(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// <c>overrideOnOk</c> will be called before the regular onOk has been processed, allowing customization of what happens
        /// on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Commvault.Powershell.Models.IGenericResp" /> from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onOk method should be processed, or if the method should return
        /// immediately (set to true to skip further processing )</param>

        partial void overrideOnOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// (overrides the default BeginProcessing method in global::System.Management.Automation.PSCmdlet)
        /// </summary>
        protected override void BeginProcessing()
        {
            Module.Instance.SetProxyConfiguration(Proxy, ProxyCredential, ProxyUseDefaultCredentials);
            if (Break)
            {
                Commvault.Powershell.Runtime.AttachDebugger.Break();
            }
            ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletBeginProcessing).Wait(); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
        }

        /// <summary>Performs clean-up after the command execution</summary>
        protected override void EndProcessing()
        {
            ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletEndProcessing).Wait(); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
        }

        /// <summary>Handles/Dispatches events during the call to the REST service.</summary>
        /// <param name="id">The message id</param>
        /// <param name="token">The message cancellation token. When this call is cancelled, this should be <c>true</c></param>
        /// <param name="messageData">Detailed message data for the message event.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the message is completed.
        /// </returns>
         async global::System.Threading.Tasks.Task Commvault.Powershell.Runtime.IEventListener.Signal(string id, global::System.Threading.CancellationToken token, global::System.Func<Commvault.Powershell.Runtime.EventData> messageData)
        {
            using( NoSynchronizationContext )
            {
                if (token.IsCancellationRequested)
                {
                    return ;
                }

                switch ( id )
                {
                    case Commvault.Powershell.Runtime.Events.Verbose:
                    {
                        WriteVerbose($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Commvault.Powershell.Runtime.Events.Warning:
                    {
                        WriteWarning($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Commvault.Powershell.Runtime.Events.Information:
                    {
                        var data = messageData();
                        WriteInformation(data, new[] { data.Message });
                        return ;
                    }
                    case Commvault.Powershell.Runtime.Events.Debug:
                    {
                        WriteDebug($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Commvault.Powershell.Runtime.Events.Error:
                    {
                        WriteError(new global::System.Management.Automation.ErrorRecord( new global::System.Exception(messageData().Message), string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null ) );
                        return ;
                    }
                }
                await Commvault.Powershell.Module.Instance.Signal(id, token, messageData, (i,t,m) => ((Commvault.Powershell.Runtime.IEventListener)this).Signal(i,t,()=> Commvault.Powershell.Runtime.EventDataConverter.ConvertFrom( m() ) as Commvault.Powershell.Runtime.EventData ), InvocationInformation, this.ParameterSetName, null );
                if (token.IsCancellationRequested)
                {
                    return ;
                }
                WriteDebug($"{id}: {(messageData().Message ?? global::System.String.Empty)}");
            }
        }

        /// <summary>Performs execution of the command.</summary>
        protected override void ProcessRecord()
        {
            ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletProcessRecordStart).Wait(); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
            try
            {
                // work
                if (ShouldProcess($"Call remote 'UpdateLaptopPlanById' operation"))
                {
                    using( var asyncCommandRuntime = new Commvault.Powershell.Runtime.PowerShell.AsyncCommandRuntime(this, ((Commvault.Powershell.Runtime.IEventListener)this).Token) )
                    {
                        asyncCommandRuntime.Wait( ProcessRecordAsync(),((Commvault.Powershell.Runtime.IEventListener)this).Token);
                    }
                }
            }
            catch (global::System.AggregateException aggregateException)
            {
                // unroll the inner exceptions to get the root cause
                foreach( var innerException in aggregateException.Flatten().InnerExceptions )
                {
                    ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletException, $"{innerException.GetType().Name} - {innerException.Message} : {innerException.StackTrace}").Wait(); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    // Write exception out to error channel.
                    WriteError( new global::System.Management.Automation.ErrorRecord(innerException,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
                }
            }
            catch (global::System.Exception exception) when ((exception as System.Management.Automation.PipelineStoppedException)== null || (exception as System.Management.Automation.PipelineStoppedException).InnerException != null)
            {
                ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletException, $"{exception.GetType().Name} - {exception.Message} : {exception.StackTrace}").Wait(); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                // Write exception out to error channel.
                WriteError( new global::System.Management.Automation.ErrorRecord(exception,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
            }
            finally
            {
                ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletProcessRecordEnd).Wait();
            }
        }

        /// <summary>Performs execution of the command, working asynchronously if required.</summary>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        protected async global::System.Threading.Tasks.Task ProcessRecordAsync()
        {
            using( NoSynchronizationContext )
            {
                await ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletProcessRecordAsyncStart); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                await ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletGetPipeline); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                Pipeline = Commvault.Powershell.Module.Instance.CreatePipeline(InvocationInformation, this.ParameterSetName);
                if (null != HttpPipelinePrepend)
                {
                    Pipeline.Prepend((this.CommandRuntime as Commvault.Powershell.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelinePrepend) ?? HttpPipelinePrepend);
                }
                if (null != HttpPipelineAppend)
                {
                    Pipeline.Append((this.CommandRuntime as Commvault.Powershell.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelineAppend) ?? HttpPipelineAppend);
                }
                // get the client instance
                try
                {
                    await ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletBeforeAPICall); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    // try to call with PATH parameters from Input Object
                    if (null == InputObject.PlanId)
                    {
                        ThrowTerminatingError( new global::System.Management.Automation.ErrorRecord(new global::System.Exception("InputObject has null value for InputObject.PlanId"),string.Empty, global::System.Management.Automation.ErrorCategory.InvalidArgument, InputObject) );
                    }
                    await this.Client.UpdateLaptopPlanById(InputObject.PlanId ?? default(long), Body, onOk, onNotFound, onInternalServerError, this, Pipeline);
                    await ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletAfterAPICall); if( ((Commvault.Powershell.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                }
                catch (Commvault.Powershell.Runtime.UndeclaredResponseException urexception)
                {
                    WriteError(new global::System.Management.Automation.ErrorRecord(urexception, urexception.StatusCode.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new {  body=Body})
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(urexception.Message) { RecommendedAction = urexception.Action }
                    });
                }
                finally
                {
                    await ((Commvault.Powershell.Runtime.IEventListener)this).Signal(Commvault.Powershell.Runtime.Events.CmdletProcessRecordAsyncEnd);
                }
            }
        }

        /// <summary>
        /// Intializes a new instance of the <see cref="SetLaptopPlan_UpdateViaIdentityExpanded" /> cmdlet class.
        /// </summary>
        public SetLaptopPlan_UpdateViaIdentityExpanded()
        {

        }

        /// <summary>Interrupts currently running code within the command.</summary>
        protected override void StopProcessing()
        {
            ((Commvault.Powershell.Runtime.IEventListener)this).Cancel();
            base.StopProcessing();
        }

        /// <summary>
        /// a delegate that is called when the remote service returns 500 (InternalServerError).
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Commvault.Powershell.Models.IGenericResp" /> from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onInternalServerError(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnInternalServerError(responseMessage, response, ref _returnNow);
                // if overrideOnInternalServerError has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // onInternalServerError - response for 500 / application/json
                // (await response) // should be Commvault.Powershell.Models.IGenericResp
                WriteObject((await response));
            }
        }

        /// <summary>a delegate that is called when the remote service returns 404 (NotFound).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Commvault.Powershell.Models.IGenericResp" /> from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onNotFound(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnNotFound(responseMessage, response, ref _returnNow);
                // if overrideOnNotFound has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // onNotFound - response for 404 / application/json
                // (await response) // should be Commvault.Powershell.Models.IGenericResp
                WriteObject((await response));
            }
        }

        /// <summary>a delegate that is called when the remote service returns 200 (OK).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Commvault.Powershell.Models.IGenericResp" /> from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Commvault.Powershell.Models.IGenericResp> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnOk(responseMessage, response, ref _returnNow);
                // if overrideOnOk has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // onOk - response for 200 / application/json
                // (await response) // should be Commvault.Powershell.Models.IGenericResp
                WriteObject((await response));
            }
        }
    }
}