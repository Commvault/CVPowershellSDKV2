
# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Add content to Dynamics 365 app
.Description
Add content to Dynamics 365 app
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IDynamics365ContentReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IDynamics365ContentReq>: Request Message to add content to dynamics 365 app
  [Dynamics365PlanId <Int64?>]: 
  [Dynamics365PlanName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/add-cvd365content
#>
function Add-CVD365Content {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='AddExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Add', Mandatory)]
    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Commvault dynamics 365 app id
    ${AppId},

    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='AddViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Add', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDynamics365ContentReq]
    # Request Message to add content to dynamics 365 app
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='AddExpanded')]
    [Parameter(ParameterSetName='AddViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${Dynamics365PlanId},

    [Parameter(ParameterSetName='AddExpanded')]
    [Parameter(ParameterSetName='AddViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Dynamics365PlanName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Add = 'CommvaultPowershell.private\Add-CVD365Content_Add';
            AddExpanded = 'CommvaultPowershell.private\Add-CVD365Content_AddExpanded';
            AddViaIdentity = 'CommvaultPowershell.private\Add-CVD365Content_AddViaIdentity';
            AddViaIdentityExpanded = 'CommvaultPowershell.private\Add-CVD365Content_AddViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Add Content to Office 365 Exchange Online app
.Description
Add Content to Office 365 Exchange Online app
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IExchangeContentReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IExchangeContentReq>: Request Message to add content to exchange app
  Type <String>: 
  [Office365PlanId <Int64?>]: 
  [Office365PlanName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/add-cvexchangecontent
#>
function Add-CVExchangeContent {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='AddExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Add', Mandatory)]
    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Commvault exchange app id
    ${AppId},

    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='AddViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Add', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IExchangeContentReq]
    # Request Message to add content to exchange app
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Parameter(ParameterSetName='AddViaIdentityExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Type},

    [Parameter(ParameterSetName='AddExpanded')]
    [Parameter(ParameterSetName='AddViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${Office365PlanId},

    [Parameter(ParameterSetName='AddExpanded')]
    [Parameter(ParameterSetName='AddViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Office365PlanName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Add = 'CommvaultPowershell.private\Add-CVExchangeContent_Add';
            AddExpanded = 'CommvaultPowershell.private\Add-CVExchangeContent_AddExpanded';
            AddViaIdentity = 'CommvaultPowershell.private\Add-CVExchangeContent_AddViaIdentity';
            AddViaIdentityExpanded = 'CommvaultPowershell.private\Add-CVExchangeContent_AddViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to add a media agent to a local storage pool access path
.Description
Used to add a media agent to a local storage pool access path
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IAddLocalAccessPath
.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IAddLocalAccessPath>: Used to add a new access path to a backup location
  MediaAgents <IIdName[]>: Can add a list of media agents to be added as the local storage access path.
    [Id <Int64?>]: 
    [Name <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

MEDIAAGENTS <IIdName[]>: Can add a list of media agents to be added as the local storage access path.
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/add-cvlocalaccesspath
#>
function Add-CVLocalAccessPath {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='AddViaIdentity', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Add', Mandatory)]
    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backup location whose details have to be fetched to add a new access path
    ${BackupLocationId},

    [Parameter(ParameterSetName='Add', Mandatory)]
    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the local storage pool whose details have to be fetched to add a new access path
    ${StoragePoolId},

    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='AddViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Add', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAddLocalAccessPath]
    # Used to add a new access path to a backup location
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Parameter(ParameterSetName='AddViaIdentityExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Can add a list of media agents to be added as the local storage access path.
    # To construct, see NOTES section for MEDIAAGENTS properties and create a hash table.
    ${MediaAgents},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Add = 'CommvaultPowershell.private\Add-CVLocalAccessPath_Add';
            AddExpanded = 'CommvaultPowershell.private\Add-CVLocalAccessPath_AddExpanded';
            AddViaIdentity = 'CommvaultPowershell.private\Add-CVLocalAccessPath_AddViaIdentity';
            AddViaIdentityExpanded = 'CommvaultPowershell.private\Add-CVLocalAccessPath_AddViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Put call to consume ma license for a client
.Description
Put call to consume ma license for a client
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/add-cvmediaagentrole
#>
function Add-CVMediaAgentRole {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Add', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Add', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # serverId of the client for which the MA role needs to be added
    ${ServerId},

    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Add = 'CommvaultPowershell.private\Add-CVMediaAgentRole_Add';
            AddViaIdentity = 'CommvaultPowershell.private\Add-CVMediaAgentRole_AddViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to add a media agent to a disk access path
.Description
Used to add a media agent to a disk access path
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IAddDiskAccessPath
.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IAddDiskAccessPath>: Used to add a new access path to a backup location
  MediaAgents <IIdName[]>: Can add a list of media agents to be added as the disk access path.
    [Id <Int64?>]: 
    [Name <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

MEDIAAGENTS <IIdName[]>: Can add a list of media agents to be added as the disk access path.
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/add-cvmediaagent
#>
function Add-CVMediaAgent {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='AddViaIdentity', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Add', Mandatory)]
    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backup location whose details have to be fetched to add a new access path
    ${BackupLocationId},

    [Parameter(ParameterSetName='Add', Mandatory)]
    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the disk storage pool whose details have to be fetched to add a new access path
    ${StoragePoolId},

    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='AddViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Add', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAddDiskAccessPath]
    # Used to add a new access path to a backup location
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Parameter(ParameterSetName='AddViaIdentityExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Can add a list of media agents to be added as the disk access path.
    # To construct, see NOTES section for MEDIAAGENTS properties and create a hash table.
    ${MediaAgents},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Add = 'CommvaultPowershell.private\Add-CVMediaAgent_Add';
            AddExpanded = 'CommvaultPowershell.private\Add-CVMediaAgent_AddExpanded';
            AddViaIdentity = 'CommvaultPowershell.private\Add-CVMediaAgent_AddViaIdentity';
            AddViaIdentityExpanded = 'CommvaultPowershell.private\Add-CVMediaAgent_AddViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Add content to Office 365 OneDrive for Business app
.Description
Add content to Office 365 OneDrive for Business app
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IOnedriveContentReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IOnedriveContentReq>: Request Message to add content to onedrive app
  [Office365PlanId <Int64?>]: 
  [Office365PlanName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/add-cvonedrivecontent
#>
function Add-CVOnedriveContent {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='AddExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Add', Mandatory)]
    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Commvault onedrive app id
    ${AppId},

    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='AddViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Add', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IOnedriveContentReq]
    # Request Message to add content to onedrive app
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='AddExpanded')]
    [Parameter(ParameterSetName='AddViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${Office365PlanId},

    [Parameter(ParameterSetName='AddExpanded')]
    [Parameter(ParameterSetName='AddViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Office365PlanName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Add = 'CommvaultPowershell.private\Add-CVOnedriveContent_Add';
            AddExpanded = 'CommvaultPowershell.private\Add-CVOnedriveContent_AddExpanded';
            AddViaIdentity = 'CommvaultPowershell.private\Add-CVOnedriveContent_AddViaIdentity';
            AddViaIdentityExpanded = 'CommvaultPowershell.private\Add-CVOnedriveContent_AddViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Add content to Office 365 SharePoint Online app
.Description
Add content to Office 365 SharePoint Online app
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ISharepointContentReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISharepointContentReq>: Request Message to add content to sharepoint app
  Type <String>: 
  [Office365PlanId <Int64?>]: 
  [Office365PlanName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/add-cvsharepointcontent
#>
function Add-CVSharepointContent {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='AddExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Add', Mandatory)]
    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Commvault sharepoint app id
    ${AppId},

    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='AddViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Add', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISharepointContentReq]
    # Request Message to add content to sharepoint app
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Parameter(ParameterSetName='AddViaIdentityExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Type},

    [Parameter(ParameterSetName='AddExpanded')]
    [Parameter(ParameterSetName='AddViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${Office365PlanId},

    [Parameter(ParameterSetName='AddExpanded')]
    [Parameter(ParameterSetName='AddViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Office365PlanName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Add = 'CommvaultPowershell.private\Add-CVSharepointContent_Add';
            AddExpanded = 'CommvaultPowershell.private\Add-CVSharepointContent_AddExpanded';
            AddViaIdentity = 'CommvaultPowershell.private\Add-CVSharepointContent_AddViaIdentity';
            AddViaIdentityExpanded = 'CommvaultPowershell.private\Add-CVSharepointContent_AddViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a new software cache
.Description
Create a new software cache
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ISoftwareCacheDetail
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ASSOCIATIONS <IServerOrServerGroupAssociation[]>: List of servers and server groups.
  [Id <Int64?>]: Id of server or server group
  [Name <String>]: Name of server or server group
  [Type <String>]: ServerOrServerGroupTypes

BODY <ISoftwareCacheDetail>: Details of software cache server.
  [Associations <IServerOrServerGroupAssociation[]>]: List of servers and server groups.
    [Id <Int64?>]: Id of server or server group
    [Name <String>]: Name of server or server group
    [Type <String>]: ServerOrServerGroupTypes
  [CacheContents <ISoftwareCacheContent[]>]: List of cache content details of software cache.
    [AdditionalUpdates <String>]: List of additional updates available in software cache
    [OSName <String>]: OS Name of the media available in software cache
    [PackagesInCache <String>]: List of packages available in the software cache
    [Version <String>]: Version of the media available in software cache
  [CacheDirectory <String>]: The software cache directory path where the media will be located
  [CacheId <Int64?>]: 
  [CacheName <String>]: 
  [Configurable <Boolean?>]: Whether the software cache is configurable
  [Enabled <Boolean?>]: Whether the software cache is enabled or not
  [Status <String>]: The status of the software cache for server. Either In Sync or Out of Sync with CommServe cache

CACHECONTENTS <ISoftwareCacheContent[]>: List of cache content details of software cache.
  [AdditionalUpdates <String>]: List of additional updates available in software cache
  [OSName <String>]: OS Name of the media available in software cache
  [PackagesInCache <String>]: List of packages available in the software cache
  [Version <String>]: Version of the media available in software cache
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/add-cvsoftwarecache
#>
function Add-CVSoftwareCache {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='AddExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Add', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISoftwareCacheDetail]
    # Details of software cache server.
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='AddExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IServerOrServerGroupAssociation[]]
    # List of servers and server groups.
    # To construct, see NOTES section for ASSOCIATIONS properties and create a hash table.
    ${Associations},

    [Parameter(ParameterSetName='AddExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISoftwareCacheContent[]]
    # List of cache content details of software cache.
    # To construct, see NOTES section for CACHECONTENTS properties and create a hash table.
    ${CacheContents},

    [Parameter(ParameterSetName='AddExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The software cache directory path where the media will be located
    ${CacheDirectory},

    [Parameter(ParameterSetName='AddExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${CacheId},

    [Parameter(ParameterSetName='AddExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${CacheName},

    [Parameter(ParameterSetName='AddExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Whether the software cache is configurable
    ${Configurable},

    [Parameter(ParameterSetName='AddExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Whether the software cache is enabled or not
    ${Enabled},

    [Parameter(ParameterSetName='AddExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The status of the software cache for server.
    # Either In Sync or Out of Sync with CommServe cache
    ${Status},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Add = 'CommvaultPowershell.private\Add-CVSoftwareCache_Add';
            AddExpanded = 'CommvaultPowershell.private\Add-CVSoftwareCache_AddExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Add content to Office 365 Teams app
.Description
Add content to Office 365 Teams app
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ITeamsContentReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ITeamsContentReq>: Request Message to add content to teams app
  [Office365PlanId <Int64?>]: 
  [Office365PlanName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/add-cvteamcontent
#>
function Add-CVTeamContent {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='AddExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Add', Mandatory)]
    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Commvault teams app id
    ${AppId},

    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='AddViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Add', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='AddViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ITeamsContentReq]
    # Request Message to add content to teams app
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='AddExpanded')]
    [Parameter(ParameterSetName='AddViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${Office365PlanId},

    [Parameter(ParameterSetName='AddExpanded')]
    [Parameter(ParameterSetName='AddViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Office365PlanName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Add = 'CommvaultPowershell.private\Add-CVTeamContent_Add';
            AddExpanded = 'CommvaultPowershell.private\Add-CVTeamContent_AddExpanded';
            AddViaIdentity = 'CommvaultPowershell.private\Add-CVTeamContent_AddViaIdentity';
            AddViaIdentityExpanded = 'CommvaultPowershell.private\Add-CVTeamContent_AddViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Run backups on server plan associated entities
.Description
Run backups on server plan associated entities
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ICreateTaskRespforBackup
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/backup-cvserverplan
#>
function Backup-CVServerPlan {
[OutputType([Commvault.Powershell.Models.ICreateTaskRespforBackup], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Backup', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Backup', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Server Plan
    ${PlanId},

    [Parameter(ParameterSetName='BackupViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Backup level of jobs
    ${BackupLevel},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Backup = 'CommvaultPowershell.private\Backup-CVServerPlan_Backup';
            BackupViaIdentity = 'CommvaultPowershell.private\Backup-CVServerPlan_BackupViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
To Backup the virtual machines in vmgroup
.Description
To Backup the virtual machines in vmgroup
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ICreateTaskRespforBackup
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/backup-cvvmgroup
#>
function Backup-CVVMGroup {
[OutputType([Commvault.Powershell.Models.ICreateTaskRespforBackup], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Backup', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Backup', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the VMgroup to backup
    ${VMGroupId},

    [Parameter(ParameterSetName='BackupViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Backup level , Default :Incremental
    ${BackupLevel},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Backup = 'CommvaultPowershell.private\Backup-CVVMGroup_Backup';
            BackupViaIdentity = 'CommvaultPowershell.private\Backup-CVVMGroup_BackupViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Compare old and new XMl or objects
.Description
Compare old and new XMl or objects
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICompareXmlReq
.Outputs
System.String
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ICompareXmlReq>: This is the data model to compare two objects
  [NewXml <String>]: second xml object in string format
  [OldXml <String>]: first xml object in string format
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/compare-cvxml
#>
function Compare-CVXml {
[OutputType([System.String])]
[CmdletBinding(DefaultParameterSetName='CompareExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Compare', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICompareXmlReq]
    # This is the data model to compare two objects
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='CompareExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # second xml object in string format
    ${NewXml},

    [Parameter(ParameterSetName='CompareExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # first xml object in string format
    ${OldXml},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Compare = 'CommvaultPowershell.private\Compare-CVXml_Compare';
            CompareExpanded = 'CommvaultPowershell.private\Compare-CVXml_CompareExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Download or Copy Software
.Description
Download or Copy Software
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IDownloadOrCopySoftware
.Outputs
System.Int64
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IDownloadOrCopySoftware>: Request body for download or copy software
  [CopyConfigurationDownloadPath <String>]: Path from where the software has to be downloaded.
  [CopyConfigurationPassword <String>]: Corresponding password of the user
  [CopyConfigurationUsername <String>]: If impersonation a user the, give the username of the user.
  [DownloadConfigurationFeatureRelease <String>]: Which specific feature release to download.
  [DownloadConfigurationLatestFixesForCurrentRelease <Boolean?>]: Boolean which determines whether to download latest fixews for current release.
  [DownloadConfigurationUnixDownloadOptions <String[]>]: gives list of all the target unix and MAC operating systems to download software for.
  [DownloadConfigurationUpgradeToLatestRelease <Boolean?>]: Boolean which determines whether to upgrade to latest release.
  [DownloadConfigurationWindowsDownloadOptions <String[]>]: gives list of all the target windows operating systems to download software for.
  [NotifyWhenJobCompletes <Boolean?>]: Boolean which determines whether to notify when software is downloaded or copied.
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/copy-cvsoftware
#>
function Copy-CVSoftware {
[OutputType([System.Int64])]
[CmdletBinding(DefaultParameterSetName='CopyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Copy', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDownloadOrCopySoftware]
    # Request body for download or copy software
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='CopyExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Path from where the software has to be downloaded.
    ${CopyConfigurationDownloadPath},

    [Parameter(ParameterSetName='CopyExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Corresponding password of the user
    ${CopyConfigurationPassword},

    [Parameter(ParameterSetName='CopyExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # If impersonation a user the, give the username of the user.
    ${CopyConfigurationUsername},

    [Parameter(ParameterSetName='CopyExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Which specific feature release to download.
    ${DownloadConfigurationFeatureRelease},

    [Parameter(ParameterSetName='CopyExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean which determines whether to download latest fixews for current release.
    ${DownloadConfigurationLatestFixesForCurrentRelease},

    [Parameter(ParameterSetName='CopyExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # gives list of all the target unix and MAC operating systems to download software for.
    ${DownloadConfigurationUnixDownloadOptions},

    [Parameter(ParameterSetName='CopyExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean which determines whether to upgrade to latest release.
    ${DownloadConfigurationUpgradeToLatestRelease},

    [Parameter(ParameterSetName='CopyExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # gives list of all the target windows operating systems to download software for.
    ${DownloadConfigurationWindowsDownloadOptions},

    [Parameter(ParameterSetName='CopyExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean which determines whether to notify when software is downloaded or copied.
    ${NotifyWhenJobCompletes},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Copy = 'CommvaultPowershell.private\Copy-CVSoftware_Copy';
            CopyExpanded = 'CommvaultPowershell.private\Copy-CVSoftware_CopyExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Disable Alert Definition
.Description
Disable Alert Definition
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvalertdefinition
#>
function Disable-CVAlertDefinition {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVAlertDefinition_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVAlertDefinition_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable auxillary copy property for commcell
.Description
Used to disable auxillary copy property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvauxillarycopycommcell
#>
function Disable-CVAuxillaryCopyCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVAuxillaryCopyCommcell_Disable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable backup property for an agent.\nTypes of available agentIds are:\n41-Active Directory,\n21-AIX File System,\n64-Big Data Apps,\n134-Cloud Apps,\n37-DB2,\n103-DB2 MultiNode,\n62-DB2 on Unix,\n128-Documentum,\n90-Domino Mailbox Archiver,\n91-DPM,\n67-Exchange Compliance Archiver,\n53-Exchange Database,\n45-Exchange Mailbox,\n54-Exchange Mailbox (Classic),\n56-Exchange Mailbox Archiver,\n82-Exchange PF Archiver,\n35-Exchange Public Folder,\n73-File Share Archiver,\n33-File System,\n74-FreeBSD,\n71-GroupWise DB,\n17-HP-UX Files System,\n65-Image Level,\n75-Image Level On Unix,\n76-Image Level ProxyHost,\n87-Image Level ProxyHost on Unix,\n3-Informix Database,\n29-Linux File System,\n89-MS SharePoint Archiver,\n104-MySQL,\n13-NAS,\n83-Netware File Archiver,\n12-Netware File System,\n10-Novell Directory Services,\n124-Object Link,\n131-Object Store,\n86-OES File System on Linux,\n22-Oracle,\n80-Oracle RAC,\n130-Other External Agent,\n125-PostgreSQL,\n38-Proxy Client File System,\n87-ProxyHost on Unix,\n61-SAP for Oracle,\n135-SAP HANA,\n78-SharePoint Server,\n20-Solaris 64bit File System,\n19-Solaris File System,\n81-SQL Server,\n5-Sybase Database,\n66-Unix File Archiver,\n36-Unix Tru64 64-bit File System,\n106-Virtual Server,\n58- Windows File Archiver
.Description
Used to disable backup property for an agent.\nTypes of available agentIds are:\n41-Active Directory,\n21-AIX File System,\n64-Big Data Apps,\n134-Cloud Apps,\n37-DB2,\n103-DB2 MultiNode,\n62-DB2 on Unix,\n128-Documentum,\n90-Domino Mailbox Archiver,\n91-DPM,\n67-Exchange Compliance Archiver,\n53-Exchange Database,\n45-Exchange Mailbox,\n54-Exchange Mailbox (Classic),\n56-Exchange Mailbox Archiver,\n82-Exchange PF Archiver,\n35-Exchange Public Folder,\n73-File Share Archiver,\n33-File System,\n74-FreeBSD,\n71-GroupWise DB,\n17-HP-UX Files System,\n65-Image Level,\n75-Image Level On Unix,\n76-Image Level ProxyHost,\n87-Image Level ProxyHost on Unix,\n3-Informix Database,\n29-Linux File System,\n89-MS SharePoint Archiver,\n104-MySQL,\n13-NAS,\n83-Netware File Archiver,\n12-Netware File System,\n10-Novell Directory Services,\n124-Object Link,\n131-Object Store,\n86-OES File System on Linux,\n22-Oracle,\n80-Oracle RAC,\n130-Other External Agent,\n125-PostgreSQL,\n38-Proxy Client File System,\n87-ProxyHost on Unix,\n61-SAP for Oracle,\n135-SAP HANA,\n78-SharePoint Server,\n20-Solaris 64bit File System,\n19-Solaris File System,\n81-SQL Server,\n5-Sybase Database,\n66-Unix File Archiver,\n36-Unix Tru64 64-bit File System,\n106-Virtual Server,\n58- Windows File Archiver
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvbackupagent
#>
function Disable-CVBackupAgent {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the agent to be modified
    ${AgentId},

    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the server to modify
    ${ServerId},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVBackupAgent_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVBackupAgent_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable backup property for commcell
.Description
Used to disable backup property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvbackupcommcell
#>
function Disable-CVBackupCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVBackupCommcell_Disable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable backup property for an instance
.Description
Used to disable backup property for an instance
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvbackupinstance
#>
function Disable-CVBackupInstance {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the instance to modify
    ${InstanceId},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVBackupInstance_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVBackupInstance_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to Disable backup schedule policies on server plan
.Description
API to Disable backup schedule policies on server plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvbackuponplan
#>
function Disable-CVBackupOnPlan {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Server Plan
    ${PlanId},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVBackupOnPlan_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVBackupOnPlan_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable backup property for a server group
.Description
Used to disable backup property for a server group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvbackupservergroup
#>
function Disable-CVBackupServerGroup {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the serverGroup to modify
    ${ServerGroupId},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVBackupServerGroup_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVBackupServerGroup_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable backup property for server
.Description
Used to disable backup property for server
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvbackupserver
#>
function Disable-CVBackupServer {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Server whose details have to be modified
    ${ServerId},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVBackupServer_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVBackupServer_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable backup property for a subclient
.Description
Used to disable backup property for a subclient
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvbackupsubclient
#>
function Disable-CVBackupSubclient {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the subclient to modify
    ${SubclientId},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVBackupSubclient_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVBackupSubclient_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable content indexing property for commcell
.Description
Used to disable content indexing property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvcontentindexingcommcell
#>
function Disable-CVContentIndexingCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVContentIndexingCommcell_Disable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable data aging property for commcell
.Description
Used to disable data aging property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvdataagingcommcell
#>
function Disable-CVDataAgingCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVDataAgingCommcell_Disable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable data aging property for a server group
.Description
Used to disable data aging property for a server group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvdataagingservergroup
#>
function Disable-CVDataAgingServerGroup {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the serverGroup to modify
    ${ServerGroupId},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVDataAgingServerGroup_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVDataAgingServerGroup_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable Data Aging property for server
.Description
Used to disable Data Aging property for server
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvdataagingserver
#>
function Disable-CVDataAgingServer {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Server whose details have to be modified
    ${ServerId},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVDataAgingServer_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVDataAgingServer_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable data verification property for commcell
.Description
Used to disable data verification property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvdataverificationcommcell
#>
function Disable-CVDataVerificationCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVDataVerificationCommcell_Disable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable DDB property for commcell
.Description
Used to disable DDB property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvddbcommcell
#>
function Disable-CVDdbCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVDdbCommcell_Disable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable all job activity property for commcell
.Description
Used to disable all job activity property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvjobactivitycommcell
#>
function Disable-CVJobActivityCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVJobActivityCommcell_Disable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Disable local authentication for the company
.Description
Disable local authentication for the company
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvlocalauthentication
#>
function Disable-CVLocalAuthentication {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the company
    ${CompanyId},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVLocalAuthentication_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVLocalAuthentication_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable log scrubbing
.Description
Used to disable log scrubbing
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvlogscrubbing
#>
function Disable-CVLogScrubbing {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVLogScrubbing_Disable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API is used to disable maintenance for a storage pool.\nIt will take the libraries associated to storage pool out maintenance mode and if the storage pool is HyperScale, then same would be applied to the nodes associated to the storage pool.\nStorage pool will be marked available for upcoming jobs.
.Description
API is used to disable maintenance for a storage pool.\nIt will take the libraries associated to storage pool out maintenance mode and if the storage pool is HyperScale, then same would be applied to the nodes associated to the storage pool.\nStorage pool will be marked available for upcoming jobs.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvmaintenancestoragepool
#>
function Disable-CVMaintenanceStoragePool {
[OutputType([Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of storage pool
    ${StoragePoolId},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVMaintenanceStoragePool_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVMaintenanceStoragePool_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable restore property for an agent\nTypes of available agentIds are:\n41-Active Directory,\n21-AIX File System,\n64-Big Data Apps,\n134-Cloud Apps,\n37-DB2,\n103-DB2 MultiNode,\n62-DB2 on Unix,\n128-Documentum,\n90-Domino Mailbox Archiver,\n91-DPM,\n67-Exchange Compliance Archiver,\n53-Exchange Database,\n45-Exchange Mailbox,\n54-Exchange Mailbox (Classic),\n56-Exchange Mailbox Archiver,\n82-Exchange PF Archiver,\n35-Exchange Public Folder,\n73-File Share Archiver,\n33-File System,\n74-FreeBSD,\n71-GroupWise DB,\n17-HP-UX Files System,\n65-Image Level,\n75-Image Level On Unix,\n76-Image Level ProxyHost,\n87-Image Level ProxyHost on Unix,\n3-Informix Database,\n29-Linux File System,\n89-MS SharePoint Archiver,\n104-MySQL,\n13-NAS,\n83-Netware File Archiver,\n12-Netware File System,\n10-Novell Directory Services,\n124-Object Link,\n131-Object Store,\n86-OES File System on Linux,\n22-Oracle,\n80-Oracle RAC,\n130-Other External Agent,\n125-PostgreSQL,\n38-Proxy Client File System,\n87-ProxyHost on Unix,\n61-SAP for Oracle,\n135-SAP HANA,\n78-SharePoint Server,\n20-Solaris 64bit File System,\n19-Solaris File System,\n81-SQL Server,\n5-Sybase Database,\n66-Unix File Archiver,\n36-Unix Tru64 64-bit File System,\n106-Virtual Server,\n58- Windows File Archiver
.Description
Used to disable restore property for an agent\nTypes of available agentIds are:\n41-Active Directory,\n21-AIX File System,\n64-Big Data Apps,\n134-Cloud Apps,\n37-DB2,\n103-DB2 MultiNode,\n62-DB2 on Unix,\n128-Documentum,\n90-Domino Mailbox Archiver,\n91-DPM,\n67-Exchange Compliance Archiver,\n53-Exchange Database,\n45-Exchange Mailbox,\n54-Exchange Mailbox (Classic),\n56-Exchange Mailbox Archiver,\n82-Exchange PF Archiver,\n35-Exchange Public Folder,\n73-File Share Archiver,\n33-File System,\n74-FreeBSD,\n71-GroupWise DB,\n17-HP-UX Files System,\n65-Image Level,\n75-Image Level On Unix,\n76-Image Level ProxyHost,\n87-Image Level ProxyHost on Unix,\n3-Informix Database,\n29-Linux File System,\n89-MS SharePoint Archiver,\n104-MySQL,\n13-NAS,\n83-Netware File Archiver,\n12-Netware File System,\n10-Novell Directory Services,\n124-Object Link,\n131-Object Store,\n86-OES File System on Linux,\n22-Oracle,\n80-Oracle RAC,\n130-Other External Agent,\n125-PostgreSQL,\n38-Proxy Client File System,\n87-ProxyHost on Unix,\n61-SAP for Oracle,\n135-SAP HANA,\n78-SharePoint Server,\n20-Solaris 64bit File System,\n19-Solaris File System,\n81-SQL Server,\n5-Sybase Database,\n66-Unix File Archiver,\n36-Unix Tru64 64-bit File System,\n106-Virtual Server,\n58- Windows File Archiver
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvrestoreagent
#>
function Disable-CVRestoreAgent {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the agent to be modified
    ${AgentId},

    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the server to modify
    ${ServerId},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVRestoreAgent_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVRestoreAgent_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable restore property for commcell
.Description
Used to disable restore property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvrestorecommcell
#>
function Disable-CVRestoreCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVRestoreCommcell_Disable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable restore property for an instance
.Description
Used to disable restore property for an instance
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvrestoreinstance
#>
function Disable-CVRestoreInstance {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the instance to modify
    ${InstanceId},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVRestoreInstance_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVRestoreInstance_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable restore property for a server group
.Description
Used to disable restore property for a server group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvrestoreservergroup
#>
function Disable-CVRestoreServerGroup {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the serverGroup to modify
    ${ServerGroupId},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVRestoreServerGroup_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVRestoreServerGroup_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable restore property for server
.Description
Used to disable restore property for server
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvrestoreserver
#>
function Disable-CVRestoreServer {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Server whose details have to be modified
    ${ServerId},

    [Parameter(ParameterSetName='DisableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVRestoreServer_Disable';
            DisableViaIdentity = 'CommvaultPowershell.private\Disable-CVRestoreServer_DisableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to disable scheduler property for commcell
.Description
Used to disable scheduler property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvschedulercommcell
#>
function Disable-CVSchedulerCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Disable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Provide UTC time in unix format.
    ${EnableAfterADelay},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disable = 'CommvaultPowershell.private\Disable-CVSchedulerCommcell_Disable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Edit Alert Definition details
.Description
Edit Alert Definition details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IAlertDefinitionsEdit
.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ASSOCIATIONS <IAlertAssociationIdNameType1[]>: AlertDefinitionsAssociations
  [Id <Int64?>]: id of the associated entity
  [Name <String>]: name of the associated entity
  [ParentEntity1Id <Int64?>]: id of the associated entity
  [ParentEntity1Name <String>]: name of the associated entity
  [ParentEntity1Type <String>]: 
  [ParentEntity2Id <Int64?>]: id of the associated entity
  [ParentEntity2Name <String>]: name of the associated entity
  [ParentEntity2Type <String>]: 
  [ParentEntity3Id <Int64?>]: id of the associated entity
  [ParentEntity3Name <String>]: name of the associated entity
  [ParentEntity3Type <String>]: 
  [ParentEntity4Id <Int64?>]: id of the associated entity
  [ParentEntity4Name <String>]: name of the associated entity
  [ParentEntity4Type <String>]: 
  [Type <String>]: 

BODY <IAlertDefinitionsEdit>: AlertDefinitionsEdit
  [AlertTargetRecipientsOperationType <String>]: Allows adding to, overwriting and deleting existing recipients. default is adding to existing recipients
  [AlertTargetSendAlertTo <String[]>]: 
  [Associations <IAlertAssociationIdNameType1[]>]: AlertDefinitionsAssociations
    [Id <Int64?>]: id of the associated entity
    [Name <String>]: name of the associated entity
    [ParentEntity1Id <Int64?>]: id of the associated entity
    [ParentEntity1Name <String>]: name of the associated entity
    [ParentEntity1Type <String>]: 
    [ParentEntity2Id <Int64?>]: id of the associated entity
    [ParentEntity2Name <String>]: name of the associated entity
    [ParentEntity2Type <String>]: 
    [ParentEntity3Id <Int64?>]: id of the associated entity
    [ParentEntity3Name <String>]: name of the associated entity
    [ParentEntity3Type <String>]: 
    [ParentEntity4Id <Int64?>]: id of the associated entity
    [ParentEntity4Name <String>]: name of the associated entity
    [ParentEntity4Type <String>]: 
    [Type <String>]: 
  [AssociationsOperationType <String>]: Allows adding to, overwriting and deleting existing alert associations. default is adding to existing alert associations
  [LocaleId <Int64?>]: 
  [LocaleName <String>]: 
  [NewName <String>]: The new name of the alert definition
  [RecipientBcc <IAlertTargetIdNameType1[]>]: 
    [Id <Int64?>]: 
    [Name <String>]: 
    [Type <String>]: 
  [RecipientCc <IAlertTargetIdNameType1[]>]: 
  [RecipientTo <IAlertTargetIdNameType1[]>]: 
  [RecipientWebHookId <Int64?>]: id of the webhook to be associated with the alert definition. Only needed incase of webhook notif selected. To get a list of webhooks, use api GET Webhook
  [SendIndividualNotifications <Boolean?>]: 
  [SubscriptionBasedAlert <Boolean?>]: Flag to indicate whether its a subscription based alert.
  [TemplateConsole <String>]: the message template for the console notification
  [TemplateEmail <String>]: the message template for the email notification. Contains both email subject as well as body
  [TemplateEventViewer <String>]: the message template for the event viewer notification
  [TemplateWebhook <String>]: the message template for the webhook notification
  [TokenMatch <String>]: 
  [TokenRuleGroups <ITokenRuleGroup[]>]: List of rule groups
    [Match <String>]: 
    [Rules <ITokenRule[]>]: List of rules
      [DateRangeFromDate <String>]: From date value in unix timestamp format
      [DateRangeTimeRange <ITimeRange[]>]: Time range selection details
        [FromTime <String>]: From time value in unix timestamp format
        [ToTime <String>]: To time value in unix timestamp format
      [DateRangeToDate <String>]: To date value in unix timestamp format
      [MatchCondition <String>]: 
      [RuleSecValue <String>]: Secondary value used for BETWEEN and NOT_BETWEEN matchCondition.
      [TimeRangeFromTime <String>]: From time value in unix timestamp format
      [TimeRangeToTime <String>]: To time value in unix timestamp format
      [TokenFormat <String>]: 
      [TokenName <String>]: Name of the token.
      [Value <String>]: Value to be compared for the token

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

RECIPIENTBCC <IAlertTargetIdNameType1[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
  [Type <String>]: 

RECIPIENTCC <IAlertTargetIdNameType1[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
  [Type <String>]: 

RECIPIENTTO <IAlertTargetIdNameType1[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
  [Type <String>]: 

TOKENRULEGROUPS <ITokenRuleGroup[]>: List of rule groups
  [Match <String>]: 
  [Rules <ITokenRule[]>]: List of rules
    [DateRangeFromDate <String>]: From date value in unix timestamp format
    [DateRangeTimeRange <ITimeRange[]>]: Time range selection details
      [FromTime <String>]: From time value in unix timestamp format
      [ToTime <String>]: To time value in unix timestamp format
    [DateRangeToDate <String>]: To date value in unix timestamp format
    [MatchCondition <String>]: 
    [RuleSecValue <String>]: Secondary value used for BETWEEN and NOT_BETWEEN matchCondition.
    [TimeRangeFromTime <String>]: From time value in unix timestamp format
    [TimeRangeToTime <String>]: To time value in unix timestamp format
    [TokenFormat <String>]: 
    [TokenName <String>]: Name of the token.
    [Value <String>]: Value to be compared for the token
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/edit-cvalertdefinition
#>
function Edit-CVAlertDefinition {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='EditExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Edit', Mandatory)]
    [Parameter(ParameterSetName='EditExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(ParameterSetName='EditViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EditViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Edit', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EditViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAlertDefinitionsEdit]
    # AlertDefinitionsEdit
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Allows adding to, overwriting and deleting existing recipients.
    # default is adding to existing recipients
    ${AlertTargetRecipientsOperationType},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # .
    ${AlertTargetSendAlertTo},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAlertAssociationIdNameType1[]]
    # AlertDefinitionsAssociations
    # To construct, see NOTES section for ASSOCIATIONS properties and create a hash table.
    ${Associations},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Allows adding to, overwriting and deleting existing alert associations.
    # default is adding to existing alert associations
    ${AssociationsOperationType},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${LocaleId},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${LocaleName},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The new name of the alert definition
    ${NewName},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAlertTargetIdNameType1[]]
    # .
    # To construct, see NOTES section for RECIPIENTBCC properties and create a hash table.
    ${RecipientBcc},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAlertTargetIdNameType1[]]
    # .
    # To construct, see NOTES section for RECIPIENTCC properties and create a hash table.
    ${RecipientCc},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAlertTargetIdNameType1[]]
    # .
    # To construct, see NOTES section for RECIPIENTTO properties and create a hash table.
    ${RecipientTo},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # id of the webhook to be associated with the alert definition.
    # Only needed incase of webhook notif selected.
    # To get a list of webhooks, use api GET Webhook
    ${RecipientWebHookId},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${SendIndividualNotifications},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to indicate whether its a subscription based alert.
    ${SubscriptionBasedAlert},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # the message template for the console notification
    ${TemplateConsole},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # the message template for the email notification.
    # Contains both email subject as well as body
    ${TemplateEmail},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # the message template for the event viewer notification
    ${TemplateEventViewer},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # the message template for the webhook notification
    ${TemplateWebhook},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${TokenMatch},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ITokenRuleGroup[]]
    # List of rule groups
    # To construct, see NOTES section for TOKENRULEGROUPS properties and create a hash table.
    ${TokenRuleGroups},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Edit = 'CommvaultPowershell.private\Edit-CVAlertDefinition_Edit';
            EditExpanded = 'CommvaultPowershell.private\Edit-CVAlertDefinition_EditExpanded';
            EditViaIdentity = 'CommvaultPowershell.private\Edit-CVAlertDefinition_EditViaIdentity';
            EditViaIdentityExpanded = 'CommvaultPowershell.private\Edit-CVAlertDefinition_EditViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Editing Array details
.Description
Editing Array details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IEditArray
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ACCESSNODES <IArrayAccessNodes[]>: .
  [DisplayName <String>]: The display name of the corresponding Media Agent
  [Id <Int64?>]: Id of the MediaAgent
  [Name <String>]: Name of the MediaAgent
  [Pruning <Boolean?>]: Enable/Disable pruning of snapshots on the selected Media Agent

BODY <IEditArray>: Request to pass for Edit Array
  [AccessNodes <IArrayAccessNodes[]>]: 
    [DisplayName <String>]: The display name of the corresponding Media Agent
    [Id <Int64?>]: Id of the MediaAgent
    [Name <String>]: Name of the MediaAgent
    [Pruning <Boolean?>]: Enable/Disable pruning of snapshots on the selected Media Agent
  [CredentialPassword <String>]: Base 64 encoded Password to access the array
  [CredentialUserName <String>]: Username to access the array
  [GeneralControlHost <String>]: Host name of the array
  [GeneralDescription <String>]: Description about the Array
  [GeneralFlags <Int64?>]: Flags to be set for array
  [RegionId <Int64?>]: 
  [RegionName <String>]: 
  [RoleId <Int64?>]: 
  [RoleName <String>]: 
  [SavedCredentialId <Int64?>]: 
  [SavedCredentialName <String>]: 
  [SnapConfigurations <IArrayConfigsEdit[]>]: Configurations related to a snap engine
    Flags <Int64>: Flag regarding placement of config in the CC page
    IsUpdated <Boolean>: Whether the config is updated/edited or not
    MasterConfigId <Int64>: This is the masterConfigId, which is available for each vendor's configs
    Name <String>: This is the name of the config which is displayed on the Command Center Console
    Type <Int64>: Type of the config value. type can accept 7 values [1,2,8,10,12,13,14], 1: boolean, 2: integer, 8: text, 10: array[string] are common configs, the rest three are special keys, 12 is for password type key for NetApp E-Series and HPE Nimble, 13 is Private Key for GCP, 14 is a hidden config to select type of Disk for GCP
    [Value <String>]: Takes a single value for all types and for type 14 it holds the id of the selected value from values
    [Values <IIdName[]>]: For type 10 and 14, it can take one or more value of idname type where id by default is 0 for 10. For HPE 3PAR StoreServ, pass MA Id in name field to configure that MA as remote snap MA.
      [Id <Int64?>]: 
      [Name <String>]: 
  [UserGroupId <Int64?>]: 
  [UserGroupName <String>]: 
  [UserId <Int64?>]: 
  [UserName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

SNAPCONFIGURATIONS <IArrayConfigsEdit[]>: Configurations related to a snap engine
  Flags <Int64>: Flag regarding placement of config in the CC page
  IsUpdated <Boolean>: Whether the config is updated/edited or not
  MasterConfigId <Int64>: This is the masterConfigId, which is available for each vendor's configs
  Name <String>: This is the name of the config which is displayed on the Command Center Console
  Type <Int64>: Type of the config value. type can accept 7 values [1,2,8,10,12,13,14], 1: boolean, 2: integer, 8: text, 10: array[string] are common configs, the rest three are special keys, 12 is for password type key for NetApp E-Series and HPE Nimble, 13 is Private Key for GCP, 14 is a hidden config to select type of Disk for GCP
  [Value <String>]: Takes a single value for all types and for type 14 it holds the id of the selected value from values
  [Values <IIdName[]>]: For type 10 and 14, it can take one or more value of idname type where id by default is 0 for 10. For HPE 3PAR StoreServ, pass MA Id in name field to configure that MA as remote snap MA.
    [Id <Int64?>]: 
    [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/edit-cvarray
#>
function Edit-CVArray {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='EditExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Edit', Mandatory)]
    [Parameter(ParameterSetName='EditExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='EditViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EditViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Edit', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EditViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IEditArray]
    # Request to pass for Edit Array
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IArrayAccessNodes[]]
    # .
    # To construct, see NOTES section for ACCESSNODES properties and create a hash table.
    ${AccessNodes},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Base 64 encoded Password to access the array
    ${CredentialPassword},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Username to access the array
    ${CredentialUserName},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Host name of the array
    ${GeneralControlHost},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Description about the Array
    ${GeneralDescription},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Flags to be set for array
    ${GeneralFlags},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RegionId},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RegionName},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RoleId},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RoleName},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SavedCredentialId},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SavedCredentialName},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IArrayConfigsEdit[]]
    # Configurations related to a snap engine
    # To construct, see NOTES section for SNAPCONFIGURATIONS properties and create a hash table.
    ${SnapConfigurations},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${UserGroupId},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${UserGroupName},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${UserId},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${UserName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Edit = 'CommvaultPowershell.private\Edit-CVArray_Edit';
            EditExpanded = 'CommvaultPowershell.private\Edit-CVArray_EditExpanded';
            EditViaIdentity = 'CommvaultPowershell.private\Edit-CVArray_EditViaIdentity';
            EditViaIdentityExpanded = 'CommvaultPowershell.private\Edit-CVArray_EditViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to edit Snap Configurations at Client Level
.Description
API to edit Snap Configurations at Client Level
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ISnapConfigOverrideEditReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISnapConfigOverrideEditReq>: Request Template to edit Snap Config
  [SnapConfigurations <ISnapConfigsOverrideEdit[]>]: 
    Flags <Int64>: Flag regarding placement of config in the CC page
    IsOverridden <Boolean>: whether the config is overridden or not
    MasterConfigId <Int64>: This is the masterConfigId, which is available for each vendors configs
    Name <String>: This is the name of the config which is displayed on the Command Center Console
    Type <Int64>: Type of the config value. type can accept 7 values [1,2,8,10,12,13,14], 1: boolean, 2: integer, 8: text, 10: array[string] are common configs, the rest three are special keys, 12 is for password type key for NetApp E-Series and HPE Nimble, 13 is Private Key for GCP, 14 is a hidden config to select type of Disk for GCP
    [Id <Int64?>]: This is the id of the config which is required during config override
    [IsUpdated <Boolean?>]: Whether the config is updated or not
    [Value <String>]: Value of the config
    [Values <IIdName[]>]: Holds a single value for types except 10, for 10 it holds one or more values. For HPE 3PAR StoreServ, pass MA Id in name field to configure that MA as remote snap MA.
      [Id <Int64?>]: 
      [Name <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

SNAPCONFIGURATIONS <ISnapConfigsOverrideEdit[]>: .
  Flags <Int64>: Flag regarding placement of config in the CC page
  IsOverridden <Boolean>: whether the config is overridden or not
  MasterConfigId <Int64>: This is the masterConfigId, which is available for each vendors configs
  Name <String>: This is the name of the config which is displayed on the Command Center Console
  Type <Int64>: Type of the config value. type can accept 7 values [1,2,8,10,12,13,14], 1: boolean, 2: integer, 8: text, 10: array[string] are common configs, the rest three are special keys, 12 is for password type key for NetApp E-Series and HPE Nimble, 13 is Private Key for GCP, 14 is a hidden config to select type of Disk for GCP
  [Id <Int64?>]: This is the id of the config which is required during config override
  [IsUpdated <Boolean?>]: Whether the config is updated or not
  [Value <String>]: Value of the config
  [Values <IIdName[]>]: Holds a single value for types except 10, for 10 it holds one or more values. For HPE 3PAR StoreServ, pass MA Id in name field to configure that MA as remote snap MA.
    [Id <Int64?>]: 
    [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/edit-cvclientsnapconfig
#>
function Edit-CVClientSnapConfig {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='EditExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Edit', Mandatory)]
    [Parameter(ParameterSetName='EditExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='Edit', Mandatory)]
    [Parameter(ParameterSetName='EditExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ClientId},

    [Parameter(ParameterSetName='EditViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EditViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Edit', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EditViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapConfigOverrideEditReq]
    # Request Template to edit Snap Config
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapConfigsOverrideEdit[]]
    # .
    # To construct, see NOTES section for SNAPCONFIGURATIONS properties and create a hash table.
    ${SnapConfigurations},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Edit = 'CommvaultPowershell.private\Edit-CVClientSnapConfig_Edit';
            EditExpanded = 'CommvaultPowershell.private\Edit-CVClientSnapConfig_EditExpanded';
            EditViaIdentity = 'CommvaultPowershell.private\Edit-CVClientSnapConfig_EditViaIdentity';
            EditViaIdentityExpanded = 'CommvaultPowershell.private\Edit-CVClientSnapConfig_EditViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to edit snap configurations for storage array at copy level
.Description
API to edit snap configurations for storage array at copy level
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ISnapConfigOverrideEditReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISnapConfigOverrideEditReq>: Request Template to edit Snap Config
  [SnapConfigurations <ISnapConfigsOverrideEdit[]>]: 
    Flags <Int64>: Flag regarding placement of config in the CC page
    IsOverridden <Boolean>: whether the config is overridden or not
    MasterConfigId <Int64>: This is the masterConfigId, which is available for each vendors configs
    Name <String>: This is the name of the config which is displayed on the Command Center Console
    Type <Int64>: Type of the config value. type can accept 7 values [1,2,8,10,12,13,14], 1: boolean, 2: integer, 8: text, 10: array[string] are common configs, the rest three are special keys, 12 is for password type key for NetApp E-Series and HPE Nimble, 13 is Private Key for GCP, 14 is a hidden config to select type of Disk for GCP
    [Id <Int64?>]: This is the id of the config which is required during config override
    [IsUpdated <Boolean?>]: Whether the config is updated or not
    [Value <String>]: Value of the config
    [Values <IIdName[]>]: Holds a single value for types except 10, for 10 it holds one or more values. For HPE 3PAR StoreServ, pass MA Id in name field to configure that MA as remote snap MA.
      [Id <Int64?>]: 
      [Name <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

SNAPCONFIGURATIONS <ISnapConfigsOverrideEdit[]>: .
  Flags <Int64>: Flag regarding placement of config in the CC page
  IsOverridden <Boolean>: whether the config is overridden or not
  MasterConfigId <Int64>: This is the masterConfigId, which is available for each vendors configs
  Name <String>: This is the name of the config which is displayed on the Command Center Console
  Type <Int64>: Type of the config value. type can accept 7 values [1,2,8,10,12,13,14], 1: boolean, 2: integer, 8: text, 10: array[string] are common configs, the rest three are special keys, 12 is for password type key for NetApp E-Series and HPE Nimble, 13 is Private Key for GCP, 14 is a hidden config to select type of Disk for GCP
  [Id <Int64?>]: This is the id of the config which is required during config override
  [IsUpdated <Boolean?>]: Whether the config is updated or not
  [Value <String>]: Value of the config
  [Values <IIdName[]>]: Holds a single value for types except 10, for 10 it holds one or more values. For HPE 3PAR StoreServ, pass MA Id in name field to configure that MA as remote snap MA.
    [Id <Int64?>]: 
    [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/edit-cvcopysnapconfig
#>
function Edit-CVCopySnapConfig {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='EditExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Edit', Mandatory)]
    [Parameter(ParameterSetName='EditExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='Edit', Mandatory)]
    [Parameter(ParameterSetName='EditExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${CopyId},

    [Parameter(ParameterSetName='EditViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EditViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Edit', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EditViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapConfigOverrideEditReq]
    # Request Template to edit Snap Config
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapConfigsOverrideEdit[]]
    # .
    # To construct, see NOTES section for SNAPCONFIGURATIONS properties and create a hash table.
    ${SnapConfigurations},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Edit = 'CommvaultPowershell.private\Edit-CVCopySnapConfig_Edit';
            EditExpanded = 'CommvaultPowershell.private\Edit-CVCopySnapConfig_EditExpanded';
            EditViaIdentity = 'CommvaultPowershell.private\Edit-CVCopySnapConfig_EditViaIdentity';
            EditViaIdentityExpanded = 'CommvaultPowershell.private\Edit-CVCopySnapConfig_EditViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to edit Snap configs at a Array level
.Description
API to edit Snap configs at a Array level
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ISnapConfigOverrideEditReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISnapConfigOverrideEditReq>: Request Template to edit Snap Config
  [SnapConfigurations <ISnapConfigsOverrideEdit[]>]: 
    Flags <Int64>: Flag regarding placement of config in the CC page
    IsOverridden <Boolean>: whether the config is overridden or not
    MasterConfigId <Int64>: This is the masterConfigId, which is available for each vendors configs
    Name <String>: This is the name of the config which is displayed on the Command Center Console
    Type <Int64>: Type of the config value. type can accept 7 values [1,2,8,10,12,13,14], 1: boolean, 2: integer, 8: text, 10: array[string] are common configs, the rest three are special keys, 12 is for password type key for NetApp E-Series and HPE Nimble, 13 is Private Key for GCP, 14 is a hidden config to select type of Disk for GCP
    [Id <Int64?>]: This is the id of the config which is required during config override
    [IsUpdated <Boolean?>]: Whether the config is updated or not
    [Value <String>]: Value of the config
    [Values <IIdName[]>]: Holds a single value for types except 10, for 10 it holds one or more values. For HPE 3PAR StoreServ, pass MA Id in name field to configure that MA as remote snap MA.
      [Id <Int64?>]: 
      [Name <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

SNAPCONFIGURATIONS <ISnapConfigsOverrideEdit[]>: .
  Flags <Int64>: Flag regarding placement of config in the CC page
  IsOverridden <Boolean>: whether the config is overridden or not
  MasterConfigId <Int64>: This is the masterConfigId, which is available for each vendors configs
  Name <String>: This is the name of the config which is displayed on the Command Center Console
  Type <Int64>: Type of the config value. type can accept 7 values [1,2,8,10,12,13,14], 1: boolean, 2: integer, 8: text, 10: array[string] are common configs, the rest three are special keys, 12 is for password type key for NetApp E-Series and HPE Nimble, 13 is Private Key for GCP, 14 is a hidden config to select type of Disk for GCP
  [Id <Int64?>]: This is the id of the config which is required during config override
  [IsUpdated <Boolean?>]: Whether the config is updated or not
  [Value <String>]: Value of the config
  [Values <IIdName[]>]: Holds a single value for types except 10, for 10 it holds one or more values. For HPE 3PAR StoreServ, pass MA Id in name field to configure that MA as remote snap MA.
    [Id <Int64?>]: 
    [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/edit-cvsnapconfig
#>
function Edit-CVSnapConfig {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='EditExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Edit', Mandatory)]
    [Parameter(ParameterSetName='EditExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='EditViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EditViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Edit', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EditViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapConfigOverrideEditReq]
    # Request Template to edit Snap Config
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapConfigsOverrideEdit[]]
    # .
    # To construct, see NOTES section for SNAPCONFIGURATIONS properties and create a hash table.
    ${SnapConfigurations},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Edit = 'CommvaultPowershell.private\Edit-CVSnapConfig_Edit';
            EditExpanded = 'CommvaultPowershell.private\Edit-CVSnapConfig_EditExpanded';
            EditViaIdentity = 'CommvaultPowershell.private\Edit-CVSnapConfig_EditViaIdentity';
            EditViaIdentityExpanded = 'CommvaultPowershell.private\Edit-CVSnapConfig_EditViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to edit Snap Configurations at Subclient level
.Description
API to edit Snap Configurations at Subclient level
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ISnapConfigOverrideEditReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISnapConfigOverrideEditReq>: Request Template to edit Snap Config
  [SnapConfigurations <ISnapConfigsOverrideEdit[]>]: 
    Flags <Int64>: Flag regarding placement of config in the CC page
    IsOverridden <Boolean>: whether the config is overridden or not
    MasterConfigId <Int64>: This is the masterConfigId, which is available for each vendors configs
    Name <String>: This is the name of the config which is displayed on the Command Center Console
    Type <Int64>: Type of the config value. type can accept 7 values [1,2,8,10,12,13,14], 1: boolean, 2: integer, 8: text, 10: array[string] are common configs, the rest three are special keys, 12 is for password type key for NetApp E-Series and HPE Nimble, 13 is Private Key for GCP, 14 is a hidden config to select type of Disk for GCP
    [Id <Int64?>]: This is the id of the config which is required during config override
    [IsUpdated <Boolean?>]: Whether the config is updated or not
    [Value <String>]: Value of the config
    [Values <IIdName[]>]: Holds a single value for types except 10, for 10 it holds one or more values. For HPE 3PAR StoreServ, pass MA Id in name field to configure that MA as remote snap MA.
      [Id <Int64?>]: 
      [Name <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

SNAPCONFIGURATIONS <ISnapConfigsOverrideEdit[]>: .
  Flags <Int64>: Flag regarding placement of config in the CC page
  IsOverridden <Boolean>: whether the config is overridden or not
  MasterConfigId <Int64>: This is the masterConfigId, which is available for each vendors configs
  Name <String>: This is the name of the config which is displayed on the Command Center Console
  Type <Int64>: Type of the config value. type can accept 7 values [1,2,8,10,12,13,14], 1: boolean, 2: integer, 8: text, 10: array[string] are common configs, the rest three are special keys, 12 is for password type key for NetApp E-Series and HPE Nimble, 13 is Private Key for GCP, 14 is a hidden config to select type of Disk for GCP
  [Id <Int64?>]: This is the id of the config which is required during config override
  [IsUpdated <Boolean?>]: Whether the config is updated or not
  [Value <String>]: Value of the config
  [Values <IIdName[]>]: Holds a single value for types except 10, for 10 it holds one or more values. For HPE 3PAR StoreServ, pass MA Id in name field to configure that MA as remote snap MA.
    [Id <Int64?>]: 
    [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/edit-cvsubclientsnapconfig
#>
function Edit-CVSubclientSnapConfig {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='EditExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Edit', Mandatory)]
    [Parameter(ParameterSetName='EditExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='Edit', Mandatory)]
    [Parameter(ParameterSetName='EditExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${SubclientId},

    [Parameter(ParameterSetName='EditViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EditViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Edit', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EditViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapConfigOverrideEditReq]
    # Request Template to edit Snap Config
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='EditExpanded')]
    [Parameter(ParameterSetName='EditViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapConfigsOverrideEdit[]]
    # .
    # To construct, see NOTES section for SNAPCONFIGURATIONS properties and create a hash table.
    ${SnapConfigurations},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Edit = 'CommvaultPowershell.private\Edit-CVSubclientSnapConfig_Edit';
            EditExpanded = 'CommvaultPowershell.private\Edit-CVSubclientSnapConfig_EditExpanded';
            EditViaIdentity = 'CommvaultPowershell.private\Edit-CVSubclientSnapConfig_EditViaIdentity';
            EditViaIdentityExpanded = 'CommvaultPowershell.private\Edit-CVSubclientSnapConfig_EditViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Enable Alert Definitions
.Description
Enable Alert Definitions
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvalertdefinition
#>
function Enable-CVAlertDefinition {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVAlertDefinition_Enable';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVAlertDefinition_EnableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable auxillary copy property for commcell
.Description
Used to enable auxillary copy property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvauxillarycopycommcell
#>
function Enable-CVAuxillaryCopyCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVAuxillaryCopyCommcell_Enable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable backup property for an agent\nTypes of available agentIds are:\n41-Active Directory,\n21-AIX File System,\n64-Big Data Apps,\n134-Cloud Apps,\n37-DB2,\n103-DB2 MultiNode,\n62-DB2 on Unix,\n128-Documentum,\n90-Domino Mailbox Archiver,\n91-DPM,\n67-Exchange Compliance Archiver,\n53-Exchange Database,\n45-Exchange Mailbox,\n54-Exchange Mailbox (Classic),\n56-Exchange Mailbox Archiver,\n82-Exchange PF Archiver,\n35-Exchange Public Folder,\n73-File Share Archiver,\n33-File System,\n74-FreeBSD,\n71-GroupWise DB,\n17-HP-UX Files System,\n65-Image Level,\n75-Image Level On Unix,\n76-Image Level ProxyHost,\n87-Image Level ProxyHost on Unix,\n3-Informix Database,\n29-Linux File System,\n89-MS SharePoint Archiver,\n104-MySQL,\n13-NAS,\n83-Netware File Archiver,\n12-Netware File System,\n10-Novell Directory Services,\n124-Object Link,\n131-Object Store,\n86-OES File System on Linux,\n22-Oracle,\n80-Oracle RAC,\n130-Other External Agent,\n125-PostgreSQL,\n38-Proxy Client File System,\n87-ProxyHost on Unix,\n61-SAP for Oracle,\n135-SAP HANA,\n78-SharePoint Server,\n20-Solaris 64bit File System,\n19-Solaris File System,\n81-SQL Server,\n5-Sybase Database,\n66-Unix File Archiver,\n36-Unix Tru64 64-bit File System,\n106-Virtual Server,\n58- Windows File Archiver
.Description
Used to enable backup property for an agent\nTypes of available agentIds are:\n41-Active Directory,\n21-AIX File System,\n64-Big Data Apps,\n134-Cloud Apps,\n37-DB2,\n103-DB2 MultiNode,\n62-DB2 on Unix,\n128-Documentum,\n90-Domino Mailbox Archiver,\n91-DPM,\n67-Exchange Compliance Archiver,\n53-Exchange Database,\n45-Exchange Mailbox,\n54-Exchange Mailbox (Classic),\n56-Exchange Mailbox Archiver,\n82-Exchange PF Archiver,\n35-Exchange Public Folder,\n73-File Share Archiver,\n33-File System,\n74-FreeBSD,\n71-GroupWise DB,\n17-HP-UX Files System,\n65-Image Level,\n75-Image Level On Unix,\n76-Image Level ProxyHost,\n87-Image Level ProxyHost on Unix,\n3-Informix Database,\n29-Linux File System,\n89-MS SharePoint Archiver,\n104-MySQL,\n13-NAS,\n83-Netware File Archiver,\n12-Netware File System,\n10-Novell Directory Services,\n124-Object Link,\n131-Object Store,\n86-OES File System on Linux,\n22-Oracle,\n80-Oracle RAC,\n130-Other External Agent,\n125-PostgreSQL,\n38-Proxy Client File System,\n87-ProxyHost on Unix,\n61-SAP for Oracle,\n135-SAP HANA,\n78-SharePoint Server,\n20-Solaris 64bit File System,\n19-Solaris File System,\n81-SQL Server,\n5-Sybase Database,\n66-Unix File Archiver,\n36-Unix Tru64 64-bit File System,\n106-Virtual Server,\n58- Windows File Archiver
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvbackupagent
#>
function Enable-CVBackupAgent {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the agent to be modified
    ${AgentId},

    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the server to modify
    ${ServerId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVBackupAgent_Enable';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVBackupAgent_EnableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable backup property for commcell
.Description
Used to enable backup property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvbackupcommcell
#>
function Enable-CVBackupCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVBackupCommcell_Enable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable backup property for an instance
.Description
Used to enable backup property for an instance
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvbackupinstance
#>
function Enable-CVBackupInstance {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the instance to modify
    ${InstanceId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVBackupInstance_Enable';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVBackupInstance_EnableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to Enable backup schedule policies on server plan
.Description
API to Enable backup schedule policies on server plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvbackuponplan
#>
function Enable-CVBackupOnPlan {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Server Plan
    ${PlanId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVBackupOnPlan_Enable';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVBackupOnPlan_EnableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable backup property for a server group
.Description
Used to enable backup property for a server group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvbackupservergroup
#>
function Enable-CVBackupServerGroup {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the serverGroup to modify
    ${ServerGroupId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVBackupServerGroup_Enable';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVBackupServerGroup_EnableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable backup property for Server
.Description
Used to enable backup property for Server
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvbackupserver
#>
function Enable-CVBackupServer {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Server whose details have to be modified
    ${ServerId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVBackupServer_Enable';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVBackupServer_EnableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable backup property for an subclient
.Description
Used to enable backup property for an subclient
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvbackupsubclient
#>
function Enable-CVBackupSubclient {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the subclient to modify
    ${SubclientId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVBackupSubclient_Enable';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVBackupSubclient_EnableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable content indexing property for commcell
.Description
Used to enable content indexing property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvcontentindexingcommcell
#>
function Enable-CVContentIndexingCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVContentIndexingCommcell_Enable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable data aging property for commcell
.Description
Used to enable data aging property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvdataagingcommcell
#>
function Enable-CVDataAgingCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVDataAgingCommcell_Enable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable data aging property for a server group
.Description
Used to enable data aging property for a server group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvdataagingservergroup
#>
function Enable-CVDataAgingServerGroup {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the serverGroup to modify
    ${ServerGroupId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVDataAgingServerGroup_Enable';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVDataAgingServerGroup_EnableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable Data Aging property for Server
.Description
Used to enable Data Aging property for Server
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvdataagingserver
#>
function Enable-CVDataAgingServer {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Server whose details have to be modified
    ${ServerId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVDataAgingServer_Enable';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVDataAgingServer_EnableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable data verification property for commcell
.Description
Used to enable data verification property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvdataverificationcommcell
#>
function Enable-CVDataVerificationCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVDataVerificationCommcell_Enable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable DDB property for commcell
.Description
Used to enable DDB property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvddbcommcell
#>
function Enable-CVDdbCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVDdbCommcell_Enable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable all job activity property for commcell
.Description
Used to enable all job activity property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvjobactivity
#>
function Enable-CVJobActivity {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVJobActivity_Enable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Enable local authentication for the company
.Description
Enable local authentication for the company
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ILocalAuthenticationDetails
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ILocalAuthenticationDetails>: Local authentication can be enabled for all users or specific user groups or completely disabled.
  [Mode <String>]: 
  [UserGroups <IIdName[]>]: 
    [Id <Int64?>]: 
    [Name <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

USERGROUPS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvlocalauthentication
#>
function Enable-CVLocalAuthentication {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='EnableExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Parameter(ParameterSetName='EnableExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the company
    ${CompanyId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EnableViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Enable', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ILocalAuthenticationDetails]
    # Local authentication can be enabled for all users or specific user groups or completely disabled.
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='EnableExpanded')]
    [Parameter(ParameterSetName='EnableViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Mode},

    [Parameter(ParameterSetName='EnableExpanded')]
    [Parameter(ParameterSetName='EnableViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for USERGROUPS properties and create a hash table.
    ${UserGroups},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVLocalAuthentication_Enable';
            EnableExpanded = 'CommvaultPowershell.private\Enable-CVLocalAuthentication_EnableExpanded';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVLocalAuthentication_EnableViaIdentity';
            EnableViaIdentityExpanded = 'CommvaultPowershell.private\Enable-CVLocalAuthentication_EnableViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable log scrubbing
.Description
Used to enable log scrubbing
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvlogscrubbing
#>
function Enable-CVLogScrubbing {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVLogScrubbing_Enable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API is used to enable maintenance for a storage pool.\nIt will put the libraries associated to storage pool in maintenance mode and if the storage pool is HyperScale, then same would be applied to the nodes associated to the storage pool.\nWhen a storage pool is in maintenance, it will not be used by any upcoming jobs.
.Description
API is used to enable maintenance for a storage pool.\nIt will put the libraries associated to storage pool in maintenance mode and if the storage pool is HyperScale, then same would be applied to the nodes associated to the storage pool.\nWhen a storage pool is in maintenance, it will not be used by any upcoming jobs.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvmaintenancestoragepool
#>
function Enable-CVMaintenanceStoragePool {
[OutputType([Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of storage pool
    ${StoragePoolId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Suspend the jobs running to the storage pool
    ${SuspendRunningJobs},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVMaintenanceStoragePool_Enable';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVMaintenanceStoragePool_EnableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable restore property for an agent\nTypes of available agentIds are:\n41-Active Directory,\n21-AIX File System,\n64-Big Data Apps,\n134-Cloud Apps,\n37-DB2,\n103-DB2 MultiNode,\n62-DB2 on Unix,\n128-Documentum,\n90-Domino Mailbox Archiver,\n91-DPM,\n67-Exchange Compliance Archiver,\n53-Exchange Database,\n45-Exchange Mailbox,\n54-Exchange Mailbox (Classic),\n56-Exchange Mailbox Archiver,\n82-Exchange PF Archiver,\n35-Exchange Public Folder,\n73-File Share Archiver,\n33-File System,\n74-FreeBSD,\n71-GroupWise DB,\n17-HP-UX Files System,\n65-Image Level,\n75-Image Level On Unix,\n76-Image Level ProxyHost,\n87-Image Level ProxyHost on Unix,\n3-Informix Database,\n29-Linux File System,\n89-MS SharePoint Archiver,\n104-MySQL,\n13-NAS,\n83-Netware File Archiver,\n12-Netware File System,\n10-Novell Directory Services,\n124-Object Link,\n131-Object Store,\n86-OES File System on Linux,\n22-Oracle,\n80-Oracle RAC,\n130-Other External Agent,\n125-PostgreSQL,\n38-Proxy Client File System,\n87-ProxyHost on Unix,\n61-SAP for Oracle,\n135-SAP HANA,\n78-SharePoint Server,\n20-Solaris 64bit File System,\n19-Solaris File System,\n81-SQL Server,\n5-Sybase Database,\n66-Unix File Archiver,\n36-Unix Tru64 64-bit File System,\n106-Virtual Server,\n58- Windows File Archiver
.Description
Used to enable restore property for an agent\nTypes of available agentIds are:\n41-Active Directory,\n21-AIX File System,\n64-Big Data Apps,\n134-Cloud Apps,\n37-DB2,\n103-DB2 MultiNode,\n62-DB2 on Unix,\n128-Documentum,\n90-Domino Mailbox Archiver,\n91-DPM,\n67-Exchange Compliance Archiver,\n53-Exchange Database,\n45-Exchange Mailbox,\n54-Exchange Mailbox (Classic),\n56-Exchange Mailbox Archiver,\n82-Exchange PF Archiver,\n35-Exchange Public Folder,\n73-File Share Archiver,\n33-File System,\n74-FreeBSD,\n71-GroupWise DB,\n17-HP-UX Files System,\n65-Image Level,\n75-Image Level On Unix,\n76-Image Level ProxyHost,\n87-Image Level ProxyHost on Unix,\n3-Informix Database,\n29-Linux File System,\n89-MS SharePoint Archiver,\n104-MySQL,\n13-NAS,\n83-Netware File Archiver,\n12-Netware File System,\n10-Novell Directory Services,\n124-Object Link,\n131-Object Store,\n86-OES File System on Linux,\n22-Oracle,\n80-Oracle RAC,\n130-Other External Agent,\n125-PostgreSQL,\n38-Proxy Client File System,\n87-ProxyHost on Unix,\n61-SAP for Oracle,\n135-SAP HANA,\n78-SharePoint Server,\n20-Solaris 64bit File System,\n19-Solaris File System,\n81-SQL Server,\n5-Sybase Database,\n66-Unix File Archiver,\n36-Unix Tru64 64-bit File System,\n106-Virtual Server,\n58- Windows File Archiver
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvrestoreagent
#>
function Enable-CVRestoreAgent {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the agent to be modified
    ${AgentId},

    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the server to modify
    ${ServerId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVRestoreAgent_Enable';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVRestoreAgent_EnableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable restore property for commcell
.Description
Used to enable restore property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvrestorecommcell
#>
function Enable-CVRestoreCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVRestoreCommcell_Enable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable restore property for an instance
.Description
Used to enable restore property for an instance
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvrestoreinstance
#>
function Enable-CVRestoreInstance {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the instance to modify
    ${InstanceId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVRestoreInstance_Enable';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVRestoreInstance_EnableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable restore property for a server group
.Description
Used to enable restore property for a server group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvrestoreservergroup
#>
function Enable-CVRestoreServerGroup {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the serverGroup to modify
    ${ServerGroupId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVRestoreServerGroup_Enable';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVRestoreServerGroup_EnableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable restore property for Server
.Description
Used to enable restore property for Server
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvrestoreserver
#>
function Enable-CVRestoreServer {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Server whose details have to be modified
    ${ServerId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVRestoreServer_Enable';
            EnableViaIdentity = 'CommvaultPowershell.private\Enable-CVRestoreServer_EnableViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to enable scheduler property for commcell
.Description
Used to enable scheduler property for commcell
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvschedulercommcell
#>
function Enable-CVSchedulerCommcell {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Enable', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Enable = 'CommvaultPowershell.private\Enable-CVSchedulerCommcell_Enable';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Gets owner permissions and laptop ownership details
.Description
Gets owner permissions and laptop ownership details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IAccessControl
.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvaccesscontrol
#>
function Get-CVAccessControl {
[OutputType([Commvault.Powershell.Models.IAccessControl], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVAccessControl_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Endpoint to get the list of access nodes
.Description
Endpoint to get the list of access nodes
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IAccessNodeInfo
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvaccessnode
#>
function Get-CVAccessNode {
[OutputType([Commvault.Powershell.Models.IAccessNodeInfo])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # user id to be filtered
    ${UserId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Vendor Name to be filtered
    ${Vendor},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVAccessNode_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get Azure and OnPrem Active Directory clients with their file system state
.Description
Get Azure and OnPrem Active Directory clients with their file system state
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IActiveDirectoryClientsV2Resp
.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvactivedirectoryclientv2
#>
function Get-CVActiveDirectoryClientV2 {
[OutputType([Commvault.Powershell.Models.IActiveDirectoryClientsV2Resp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVActiveDirectoryClientV2_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get detail of the AD/LDAP domain
.Description
Get detail of the AD/LDAP domain
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IAdldapDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvadldapdetail
#>
function Get-CVAdldapDetail {
[OutputType([Commvault.Powershell.Models.IAdldapDetails])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the AD/LDAP domain
    ${DomainId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVAdldapDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVAdldapDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get aggregate count of entity
.Description
Get aggregate count of entity
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGroupByAggregationValue
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvaggregateonentity
#>
function Get-CVAggregateOnEntity {
[OutputType([Commvault.Powershell.Models.IGroupByAggregationValue])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # name of global search entity
    ${GlobalSearchEntity},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # aggregation function to be applied.
    ${Func},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # attribute on which aggregation function would be applied.
    ${AggregateOn},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Filter criteria to filter out global search entities
    ${Fq},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # comma-separated list of entity response attributes based on which aggregate results would be grouped
    ${GroupBy},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVAggregateOnEntity_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVAggregateOnEntity_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of alert definition
.Description
Get details of alert definition
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IAlertDefinitionsDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvalertdefinitiondetail
#>
function Get-CVAlertDefinitionDetail {
[OutputType([Commvault.Powershell.Models.IAlertDefinitionsDetails])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${AdditionalProperties},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVAlertDefinitionDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVAlertDefinitionDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the list of Alert Definitions
.Description
Get the list of Alert Definitions
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IAlertDefinition
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvalertdefinitionlist
#>
function Get-CVAlertDefinitionList {
[OutputType([Commvault.Powershell.Models.IAlertDefinition])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # To get extra meta data details for the api
    ${AdditionalProperties},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVAlertDefinitionList_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get List Of Alerts Triggered
.Description
Get List Of Alerts Triggered
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IAlertsTriggeredListResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvalerttriggered
#>
function Get-CVAlertTriggered {
[OutputType([Commvault.Powershell.Models.IAlertsTriggeredListResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVAlertTriggered_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get various anomalous conditions like events, jobs, offline clients, high CPU and memory loaded clients
.Description
Get various anomalous conditions like events, jobs, offline clients, high CPU and memory loaded clients
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IAnomalousConditionInfo
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvanomalouscondition
#>
function Get-CVAnomalouSCondition {
[OutputType([Commvault.Powershell.Models.IAnomalousConditionInfo])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # unix time stamp denotes from which the anomalous events should be retrieved
    ${FromTime},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVAnomalouSCondition_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get details of a Kubernetes application group with applicationGroupId
.Description
API to get details of a Kubernetes application group with applicationGroupId
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGetApplicationGroupDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvapplicationgroupdetail
#>
function Get-CVApplicationGroupDetail {
[OutputType([Commvault.Powershell.Models.IGetApplicationGroupDetails])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # applicationGroupId is the ID of the Kubernetes application group
    ${ApplicationGroupId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVApplicationGroupDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVApplicationGroupDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the details of all applicationGroups
.Description
Get the details of all applicationGroups
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IApplicationGroupListResp
.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvapplicationgroup
#>
function Get-CVAPplicationGroup {
[OutputType([Commvault.Powershell.Models.IApplicationGroupListResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Id of the hypervisor to list application groups
    ${ClusterId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVAPplicationGroup_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get Backup Destinations for a Plan
.Description
Get Backup Destinations for a Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IArchivePlanBackupDestinations
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvarchivebackupdestination
#>
function Get-CVArchiveBackupDestination {
[OutputType([Commvault.Powershell.Models.IArchivePlanBackupDestinations])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Archive Plan to retrieve backup destinations
    ${PlanId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVArchiveBackupDestination_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVArchiveBackupDestination_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint is used to return the list of Archive file servers.
.Description
This endpoint is used to return the list of Archive file servers.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IFileServerSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvarchivefileserver
#>
function Get-CVArchiveFileServer {
[OutputType([Commvault.Powershell.Models.IFileServerSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVArchiveFileServer_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get Archive Plan details
.Description
Get Archive Plan details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IArchivePlanDetails
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvarchiveplan
#>
function Get-CVArchivePlan {
[OutputType([Commvault.Powershell.Models.IArchivePlanDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the plan
    ${PlanId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVArchivePlan_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVArchivePlan_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Getting Array Details
.Description
Getting Array Details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IArrayDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvarraydetail
#>
function Get-CVArrayDetail {
[OutputType([Commvault.Powershell.Models.IArrayDetails])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVArrayDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVArrayDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get Array Replication Pair information
.Description
Get Array Replication Pair information
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IArrayReplicationMonitorInfo
.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvarrayreplicationmonitor
#>
function Get-CVArrayReplicationMonitor {
[OutputType([Commvault.Powershell.Models.IArrayReplicationMonitorInfo], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # The ID of the failover group associated to array replication pairs
    ${FailoverGroupId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # The ID of the array replication pair
    ${ReplicationId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVArrayReplicationMonitor_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get all storage arrays.
.Description
Get all storage arrays.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IArrayLevel
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvarray
#>
function Get-CVArray {
[OutputType([Commvault.Powershell.Models.IArrayLevel])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVArray_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get list of association for a company
.Description
API to get list of association for a company
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IIdName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvassociation
#>
function Get-CVAssociation {
[OutputType([Commvault.Powershell.Models.IIdName])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Company whose associations have to be fetched
    ${CompanyId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVAssociation_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVAssociation_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Fetch details of a backup destination.\n
.Description
Fetch details of a backup destination.\n
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IBackupDestination
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvbackupdestinationdetailwithoutplaninfo
#>
function Get-CVBackupDestinationDetailWithoutPlanInfo {
[OutputType([Commvault.Powershell.Models.IBackupDestination])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backupDestination for which details will be fetched.
    ${BackupDestinationId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVBackupDestinationDetailWithoutPlanInfo_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVBackupDestinationDetailWithoutPlanInfo_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get specific backup destination details for a server plan
.Description
Get specific backup destination details for a server plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IPlanBackupDestinationDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvbackupdestinationdetail
#>
function Get-CVBackupDestinationDetail {
[OutputType([Commvault.Powershell.Models.IPlanBackupDestinationDetails])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backup destination
    ${BackupDestinationId},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the plan to retrieve backup destination
    ${PlanId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVBackupDestinationDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVBackupDestinationDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get Backup Destinations for a Plan
.Description
Get Backup Destinations for a Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IPlanBackupDestinations
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvbackupdestination
#>
function Get-CVBackupDestination {
[OutputType([Commvault.Powershell.Models.IPlanBackupDestinations])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to retrieve backup destinations
    ${PlanId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVBackupDestination_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVBackupDestination_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to fetch mount path details of the disk storage pool
.Description
Used to fetch mount path details of the disk storage pool
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IBackupLocationDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvbackuplocationdetail
#>
function Get-CVBackupLocationDetail {
[OutputType([Commvault.Powershell.Models.IBackupLocationDetails])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backup location whose details have to be fetched
    ${BackupLocationId},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the disk storage pool whose details have to be fetched
    ${StoragePoolId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVBackupLocationDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVBackupLocationDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint is used to return the list of big data apps.
.Description
This endpoint is used to return the list of big data apps.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IBigDataAppSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvbigdatalist
#>
function Get-CVBigDataList {
[OutputType([Commvault.Powershell.Models.IBigDataAppSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVBigDataList_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of a blackout window based on id
.Description
Get details of a blackout window based on id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IBlackoutWindow
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvblackoutwindowdetail
#>
function Get-CVBlackoutWindowDetail {
[OutputType([Commvault.Powershell.Models.IBlackoutWindow])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Blackout Window whose details have to be fetched
    ${BlackoutWindowId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVBlackoutWindowDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVBlackoutWindowDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get All Blackout Windows
.Description
Get All Blackout Windows
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Int64
.Inputs
System.String
.Outputs
Commvault.Powershell.Models.IBlackoutWindowSummary
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvblackoutwindow
#>
function Get-CVBlackoutWindow {
[OutputType([Commvault.Powershell.Models.IBlackoutWindowSummary], [System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByList', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Shows blackout windows associated with the commcell whose id has been provided.
    ${CommcellId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Shows blackout windows associated with the company whose id has been provided.
    ${CompanyId},

    [Parameter(ParameterSetName='Get')]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Shows blackout windows associated with the server group whose id has been provided.
    ${ServerGroupId},

    [Parameter(ParameterSetName='Get')]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Shows blackout window at commcell level if set to true.
    ${ShowOnlyCommcellLevel},

    [Parameter(ParameterSetName='ByList', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Parameter(ParameterSetName='ByName', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Parameter(ParameterSetName='ById', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify blackout window rule subset by ClientId.
    ${ClientId},

    [Parameter(ParameterSetName='ByList', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Parameter(ParameterSetName='ByName', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Parameter(ParameterSetName='ById', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify blackout window rule subset by AppTypeId.
    ${AppTypeId},

    [Parameter(ParameterSetName='ByList', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Parameter(ParameterSetName='ByName', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Parameter(ParameterSetName='ById', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify blackout window rule subset by InstanceId.
    ${InstanceId},

    [Parameter(ParameterSetName='ByList', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Parameter(ParameterSetName='ByName', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Parameter(ParameterSetName='ById', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify blackout window rule subset by BackupsetId.
    ${BackupsetId},

    [Parameter(ParameterSetName='ByList', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Parameter(ParameterSetName='ByName', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Parameter(ParameterSetName='ById', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify blackout window rule subset by SubclientId.
    ${SubclientId},

    [Parameter(ParameterSetName='ByList', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Parameter(ParameterSetName='ByName', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Parameter(ParameterSetName='ById', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify blackout window rule subset by ClientgroupId.
    ${ClientgroupId},

    [Parameter(ParameterSetName='ByList', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Parameter(ParameterSetName='ByName', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Parameter(ParameterSetName='ById', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify blackout window rule subset by SchedulePolicyId.
    ${SchedulePolicyId},

    [Parameter(ParameterSetName='ByName', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify blackout window rules to be output by Name.
    ${Name},

    [Parameter(ParameterSetName='ById', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify blackout window rule to be output by Id.
    ${Id},

    [Parameter(ParameterSetName='Get', DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(ParameterSetName='Get', DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(ParameterSetName='Get', DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(ParameterSetName='Get')]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(ParameterSetName='Get', DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(ParameterSetName='Get', DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(ParameterSetName='Get', DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVBlackoutWindow_Get';
            ByList = 'CommvaultPowershell.custom\Get-CVBlackoutWindow';
            ByName = 'CommvaultPowershell.custom\Get-CVBlackoutWindow';
            ById = 'CommvaultPowershell.custom\Get-CVBlackoutWindow';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get client information that retire operation concerns
.Description
API to get client information that retire operation concerns
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IClientInfoForRetire
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvclientinfo
#>
function Get-CVClientInfo {
[OutputType([Commvault.Powershell.Models.IClientInfoForRetire])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ClientId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVClientInfo_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVClientInfo_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get all arrays at client level
.Description
API to get all arrays at client level
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IArrayLevel
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvclientlvlarray
#>
function Get-CVClientLvlArray {
[OutputType([Commvault.Powershell.Models.IArrayLevel])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ClientId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVClientLvlArray_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVClientLvlArray_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to fetch Snap configs for Storage Arrays at client level
.Description
API to fetch Snap configs for Storage Arrays at client level
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ISnapConfigOverrideResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvclientsnapconfig
#>
function Get-CVClientSnapConfig {
[OutputType([Commvault.Powershell.Models.ISnapConfigOverrideResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ClientId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVClientSnapConfig_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVClientSnapConfig_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the list of clients associated with the BackupDestination.
.Description
Get the list of clients associated with the BackupDestination.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IIdName
.Outputs
System.Management.Automation.PSObject
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvclient
#>
function Get-CVClient {
[Alias('Get-CVClientProps', 'Get-CVClientAdditionalSettings')]
[OutputType([Commvault.Powershell.Models.IIdName], [Commvault.Powershell.Models.IGenericResp], [System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='Default', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the BackupDestination.
    ${BackupDestinationId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Default')]
    [Parameter(ParameterSetName='ByName')]
    [Parameter(ParameterSetName='ById')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Retrieves additional setting properties for each client in the list.
    ${AdditionalSettings},

    [Parameter(ParameterSetName='Default')]
    [Parameter(ParameterSetName='ByName')]
    [Parameter(ParameterSetName='ById')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Retrieves package version properties for the specified client.
    ${Version},

    [Parameter(ParameterSetName='Default')]
    [Parameter(ParameterSetName='ByName')]
    [Parameter(ParameterSetName='ById')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Retrieves timezone properties for the specified client.
    ${TimeZone},

    [Parameter(ParameterSetName='Default')]
    [Parameter(ParameterSetName='ByName')]
    [Parameter(ParameterSetName='ById')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Retrieves all properties for the specified client.
    ${AllProperties},

    [Parameter(ParameterSetName='ByName')]
    [Alias('Client')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get detail properties for client specified by Name.
    ${Name},

    [Parameter(ParameterSetName='ById')]
    [Alias('ClientId')]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Get detail properties for client specified by Id.
    ${Id},

    [Parameter(ParameterSetName='Get', DontShow)]
    [Parameter(ParameterSetName='GetViaIdentity', DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(ParameterSetName='Get', DontShow)]
    [Parameter(ParameterSetName='GetViaIdentity', DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(ParameterSetName='Get', DontShow)]
    [Parameter(ParameterSetName='GetViaIdentity', DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(ParameterSetName='Get', DontShow)]
    [Parameter(ParameterSetName='GetViaIdentity', DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(ParameterSetName='Get', DontShow)]
    [Parameter(ParameterSetName='GetViaIdentity', DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(ParameterSetName='Get', DontShow)]
    [Parameter(ParameterSetName='GetViaIdentity', DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVClient_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVClient_GetViaIdentity';
            Default = 'CommvaultPowershell.custom\Get-CVClient';
            ByName = 'CommvaultPowershell.custom\Get-CVClient';
            ById = 'CommvaultPowershell.custom\Get-CVClient';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get All Cloud Storage
.Description
Get All Cloud Storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IStorageListSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvcloudstoragelist
#>
function Get-CVCloudStorageList {
[OutputType([Commvault.Powershell.Models.IStorageListSummary], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Filter cloud storage list to given subtype.
    ${StorageSubType},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVCloudStorageList_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of metadata Cache of a cloud storage based on Id
.Description
Get details of metadata Cache of a cloud storage based on Id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IMetadataCacheConfiguration
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvcloudstoragemetadatacache
#>
function Get-CVCloudStorageMetaDataCache {
[OutputType([Commvault.Powershell.Models.IMetadataCacheConfiguration], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of cloud Storage
    ${CloudStorageId},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of metadata cache
    ${MetadataCacheId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVCloudStorageMetaDataCache_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVCloudStorageMetaDataCache_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get Cloud Storage Details
.Description
Get Cloud Storage Details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ICloudStorageDetails
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvcloudstorage
#>
function Get-CVCloudStorage {
[OutputType([Commvault.Powershell.Models.ICloudStorageDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of cloud Storage
    ${CloudStorageId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Set to true if want to show inherited security associations
    ${ShowInheritedAssociation},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVCloudStorage_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVCloudStorage_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of a company based on id
.Description
Get details of a company based on id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ICompany
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvcompanydetail
#>
function Get-CVCompanyDetail {
[OutputType([Commvault.Powershell.Models.ICompany])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Company whose details have to be fetched
    ${CompanyId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Show inherited security association
    ${ShowInheritedAssociation},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVCompanyDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVCompanyDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get a company's laptop admins.
.Description
Get a company's laptop admins.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGetLaptopAdminsResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvcompanylaptopadmin
#>
function Get-CVCompanyLaptopAdmin {
[OutputType([Commvault.Powershell.Models.IGetLaptopAdminsResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${CompanyId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVCompanyLaptopAdmin_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVCompanyLaptopAdmin_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get All Companies
.Description
Get All Companies
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.ICompanySummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvcompany
#>
function Get-CVCompany {
[OutputType([Commvault.Powershell.Models.ICompanySummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # If true, companies marked for deletion are included in the response
    ${IncludeDeletedCompanies},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVCompany_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
To get a list of all the agents configured for a user
.Description
To get a list of all the agents configured for a user
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IAgentDetails
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvconfiguredagent
#>
function Get-CVConfiguredAgent {
[OutputType([Commvault.Powershell.Models.IAgentDetails])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVConfiguredAgent_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to fetch snap configs for storage arrays at copy level
.Description
API to fetch snap configs for storage arrays at copy level
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ISnapConfigOverrideResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvcopyconfig
#>
function Get-CVCopyConfig {
[OutputType([Commvault.Powershell.Models.ISnapConfigOverrideResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${CopyId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVCopyConfig_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVCopyConfig_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get arrays list at copy level
.Description
API to get arrays list at copy level
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IArrayLevel
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvcopytlvlarray
#>
function Get-CVCopytLvlArray {
[OutputType([Commvault.Powershell.Models.IArrayLevel])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${CopyId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVCopytLvlArray_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVCopytLvlArray_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint is used to return the list of cloud accounts for Cloud Resource Discovery operation.
.Description
This endpoint is used to return the list of cloud accounts for Cloud Resource Discovery operation.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGetCrdCloudAccountsResponse
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvcrdcloudaccount
#>
function Get-CVCrdCloudAccount {
[OutputType([Commvault.Powershell.Models.IGetCrdCloudAccountsResponse])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Type of the cloud vendor.
    # Cloud accounts for the specified cloud vendor will be returned.
    # Supported Vendor type:
    # 3-Azure
    ${Vendor},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # App type for which the Cloud Resorce Discovery instance is being configured.
    # Supported App type:
    # 134-Cloud Apps
    ${TargetApp},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Cloud apps instance type for which the Cloud Resorce Discovery instance is being configured.
    # Supported Cloud apps instance type:
    # 6-Azure Blob
    ${TargetInstance},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVCrdCloudAccount_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
List of Credentials
.Description
List of Credentials
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.ICredentialSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvcredentials
#>
function Get-CVCredentials {
[OutputType([Commvault.Powershell.Models.ICredentialSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVCredentials_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Fetches the details of the given CVFS bucket
.Description
Fetches the details of the given CVFS bucket
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResponse
.Outputs
Commvault.Powershell.Models.IGetCvfss3BucketResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvcvfs3bucket
#>
function Get-CVCvfS3Bucket {
[OutputType([Commvault.Powershell.Models.IGetCvfss3BucketResp], [Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the bucket
    ${Id},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVCvfS3Bucket_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVCvfS3Bucket_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get all databases
.Description
Get all databases
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IDatabaseSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvdatabase
#>
function Get-CVDatabase {
[OutputType([Commvault.Powershell.Models.IDatabaseSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVDatabase_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get Data Classification Plan details
.Description
Get Data Classification Plan details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IDcPlanDetails
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvdcplan
#>
function Get-CVDcPlan {
[OutputType([Commvault.Powershell.Models.IDcPlanDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVDcPlan_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVDcPlan_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Fetch the default inventory associated to the index server
.Description
Fetch the default inventory associated to the index server
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IInventoryDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvdefaultinventory
#>
function Get-CVDefaultInventory {
[OutputType([Commvault.Powershell.Models.IInventoryDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Pseudo client id of the index server
    ${IndexServerClientId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Create the default inventory if it is missing for the index server
    ${CreateIfAbsent},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVDefaultInventory_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVDefaultInventory_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of a disk storage pool based on id
.Description
Get details of a disk storage pool based on id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IDiskStorage
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvdiskstoragedetail
#>
function Get-CVDiskStorageDetail {
[OutputType([Commvault.Powershell.Models.IDiskStorage])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the disk storage pool whose details have to be fetched
    ${StoragePoolId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Show inherited security association
    ${ShowInheritedAssociation},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVDiskStorageDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVDiskStorageDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get a list of disk storage pools
.Description
Get a list of disk storage pools
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IStorageListSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvdiskstorage
#>
function Get-CVDiskStorage {
[OutputType([Commvault.Powershell.Models.IStorageListSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVDiskStorage_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the list of distributed storages
.Description
Get the list of distributed storages
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IDistributedStorageSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvdistributedstorage
#>
function Get-CVDistributedStorage {
[OutputType([Commvault.Powershell.Models.IDistributedStorageSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVDistributedStorage_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint is used to return the list of distributed systems.
.Description
This endpoint is used to return the list of distributed systems.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IDistributedSystemSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvdistributedsystem
#>
function Get-CVDistributedSystem {
[OutputType([Commvault.Powershell.Models.IDistributedSystemSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVDistributedSystem_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get list of machines eligible to be added to failover group
.Description
API to get list of machines eligible to be added to failover group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IFailoverGroupEligibleMachineList
.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cveligiblemachinefailovergroup
#>
function Get-CVEligibleMachineFailoverGroup {
[OutputType([Commvault.Powershell.Models.IFailoverGroupEligibleMachineList], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # The ID of the source entity.
    # This is the ID for client or client group
    ${SourceEntityId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # The client ID of the destination
    ${DestinationClientId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # The type of failover group source.
    # Default value is 'REPLICATION'
    ${FailoverGroupSource},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # The type of source entity.
    # It can be 'CLIENT' or 'CLIENT_ENTITY'.
    # Default value is 'CLIENT'
    ${SourceEntityType},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVEligibleMachineFailoverGroup_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to fetch available media agents which can be added as access paths for local storage
.Description
Used to fetch available media agents which can be added as access paths for local storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IIdNameDisplayName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cveligiblemediaagent
#>
function Get-CVEligibleMediaAgent {
[OutputType([Commvault.Powershell.Models.IIdNameDisplayName])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backup location of which media agent has to be shared
    ${BackupLocationId},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the local storage pool whose media agent has to be shared
    ${StoragePoolId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVEligibleMediaAgent_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVEligibleMediaAgent_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Retrieves SMTP server details
.Description
Retrieves SMTP server details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGetEmailServerDetails
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvemailserver
#>
function Get-CVEmailServer {
[OutputType([Commvault.Powershell.Models.IGetEmailServerDetails])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVEmailServer_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get list of entity settings used to modify default behaviour for linked entity like servers or server groups
.Description
Get list of entity settings used to modify default behaviour for linked entity like servers or server groups
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IEntitySettingsListItem
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cventitysetting
#>
function Get-CVEntitySetting {
[OutputType([Commvault.Powershell.Models.IEntitySettingsListItem])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVEntitySetting_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint is used to return the list of epic servers.
.Description
This endpoint is used to return the list of epic servers.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IFileServerSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvepicserver
#>
function Get-CVEpicServer {
[OutputType([Commvault.Powershell.Models.IFileServerSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVEpicServer_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to fetch failover group information
.Description
API to fetch failover group information
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IFailoverGroupDetails
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvfailovergroupdetail
#>
function Get-CVFailoverGroupDetail {
[OutputType([Commvault.Powershell.Models.IFailoverGroupDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the failover group
    ${FailoverGroupId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVFailoverGroupDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVFailoverGroupDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This end point return the list of failover groups
.Description
This end point return the list of failover groups
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IFailoverGroupsList
.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvfailovergroup
#>
function Get-CVFailoverGroup {
[OutputType([Commvault.Powershell.Models.IFailoverGroupsList], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            List = 'CommvaultPowershell.private\Get-CVFailoverGroup_List';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint is used to return the list of file servers.
.Description
This endpoint is used to return the list of file servers.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IFileServerSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvfileserver
#>
function Get-CVFileServer {
[OutputType([Commvault.Powershell.Models.IFileServerSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVFileServer_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint is used to return the detail of network topology.
.Description
This endpoint is used to return the detail of network topology.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IFirewallTopologyDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvfirewalltopologydetail
#>
function Get-CVFirewallTopologyDetail {
[OutputType([Commvault.Powershell.Models.IFirewallTopologyDetails])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # .
    ${TopologyId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVFirewallTopologyDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVFirewallTopologyDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint is used to return the list of network topology.
.Description
This endpoint is used to return the list of network topology.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IFirewallTopology
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvfirewalltopology
#>
function Get-CVFirewallTopology {
[OutputType([Commvault.Powershell.Models.IFirewallTopology])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVFirewallTopology_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get database list for GCP
.Description
Get database list for GCP
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGcpDatabaseList
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvgcpspannerdatabase
#>
function Get-CVGcpSpannerDatabase {
[OutputType([Commvault.Powershell.Models.IGcpDatabaseList])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # the id of the node where the browse request is sent
    ${CloudAccountId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # the google spanner instance name
    ${InstanceName},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # google cloud project the instance belongs to
    ${ProjectName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVGcpSpannerDatabase_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
To get the list of instances for GCP
.Description
To get the list of instances for GCP
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGcpInstanceList
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvgcpspannerinstancelist
#>
function Get-CVGcpSpannerInstanceList {
[OutputType([Commvault.Powershell.Models.IGcpInstanceList])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # the google cloud hypervisor account id
    ${CloudAccountId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVGcpSpannerInstanceList_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get permission status for a cloudAccount on a GCP project
.Description
Get permission status for a cloudAccount on a GCP project
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Boolean
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvgcpspannerpermission
#>
function Get-CVGcpSpannerPermission {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # the id of the node where the browse request is sent
    ${CloudAccountId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # google cloud project the instance belongs to
    ${ProjectName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVGcpSpannerPermission_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get list of global execptions
.Description
Get list of global execptions
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IGetGlobalExceptions
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvglobalexception
#>
function Get-CVGlobalException {
[OutputType([Commvault.Powershell.Models.IGetGlobalExceptions], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVGlobalException_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get list of global settings used to modify system default behaviour
.Description
Get list of global settings used to modify system default behaviour
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGlobalSettingsItem
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvglobalsetting
#>
function Get-CVGlobalSetting {
[OutputType([Commvault.Powershell.Models.IGlobalSettingsItem])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVGlobalSetting_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get Hybrid File Store Share Status
.Description
API to get Hybrid File Store Share Status
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IHfsShareStatusResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvhybridfilestoresharestatus
#>
function Get-CVHybridFileStoreShareStatus {
[OutputType([Commvault.Powershell.Models.IHfsShareStatusResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the HFS Share to fetch its status
    ${HfsShareId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVHybridFileStoreShareStatus_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVHybridFileStoreShareStatus_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get list of hybrid file stores
.Description
Get list of hybrid file stores
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IHybridFileStoreSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvhybridfilestore
#>
function Get-CVHybridFileStore {
[OutputType([Commvault.Powershell.Models.IHybridFileStoreSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVHybridFileStore_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get All HyperScale Storage
.Description
Get All HyperScale Storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IStorageListSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvhyperscalestoragelist
#>
function Get-CVHyperScaleStorageList {
[OutputType([Commvault.Powershell.Models.IStorageListSummary], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVHyperScaleStorageList_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of a specific HyperScale Storage
.Description
Get details of a specific HyperScale Storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IHyperScaleStorageDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvhyperscalestorage
#>
function Get-CVHyperScaleStorage {
[OutputType([Commvault.Powershell.Models.IHyperScaleStorageDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of hyperscale storage
    ${HyperScaleStorageId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Set to true if want to show inherited security associations
    ${ShowInheritedAssociation},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVHyperScaleStorage_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVHyperScaleStorage_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the details of  HYpervisor
.Description
Get the details of  HYpervisor
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IHypervisorPropertiesResp
.Outputs
Commvault.Powershell.Models.IListHypervisors
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvhypervisor
#>
function Get-CVHypervisor {
[OutputType([Commvault.Powershell.Models.IHypervisorPropertiesResp], [Commvault.Powershell.Models.IGenericResp], [Commvault.Powershell.Models.IListHypervisors])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the HYpervisor to get
    ${HypervisorId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVHypervisor_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVHypervisor_GetViaIdentity';
            List = 'CommvaultPowershell.private\Get-CVHypervisor_List';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Retrieve job history for identity server asset
.Description
Retrieve job history for identity server asset
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IDatasourceJobSummary
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvidentityserverassetjobhistory
#>
function Get-CVIdentityServerAssetJobHistory {
[OutputType([Commvault.Powershell.Models.IDatasourceJobSummary], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # FQDN of the asset
    ${AssetId},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${InventoryId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVIdentityServerAssetJobHistory_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVIdentityServerAssetJobHistory_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get identity servers list
.Description
Get identity servers list
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IIdentityServer
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvidentityserver
#>
function Get-CVIdentityServer {
[OutputType([Commvault.Powershell.Models.IIdentityServer])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVIdentityServer_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get list of index servers
.Description
Get list of index servers
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IIndexServerSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvindexserver
#>
function Get-CVIndexServer {
[OutputType([Commvault.Powershell.Models.IIndexServerSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVIndexServer_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint is used to return the list of instances.
.Description
This endpoint is used to return the list of instances.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IInstanceSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvinstance
#>
function Get-CVInstance {
[OutputType([Commvault.Powershell.Models.IInstanceSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVInstance_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get all instant clones
.Description
Get all instant clones
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IInstantClonesSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvinstantclone
#>
function Get-CVInstantClone {
[OutputType([Commvault.Powershell.Models.IInstantClonesSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVInstantClone_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the details of inventory asset
.Description
Get the details of inventory asset
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IInventoryAssetDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvinventoryassetdetail
#>
function Get-CVInventoryAssetDetail {
[OutputType([Commvault.Powershell.Models.IInventoryAssetDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # FQDN of the asset
    ${AssetId},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${InventoryId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVInventoryAssetDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVInventoryAssetDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the list of assets associated to the inventory
.Description
Get the list of assets associated to the inventory
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IInventoryAssetSummary
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvinventoryassetlist
#>
function Get-CVInventoryAssetList {
[OutputType([Commvault.Powershell.Models.IInventoryAssetSummary], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Inventory id
    ${InventoryId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVInventoryAssetList_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVInventoryAssetList_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the list of data sources associated to the inventory
.Description
Get the list of data sources associated to the inventory
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IInventoryAssociatedDatasource
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvinventoryassociateddatasourcelist
#>
function Get-CVInventoryAssociatedDataSourceList {
[OutputType([Commvault.Powershell.Models.IInventoryAssociatedDatasource], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Inventory Id
    ${InventoryId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVInventoryAssociatedDataSourceList_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVInventoryAssociatedDataSourceList_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get inventory details
.Description
Get inventory details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IInventoryDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvinventorydetail
#>
function Get-CVInventoryDetail {
[OutputType([Commvault.Powershell.Models.IInventoryDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${InventoryId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVInventoryDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVInventoryDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Retrieve the list of inventories
.Description
Retrieve the list of inventories
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IInventoryDetails
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvinventorylist
#>
function Get-CVInventoryList {
[OutputType([Commvault.Powershell.Models.IInventoryDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVInventoryList_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the list of Jobs for selected backupDestinationId.
.Description
Get the list of Jobs for selected backupDestinationId.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IJobDetailForStorage
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvjobonbackupdestination
#>
function Get-CVJobOnBackupDestination {
[OutputType([Commvault.Powershell.Models.IJobDetailForStorage], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the BackupDestination to fetch Job List.
    ${BackupDestinationId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Aged Jobs selection.
    # Accepted values [ 0 to exclude aged jobs, 1 to show only aged jobs, 2 to include aged jobs].
    ${AgedData},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Job backup type filter.
    # Accepted values [1=Full, 2=Incremental, 4=Differential, 8=All, 64=Synthetic full].
    ${BackupLvl},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Comma separated Client Ids to filter the jobs based on clients associated
    ${Clients},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Filter jobs by data status.
    # Accepted values [0 = show all, 1 = show available, 4 = show to be copied, 8 = show not to be copied, 16 = show extended retained].
    ${CopyState},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # End time of the time range.
    ${EndTime},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Start time of the time range.
    ${StartTime},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Time period selection for which to fetch jobs.
    # Accepted values [last24Hours, lastWeek, lastMonth, last3Months, custom].
    # When custom is selected Jobs are filtered based on values provided in other params.
    ${View},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVJobOnBackupDestination_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVJobOnBackupDestination_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Fetch all the modifiers
.Description
Fetch all the modifiers
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IK8SRestoreModifierApiresp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvk8smodifier
#>
function Get-CVK8SModifier {
[OutputType([Commvault.Powershell.Models.IK8SRestoreModifierApiresp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='Get1', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the cluster whose modifier has to be listed.
    ${ClusterId},

    [Parameter(ParameterSetName='Get1', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # Name of the modifier to be read.
    ${ModifierName},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='GetViaIdentity1', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVK8SModifier_Get';
            Get1 = 'CommvaultPowershell.private\Get-CVK8SModifier_Get1';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVK8SModifier_GetViaIdentity';
            GetViaIdentity1 = 'CommvaultPowershell.private\Get-CVK8SModifier_GetViaIdentity1';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get key management servers
.Description
Get key management servers
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IKeyManagementServer
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvkeymanagementserver
#>
function Get-CVKeyManagementServer {
[OutputType([Commvault.Powershell.Models.IKeyManagementServer], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVKeyManagementServer_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get details of a Kubernetes application
.Description
API to get details of a Kubernetes application
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IKubernetesApplicationDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvkuberneteappdetail
#>
function Get-CVKuberneteAppDetail {
[OutputType([Commvault.Powershell.Models.IKubernetesApplicationDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # GUID of the Application to get details
    ${AppGuid},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVKuberneteAppDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVKuberneteAppDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get all Kubernetes application groups
.Description
API to get all Kubernetes application groups
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IKubernetesApplicationGroupItem
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvkuberneteappgroup
#>
function Get-CVKuberneteAppGroup {
[OutputType([Commvault.Powershell.Models.IKubernetesApplicationGroupItem], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # clusterId is the ID of the Kubernetes cluster client to filter Application Groups for
    ${ClusterId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVKuberneteAppGroup_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get all application in Kubenetes cluster
.Description
Get all application in Kubenetes cluster
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IApplicationListResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvkuberneteapplication
#>
function Get-CVKuberneteApplication {
[OutputType([Commvault.Powershell.Models.IApplicationListResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVKuberneteApplication_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get all Kubernetes applications
.Description
API to get all Kubernetes applications
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IGetApplicationsList
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvkuberneteapp
#>
function Get-CVKuberneteApp {
[OutputType([Commvault.Powershell.Models.IGetApplicationsList], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVKuberneteApp_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get details of a Kubernetes clusters with clusterId
.Description
API to get details of a Kubernetes clusters with clusterId
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IGetClusterDetailsResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvkuberneteclusterdetail
#>
function Get-CVKuberneteClusterDetail {
[OutputType([Commvault.Powershell.Models.IGetClusterDetailsResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ClusterId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVKuberneteClusterDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVKuberneteClusterDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get all Kubernetes clusters
.Description
API to get all Kubernetes clusters
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IGetClusterResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvkuberneteclusterop
#>
function Get-CVKuberneteClusterOp {
[OutputType([Commvault.Powershell.Models.IGetClusterResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVKuberneteClusterOp_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the details of all cluster
.Description
Get the details of all cluster
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IListClusters
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvkubernetecluster
#>
function Get-CVKuberneteCluster {
[OutputType([Commvault.Powershell.Models.IListClusters], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            List = 'CommvaultPowershell.private\Get-CVKuberneteCluster_List';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get Backup Destinations for a Plan
.Description
Get Backup Destinations for a Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IPlanBackupDestinations
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvlaptopbackupdestination
#>
function Get-CVLaptopBackupDestination {
[OutputType([Commvault.Powershell.Models.IPlanBackupDestinations])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Laptop Plan to retrieve backup destinations
    ${PlanId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVLaptopBackupDestination_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVLaptopBackupDestination_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get list of laptops
.Description
Get list of laptops
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.ILaptopsList
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvlaptoplist
#>
function Get-CVLaptopList {
[OutputType([Commvault.Powershell.Models.ILaptopsList])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${AdditionalProperties},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${Edgemode},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVLaptopList_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get the list of laptop owner mappings
.Description
API to get the list of laptop owner mappings
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ILaptopOwnerMapping
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvlaptopownermapping
#>
function Get-CVLaptopOwnerMapping {
[OutputType([Commvault.Powershell.Models.ILaptopOwnerMapping], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Id of the company for which the laptop owner mapping needs to be returned
    ${CompanyId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVLaptopOwnerMapping_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get Laptop Plan details
.Description
Get Laptop Plan details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ILaptopPlanDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvlaptopplan
#>
function Get-CVLaptopPlan {
[OutputType([Commvault.Powershell.Models.ILaptopPlanDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the plan
    ${PlanId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVLaptopPlan_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVLaptopPlan_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint returns license information
.Description
This endpoint returns license information
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ILicenseInfo
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvlicenseinfo
#>
function Get-CVLicenseInfo {
[OutputType([Commvault.Powershell.Models.ILicenseInfo], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVLicenseInfo_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Fetches the list of clones for the given bucket id
.Description
Fetches the list of clones for the given bucket id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResponse
.Outputs
Commvault.Powershell.Models.IGetCvfss3BucketCloneDetailsResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvlists3bucketclone
#>
function Get-CVListS3BucketClone {
[OutputType([Commvault.Powershell.Models.IGetCvfss3BucketCloneDetailsResp], [Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the bucket
    ${Id},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVListS3BucketClone_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVListS3BucketClone_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to fetch mount path details of the local storage pool
.Description
Used to fetch mount path details of the local storage pool
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IBackupLocationDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvlocalbackuplocationdetail
#>
function Get-CVLocalBackupLocationDetail {
[OutputType([Commvault.Powershell.Models.IBackupLocationDetails])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backup location whose details have to be fetched
    ${BackupLocationId},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the local storage pool whose details have to be fetched
    ${StoragePoolId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVLocalBackupLocationDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVLocalBackupLocationDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of a local storage pool based on id.
.Description
Get details of a local storage pool based on id.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ILocalStorage
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvlocalstoragedetail
#>
function Get-CVLocalStorageDetail {
[OutputType([Commvault.Powershell.Models.ILocalStorage])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the local storage pool whose details have to be fetched
    ${StoragePoolId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Show inherited security association
    ${ShowInheritedAssociation},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVLocalStorageDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVLocalStorageDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get a list of Local storage pools
.Description
Get a list of Local storage pools
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IStorageListSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvlocalstorage
#>
function Get-CVLocalStorage {
[OutputType([Commvault.Powershell.Models.IStorageListSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVLocalStorage_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Fetch the list of DDB disks hosted on the MediaAgent
.Description
Fetch the list of DDB disks hosted on the MediaAgent
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IMaddbDiskMgmtResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvmediaagentddbdisk
#>
function Get-CVMediaAgentDdbDisk {
[OutputType([Commvault.Powershell.Models.IMaddbDiskMgmtResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the MediaAgent
    ${MediaAgentId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVMediaAgentDdbDisk_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVMediaAgentDdbDisk_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of a media agent based on id
.Description
Get details of a media agent based on id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IMediaAgent
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvmediaagentdetail
#>
function Get-CVMediaAgentDetail {
[OutputType([Commvault.Powershell.Models.IMediaAgent])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Media Agent whose details have to be fetched
    ${MediaAgentId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Show inherited security association
    ${ShowInheritedAssociation},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVMediaAgentDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVMediaAgentDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get All Media Agents
.Description
Get All Media Agents
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IMediaAgentForDdbSummary
.Outputs
Commvault.Powershell.Models.IMediaAgentSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvmediaagent
#>
function Get-CVMediaAgent {
[OutputType([Commvault.Powershell.Models.IMediaAgentSummary], [Commvault.Powershell.Models.IMediaAgentForDdbSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get1')]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # If set to true then fetch the list of DDB disks hosted on each MediaAgent
    ${FetchDdbDisks},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVMediaAgent_Get';
            Get1 = 'CommvaultPowershell.private\Get-CVMediaAgent_Get1';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get mountpath content
.Description
API to get mountpath content
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IGetMountPathContentResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvmountpathcontent
#>
function Get-CVMountPathContent {
[OutputType([Commvault.Powershell.Models.IGetMountPathContentResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Device Id
    ${DeviceId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Mountpath Id
    ${MountPathId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVMountPathContent_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of a specific node of a hyperscale storage
.Description
Get details of a specific node of a hyperscale storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IHyperScaleNodeDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvnodedetail
#>
function Get-CVNodeDetail {
[OutputType([Commvault.Powershell.Models.IHyperScaleNodeDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of hyperscale storage
    ${HyperScaleStorageId},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of node
    ${NodeId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVNodeDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVNodeDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to deploy Access Node
.Description
API to deploy Access Node
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IAccessNodeDeployment
.Outputs
Commvault.Powershell.Models.ICreateTaskRespforBackup
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IAccessNodeDeployment>: AccessNodeDeployment
  NetworkName <String>: Destination network name
  UserCredentialsPassword <String>: 
  UserCredentialsUserName <String>: 
  VCenter <String>: vCenter server instance
  VMLocationDataCenterName <String>: 
  VMLocationDatastore <String>: If cluster is selected for storage then moref of datastore cluster else dataStoreName
  VMLocationHost <String>: If ESX-Host for resource the host moref or If ESX-Cluster then cluster moref and if resource pool is used for resource then first go for host moref then cluster moref
  VMName <String>: 
  [AutomaticOSUpdates <Boolean?>]: 
  [ClientGroup <String>]: 
  [CommCellHostName <String>]: CommServer host name
  [CommCellName <String>]: CommServer name
  [DeploymentType <Int64?>]: 0: Access node deployment, 1: File recovery enabler for linux deployment
  [HardDiskType <Int64?>]: 1: Thin Provision, 2: Thick provision lazy zeroed, 3: Thick provision eager zeroed
  [HostName <String>]: Host name for vm, if not provided it will be same as vmName
  [Name <String>]: Client name for vm, if not provided it will be same as vmName
  [NetworkDnsSearch <String>]: 
  [NetworkGateway <String>]: 
  [NetworkNameservers <String[]>]: 
  [NetworkNetmask <String>]: 
  [NetworkStaticIP <String>]: 
  [NetworkUseDhcp <String>]: If useDHCP is False then make sure to provide staticIP, netmask, gateway
  [NotifyUserOnJobCompletion <Boolean?>]: 
  [OS <String>]: 
  [Timezone <String>]: Linux OS qualified timezones
  [VMLocationCluster <String>]: ESX-Cluster moref if cluster is selected for resource
  [VMLocationInventoryPath <String>]: Folder path where you can locate vm, empty if Datacenter is selected for location. Default is set to Datacenter
  [VMLocationResourcePool <String>]: Resource Pool moref if resource pool is selected for resource
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvnode
#>
function Get-CVNode {
[OutputType([Commvault.Powershell.Models.ICreateTaskRespforBackup])]
[CmdletBinding(DefaultParameterSetName='AccessExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Access', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAccessNodeDeployment]
    # AccessNodeDeployment
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='AccessExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Destination network name
    ${NetworkName},

    [Parameter(ParameterSetName='AccessExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${UserCredentialsPassword},

    [Parameter(ParameterSetName='AccessExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${UserCredentialsUserName},

    [Parameter(ParameterSetName='AccessExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # vCenter server instance
    ${VCenter},

    [Parameter(ParameterSetName='AccessExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${VMLocationDataCenterName},

    [Parameter(ParameterSetName='AccessExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # If cluster is selected for storage then moref of datastore cluster else dataStoreName
    ${VMLocationDatastore},

    [Parameter(ParameterSetName='AccessExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # If ESX-Host for resource the host moref or If ESX-Cluster then cluster moref and if resource pool is used for resource then first go for host moref then cluster moref
    ${VMLocationHost},

    [Parameter(ParameterSetName='AccessExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${VMName},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${AutomaticOSUpdates},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ClientGroup},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # CommServer host name
    ${CommCellHostName},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # CommServer name
    ${CommCellName},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # 0: Access node deployment, 1: File recovery enabler for linux deployment
    ${DeploymentType},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # 1: Thin Provision, 2: Thick provision lazy zeroed, 3: Thick provision eager zeroed
    ${HardDiskType},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Host name for vm, if not provided it will be same as vmName
    ${HostName},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Client name for vm, if not provided it will be same as vmName
    ${Name},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${NetworkDnsSearch},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${NetworkGateway},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # .
    ${NetworkNameservers},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${NetworkNetmask},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${NetworkStaticIP},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # If useDHCP is False then make sure to provide staticIP, netmask, gateway
    ${NetworkUseDhcp},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${NotifyUserOnJobCompletion},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OS},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Linux OS qualified timezones
    ${Timezone},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # ESX-Cluster moref if cluster is selected for resource
    ${VMLocationCluster},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Folder path where you can locate vm, empty if Datacenter is selected for location.
    # Default is set to Datacenter
    ${VMLocationInventoryPath},

    [Parameter(ParameterSetName='AccessExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Resource Pool moref if resource pool is selected for resource
    ${VMLocationResourcePool},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Access = 'CommvaultPowershell.private\Get-CVNode_Access';
            AccessExpanded = 'CommvaultPowershell.private\Get-CVNode_AccessExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get Object Store Plan details
.Description
Get Object Store Plan details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IObjectStorePlan
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvobjectstoreplanid
#>
function Get-CVObjectStorePlanId {
[OutputType([Commvault.Powershell.Models.IObjectStorePlan])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the object store plan to fetch details
    ${PlanId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVObjectStorePlanId_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVObjectStorePlanId_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Returns all Office365 active plans with number of entities associated to the plan per workload
.Description
Returns all Office365 active plans with number of entities associated to the plan per workload
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IOffice365PlanSummaryListResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvoffice365plandashboard
#>
function Get-CVOffice365PlanDashboard {
[OutputType([Commvault.Powershell.Models.IOffice365PlanSummaryListResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVOffice365PlanDashboard_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get a list of categories and permissions in each category
.Description
Get a list of categories and permissions in each category
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.ICategoryListResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvpermissionresponse
#>
function Get-CVPermissionResponse {
[OutputType([Commvault.Powershell.Models.ICategoryListResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVPermissionResponse_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get All Plans as Name Id Pairs
.Description
Get All Plans as Name Id Pairs
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IIdName
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvplanid
#>
function Get-CVPlanId {
[OutputType([Commvault.Powershell.Models.IIdName])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVPlanId_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to fetch list of entities that are applicable for plan association via plan assignment rules.
.Description
API to fetch list of entities that are applicable for plan association via plan assignment rules.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IPlanRuleApplicableEntity
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvplanruleassociatedentity
#>
function Get-CVPlanRuleAssociatedEntity {
[OutputType([Commvault.Powershell.Models.IPlanRuleApplicableEntity], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVPlanRuleAssociatedEntity_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Api to fetch plan rules details.
.Description
Api to fetch plan rules details.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IPlanEntityRuleInfo
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvplanruledetail
#>
function Get-CVPlanRuleDetail {
[OutputType([Commvault.Powershell.Models.IPlanEntityRuleInfo], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the rule to update in Plan
    ${RuleId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVPlanRuleDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVPlanRuleDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get excluded workloads from plan rule evaluation framework
.Description
API to get excluded workloads from plan rule evaluation framework
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IWorkloadEntity
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvplanruleentityexclude
#>
function Get-CVPlanRuleEntityExclude {
[OutputType([Commvault.Powershell.Models.IWorkloadEntity], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVPlanRuleEntityExclude_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Fetch plan rule execution settings
.Description
Fetch plan rule execution settings
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IPlanRuleExecutionSettings
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvplanrulesetting
#>
function Get-CVPlanRuleSetting {
[OutputType([Commvault.Powershell.Models.IPlanRuleExecutionSettings], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVPlanRuleSetting_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Api to fetch plan rules list.
.Description
Api to fetch plan rules list.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IPlanEntityRuleInfo
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvplanrule
#>
function Get-CVPlanRule {
[OutputType([Commvault.Powershell.Models.IPlanEntityRuleInfo], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVPlanRule_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get Summary of a Plan
.Description
Get Summary of a Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IPlanSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvplansummary
#>
function Get-CVPlanSummary {
[OutputType([Commvault.Powershell.Models.IPlanSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVPlanSummary_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get Plan details
.Description
Get Plan details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IServerPlan
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvplan
#>
function Get-CVPlan {
[OutputType([Commvault.Powershell.Models.IServerPlan])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the plan to fetch details
    ${PlanId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVPlan_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVPlan_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get eligibility for install job option at different entity level
.Description
API to get eligibility for install job option at different entity level
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGetSetWindowsMssqlPatchingMsg
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvplatformupgradeoption
#>
function Get-CVPlatformUpgradeOption {
[OutputType([Commvault.Powershell.Models.IGetSetWindowsMssqlPatchingMsg])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Id of the client or client group for which to fetch install job options
    ${ClientId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Specify the entity level for which to fetch install jobs options.
    # Accepted values [ 2 = Client, 3 = Client Group, 4 = Commcell]
    ${Option},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVPlatformUpgradeOption_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Retrieve list of projects for the request
.Description
Retrieve list of projects for the request
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IRmProjectInfo
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvproject
#>
function Get-CVProject {
[OutputType([Commvault.Powershell.Models.IRmProjectInfo], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Unique request id
    ${RequestId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVProject_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVProject_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get qualified server list to create a new software cache
.Description
Get qualified server list to create a new software cache
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ISoftwareCacheDetail
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvqualifiedserver
#>
function Get-CVQualifiedServer {
[OutputType([Commvault.Powershell.Models.ISoftwareCacheDetail], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVQualifiedServer_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the list of Recovery groups
.Description
Get the list of Recovery groups
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IRecoveryGroup
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvrecoverygroup
#>
function Get-CVRecoveryGroup {
[OutputType([Commvault.Powershell.Models.IRecoveryGroup], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVRecoveryGroup_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the list of recovery point stores.
.Description
Get the list of recovery point stores.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IRpStoreListEntity
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvrecoverypointstorelist
#>
function Get-CVRecoveryPointStoreList {
[OutputType([Commvault.Powershell.Models.IRpStoreListEntity], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVRecoveryPointStoreList_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Fetch details about recovery point stores or library details
.Description
Fetch details about recovery point stores or library details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IRecoveryPointStoreDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvrecoverypointstore
#>
function Get-CVRecoveryPointStore {
[OutputType([Commvault.Powershell.Models.IRecoveryPointStoreDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # .
    ${RpsId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVRecoveryPointStore_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVRecoveryPointStore_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the list of recovery targets
.Description
Get the list of recovery targets
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IGetRecoveryTargetListSummary
.Outputs
Commvault.Powershell.Models.IRecoveryTargetDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvrecoverytarget
#>
function Get-CVRecoveryTarget {
[OutputType([Commvault.Powershell.Models.IGetRecoveryTargetListSummary], [Commvault.Powershell.Models.IGenericResp], [Commvault.Powershell.Models.IRecoveryTargetDetails])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get1', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # id of recovery target
    ${RecoveryTargetId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials},

    [Parameter(ParameterSetName='Get1')]
    [Parameter(ParameterSetName='GetViaIdentity')]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVRecoveryTarget_Get';
            Get1 = 'CommvaultPowershell.private\Get-CVRecoveryTarget_Get1';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVRecoveryTarget_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of the region
.Description
Get details of the region
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IRegionDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvregiondetail
#>
function Get-CVRegionDetail {
[OutputType([Commvault.Powershell.Models.IRegionDetails])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${RegionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVRegionDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVRegionDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get list of regions
.Description
Get list of regions
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGetEntityRegionResp
.Outputs
Commvault.Powershell.Models.IIdNameDisplayName
.Outputs
Commvault.Powershell.Models.IRegionSummary
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvregion
#>
function Get-CVRegion {
[OutputType([Commvault.Powershell.Models.IRegionSummary], [Commvault.Powershell.Models.IIdNameDisplayName], [Commvault.Powershell.Models.IGetEntityRegionResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get1', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Unique id for the entity
    ${EntityId},

    [Parameter(ParameterSetName='Get1', Mandatory)]
    [Parameter(ParameterSetName='Get2', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # Type of the entity
    ${EntityType},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Get')]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Region type to be filtered
    ${Type},

    [Parameter(ParameterSetName='Get1')]
    [Parameter(ParameterSetName='GetViaIdentity')]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Flag for Enable/Disable Region Calculation
    ${Calculate},

    [Parameter(ParameterSetName='Get1')]
    [Parameter(ParameterSetName='GetViaIdentity')]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Region Type Enum
    ${EntityRegionType},

    [Parameter(ParameterSetName='Get2', Mandatory)]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Comma Seprated Entity Ids
    ${Entities},

    [Parameter(ParameterSetName='Get2')]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Region Type Enum
    ${RegionType},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials},

    [Parameter(ParameterSetName='Get1')]
    [Parameter(ParameterSetName='Get2')]
    [Parameter(ParameterSetName='GetViaIdentity')]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVRegion_Get';
            Get1 = 'CommvaultPowershell.private\Get-CVRegion_Get1';
            Get2 = 'CommvaultPowershell.private\Get-CVRegion_Get2';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVRegion_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get all replication groups
.Description
Get all replication groups
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IReplicationGroupList
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvreplicationgroup
#>
function Get-CVReplicationGroup {
[OutputType([Commvault.Powershell.Models.IReplicationGroupList])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVReplicationGroup_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get Continuous Replication Pair Details
.Description
Get Continuous Replication Pair Details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IReplicationMonitorDetail
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvreplicationmonitorpairid
#>
function Get-CVReplicationMonitorPairId {
[OutputType([Commvault.Powershell.Models.IReplicationMonitorDetail], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${PairId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # To get extra meta data details for the api
    ${AdditionalProperties},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVReplicationMonitorPairId_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVReplicationMonitorPairId_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Retrieve details of an existing request
.Description
Retrieve details of an existing request
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IRmRequestDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvrequestdetail
#>
function Get-CVRequestDetail {
[OutputType([Commvault.Powershell.Models.IRmRequestDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Unique identifier for the request
    ${RequestId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVRequestDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVRequestDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get All Resource Pools
.Description
Get All Resource Pools
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IResourcePoolSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvresourcepool
#>
function Get-CVResourcePool {
[OutputType([Commvault.Powershell.Models.IResourcePoolSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVResourcePool_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get a details of the role whose role id has been provided
.Description
Get a details of the role whose role id has been provided
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IRole
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvroledetail
#>
function Get-CVRoleDetail {
[OutputType([Commvault.Powershell.Models.IRole])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Role Id
    ${RoleId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Shows inherited security associations
    ${ShowInheritedAssociation},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVRoleDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVRoleDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get a list of all the roles
.Description
Get a list of all the roles
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IRoleSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvrole
#>
function Get-CVRole {
[OutputType([Commvault.Powershell.Models.IRoleSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVRole_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get jobs running to a storage pool.
.Description
API to get jobs running to a storage pool.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResponse
.Outputs
System.Int64
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvrunningjob
#>
function Get-CVRunningJob {
[OutputType([System.Int64], [Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of storage pool
    ${StoragePoolId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # To include/exclude suspended jobs in the response
    ${IgnoreSuspendedJobs},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Type of job
    ${JobType},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVRunningJob_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVRunningJob_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the S3 Access Key for the logged in user on email
.Description
Get the S3 Access Key for the logged in user on email
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResponse
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvs3accesskey
#>
function Get-CVS3AccessKey {
[OutputType([Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVS3AccessKey_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Fetch the details of the clone of the given ID
.Description
Fetch the details of the clone of the given ID
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResponse
.Outputs
Commvault.Powershell.Models.IGetCvfss3BucketCloneDetailsResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvs3bucketclonedetail
#>
function Get-CVS3BucketCloneDetail {
[OutputType([Commvault.Powershell.Models.IGetCvfss3BucketCloneDetailsResp], [Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the cloned bucket
    ${CloneId},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the bucket
    ${Id},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVS3BucketCloneDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVS3BucketCloneDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Gets details of SAML app based on SAML app name
.Description
Gets details of SAML app based on SAML app name
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ISaml
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsamlapp
#>
function Get-CVSamlApp {
[OutputType([Commvault.Powershell.Models.ISaml])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # .
    ${Name},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVSamlApp_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVSamlApp_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to fetch DC plan associated to server group
.Description
API to fetch DC plan associated to server group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IIdName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvservergroupdcplan
#>
function Get-CVServerGroupDcPlan {
[OutputType([Commvault.Powershell.Models.IIdName], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ServerGroupId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVServerGroupDcPlan_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVServerGroupDcPlan_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of a serverGroup based on id
.Description
Get details of a serverGroup based on id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IServerGroup
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvservergroupiddetail
#>
function Get-CVServerGroupIdDetail {
[OutputType([Commvault.Powershell.Models.IServerGroup])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the serverGroupId whose details have to be fetched
    ${ServerGroupId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Header')]
    [System.String]
    # .
    ${Mode},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVServerGroupIdDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVServerGroupIdDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get All Server Groups
.Description
Get All Server Groups
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IServerGroupList
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvservergroup
#>
function Get-CVServerGroup {
[OutputType([Commvault.Powershell.Models.IServerGroupList])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVServerGroup_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to fetch schedules responsible for server plan RPO
.Description
API to fetch schedules responsible for server plan RPO
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IPlanSchedules
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvserverplanrpo
#>
function Get-CVServerPlanRpo {
[OutputType([Commvault.Powershell.Models.IPlanSchedules], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Server Plan
    ${PlanId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVServerPlanRpo_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVServerPlanRpo_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This end point returns the list of servers
.Description
This end point returns the list of servers
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IIdNameDisplayName
.Outputs
Commvault.Powershell.Models.IServersListResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvserver
#>
function Get-CVServer {
[OutputType([Commvault.Powershell.Models.IServersListResp], [Commvault.Powershell.Models.IIdNameDisplayName])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get1', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Company whose servers(with no packages) have to be fetched
    ${CompanyId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Get')]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Returns only infrastructure machines if value is 1 if 0, it returns all servers, default value is 1
    ${ShowOnlyInfrastructureMachines},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVServer_Get';
            Get1 = 'CommvaultPowershell.private\Get-CVServer_Get1';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVServer_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Returns a list of Service Commcells
.Description
Returns a list of Service Commcells
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IServiceCommcells
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvservicecommcell
#>
function Get-CVServiceCommcell {
[OutputType([Commvault.Powershell.Models.IServiceCommcells])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVServiceCommcell_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Api to fetch summary of a plan.
.Description
Api to fetch summary of a plan.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ISinglePlanSummary
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsingleplansummary
#>
function Get-CVSinglePlanSummary {
[OutputType([Commvault.Powershell.Models.ISinglePlanSummary], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the plan to get summary of
    ${PlanId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVSinglePlanSummary_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVSinglePlanSummary_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get all IntelliSnap enabled Clients
.Description
API to get all IntelliSnap enabled Clients
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IIntelliSnapClientsList
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsnapclient
#>
function Get-CVSnapClient {
[OutputType([Commvault.Powershell.Models.IIntelliSnapClientsList])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVSnapClient_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
get snap config for vendor.
.Description
get snap config for vendor.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGetSnapConfig
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsnapconfig
#>
function Get-CVSnapConfig {
[OutputType([Commvault.Powershell.Models.IGetSnapConfig])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${VendorId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVSnapConfig_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVSnapConfig_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Listing Snapshot of a particular array
.Description
Listing Snapshot of a particular array
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IListSnapshots
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsnapshot
#>
function Get-CVSnapshot {
[OutputType([Commvault.Powershell.Models.IListSnapshots])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            List = 'CommvaultPowershell.private\Get-CVSnapshot_List';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get all IntelliSnap enabled subclients for particular client
.Description
API to get all IntelliSnap enabled subclients for particular client
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IIntelliSnapSubclients
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsnapsubclient
#>
function Get-CVSnapSubclient {
[OutputType([Commvault.Powershell.Models.IIntelliSnapSubclients])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ClientId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVSnapSubclient_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVSnapSubclient_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get list of SNMP hosts for alert notification
.Description
Get list of SNMP hosts for alert notification
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.ISnmpConfigurationSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsnmphost
#>
function Get-CVSnmPhost {
[OutputType([Commvault.Powershell.Models.ISnmpConfigurationSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVSnmPhost_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get all software caches details
.Description
Get all software caches details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ISoftwareCacheDetail
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsoftwarecachdetail
#>
function Get-CVSoftwareCachDetail {
[OutputType([Commvault.Powershell.Models.ISoftwareCacheDetail], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVSoftwareCachDetail_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get software cache details for specific server
.Description
Get software cache details for specific server
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ISoftwareCacheDetail
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsoftwarecachedetail
#>
function Get-CVSoftwareCacheDetail {
[OutputType([Commvault.Powershell.Models.ISoftwareCacheDetail], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Software cache client id
    ${ClientId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVSoftwareCacheDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVSoftwareCacheDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to fetch applicable workload solutions for the user like File Server, Virtualization or Database
.Description
API to fetch applicable workload solutions for the user like File Server, Virtualization or Database
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ISolutionDetail
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsolutionid
#>
function Get-CVSolutionId {
[OutputType([Commvault.Powershell.Models.ISolutionDetail], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVSolutionId_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Gives a list of eligible source copies for given region id
.Description
Gives a list of eligible source copies for given region id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IPlanSourceCopy
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsourcecopy
#>
function Get-CVSourceCopy {
[OutputType([Commvault.Powershell.Models.IPlanSourceCopy])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of plan
    ${PlanId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Get list of source copy eligible for snap copy in given region.
    ${ForSnapCopy},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Region Id against which we want to check eligible source copies.
    # Skip if no region present.
    ${RegionId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVSourceCopy_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVSourceCopy_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get associated copies and plan which are utilizing this storage.
.Description
Get associated copies and plan which are utilizing this storage.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IStorageAssociatedCopy
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvstorageassociatedcopy
#>
function Get-CVStorageAssociatedCopy {
[OutputType([Commvault.Powershell.Models.IStorageAssociatedCopy])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the storage pool whose associated copies have to be fetched
    ${StoragePoolId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVStorageAssociatedCopy_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVStorageAssociatedCopy_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get all arrays at Subclient Level
.Description
API to get all arrays at Subclient Level
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IArrayLevel
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsubclientlvlarray
#>
function Get-CVSubclientLvlArray {
[OutputType([Commvault.Powershell.Models.IArrayLevel])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ClientId},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${SubclientId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVSubclientLvlArray_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVSubclientLvlArray_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to fetch Snap configs for Storage Arrays at subclient level
.Description
API to fetch Snap configs for Storage Arrays at subclient level
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ISnapConfigOverrideResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsubclientsnapconfig
#>
function Get-CVSubclientSnapConfig {
[OutputType([Commvault.Powershell.Models.ISnapConfigOverrideResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${SubclientId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVSubclientSnapConfig_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVSubclientSnapConfig_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint returns the details of a syslog server.
.Description
This endpoint returns the details of a syslog server.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.ISyslogStatus
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsyslogstatus
#>
function Get-CVSyslogStatus {
[OutputType([Commvault.Powershell.Models.ISyslogStatus])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVSyslogStatus_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Returns list of tags for the logged in user's default entity tag set along with count of associated entities
.Description
Returns list of tags for the logged in user's default entity tag set along with count of associated entities
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ITagAssociatedEntitiesResponse
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvtagassociatedentity
#>
function Get-CVTagAssociatedEntity {
[OutputType([Commvault.Powershell.Models.ITagAssociatedEntitiesResponse], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Id of the tag whose associated entities details needs to be returned
    ${TagId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVTagAssociatedEntity_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Gives list of values for given tagId
.Description
Gives list of values for given tagId
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ITagValueResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvtagvalue
#>
function Get-CVTagValue {
[OutputType([Commvault.Powershell.Models.ITagValueResponse], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the tag name whose value is requested
    ${TagId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVTagValue_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVTagValue_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get test failover machines for failover group
.Description
API to get test failover machines for failover group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ITestFailoverVirtualMachines
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvtestfailovermachinefailovergroup
#>
function Get-CVTestFailoverMachineFailoverGroup {
[OutputType([Commvault.Powershell.Models.ITestFailoverVirtualMachines], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the failover group
    ${FailoverGroupId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVTestFailoverMachineFailoverGroup_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVTestFailoverMachineFailoverGroup_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of triggered alert
.Description
Get details of triggered alert
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ITriggeredAlertsDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvtriggeredalertdetail
#>
function Get-CVTriggeredAlertDetail {
[OutputType([Commvault.Powershell.Models.ITriggeredAlertsDetails])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVTriggeredAlertDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVTriggeredAlertDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to fetch authentication methods of an existing user
.Description
Used to fetch authentication methods of an existing user
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IUserAuthenticationMethods
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvuserauthenticationmethod
#>
function Get-CVUserauthenticationMethod {
[OutputType([Commvault.Powershell.Models.IUserAuthenticationMethods])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the User whose authentication method details have to be fetched
    ${UserId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Set as true to fetch the list of available authentication methods for the user
    ${FetchAvailableMethodsOnly},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVUserauthenticationMethod_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVUserauthenticationMethod_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of a User based on id
.Description
Get details of a User based on id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IUser
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvuserdetail
#>
function Get-CVUserDetail {
[OutputType([Commvault.Powershell.Models.IUser])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the User whose details have to be fetched
    ${UserId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Header')]
    [System.String]
    # .
    ${Mode},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVUserDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVUserDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of a user-group based on id
.Description
Get details of a user-group based on id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IUserGroup
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvusergroupdetail
#>
function Get-CVUserGroupDetail {
[OutputType([Commvault.Powershell.Models.IUserGroup])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the user-group whose details have to be fetched
    ${UserGroupId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Header')]
    [System.String]
    # .
    ${Mode},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVUserGroupDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVUserGroupDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get a list of existing user groups.
.Description
Get a list of existing user groups.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IUserGroupSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvusergroup
#>
function Get-CVUserGroup {
[OutputType([Commvault.Powershell.Models.IUserGroupSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Header')]
    [System.String]
    # .
    ${Mode},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVUserGroup_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the S3 Access Key for the given user on their email
.Description
Get the S3 Access Key for the given user on their email
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvusers3accesskey
#>
function Get-CVUserS3AccessKey {
[OutputType([Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the user
    ${Id},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVUserS3AccessKey_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVUserS3AccessKey_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get All Users
.Description
Get All Users
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IUserSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvuser
#>
function Get-CVUser {
[OutputType([Commvault.Powershell.Models.IUserSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Returns only laptop users when set to true.
    # This param is only effective when EdgeMode header is passed.
    ${LaptopUsers},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int32]
    # Returns the list of users associated to the userGroupId provided.
    ${UserGroupId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVUser_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of a blackout window based on id
.Description
Get details of a blackout window based on id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IV4BlackoutWindow
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvv4blackoutwindowdetail
#>
function Get-CVV4BlackoutWindowDetail {
[OutputType([Commvault.Powershell.Models.IV4BlackoutWindow])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Blackout Window whose details have to be fetched
    ${BlackoutWindowId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVV4BlackoutWindowDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVV4BlackoutWindowDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get All Blackout Windows
.Description
Get All Blackout Windows
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IV4BlackoutWindowSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvv4blackoutwindow
#>
function Get-CVV4BlackoutWindow {
[OutputType([Commvault.Powershell.Models.IV4BlackoutWindowSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Shows blackout windows associated with the commcell whose id has been provided.
    ${CommcellId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Shows blackout windows associated with the company whose id has been provided.
    ${CompanyId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Shows blackout windows associated with the server group whose id has been provided.
    ${ServerGroupId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Shows blackout window at commcell level if set to true.
    ${ShowOnlyCommcellLevel},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVV4BlackoutWindow_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Gives list of valid laptop owner mapping in the response
.Description
Gives list of valid laptop owner mapping in the response
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ILaptopOwnerMapping
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvv4laptopownermappingpreview
#>
function Get-CVV4LaptopOwnerMappingPreview {
[OutputType([Commvault.Powershell.Models.ILaptopOwnerMapping], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVV4LaptopOwnerMappingPreview_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get all snap vendors
.Description
Get all snap vendors
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IVendorResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvvendor
#>
function Get-CVVendor {
[OutputType([Commvault.Powershell.Models.IVendorResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVVendor_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get all virtual machines
.Description
Get all virtual machines
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IVirtualMachineSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvvirtualmachine
#>
function Get-CVVirtualMachine {
[OutputType([Commvault.Powershell.Models.IVirtualMachineSummary])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVVirtualMachine_Get';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details for virtual machine
.Description
Get details for virtual machine
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IVirtualMachineDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvvmdetail
#>
function Get-CVVMDetail {
[OutputType([Commvault.Powershell.Models.IVirtualMachineDetails])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # The vmUUID can be obtained from GET /virtualMachines UUID property
    ${VMUuid},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${ShowInheritedAssociation},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVVMDetail_Get';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVVMDetail_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the details of all vmGroup
.Description
Get the details of all vmGroup
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IGetVMGroupResp
.Outputs
Commvault.Powershell.Models.IVMGroupSummary
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvvmgroup
#>
function Get-CVVMGroup {
[OutputType([Commvault.Powershell.Models.IVMGroupSummary], [Commvault.Powershell.Models.IGenericResp], [Commvault.Powershell.Models.IGetVMGroupResp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get1', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the VmGroup to get
    ${VMGroupId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Get')]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Id of the hypervisor to list vm groups
    ${HypervisorId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Get = 'CommvaultPowershell.private\Get-CVVMGroup_Get';
            Get1 = 'CommvaultPowershell.private\Get-CVVMGroup_Get1';
            GetViaIdentity = 'CommvaultPowershell.private\Get-CVVMGroup_GetViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to perform planned failover for failover group
.Description
API to perform planned failover for failover group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
System.String
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/group-cvplannedfailover
#>
function Group-CVPlannedFailover {
[OutputType([System.String], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Group', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Group', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # Name of DR operation.
    # Case insensitive
    ${DrOperation},

    [Parameter(ParameterSetName='Group', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the failover group
    ${FailoverGroupId},

    [Parameter(ParameterSetName='GroupViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Replication ID of particular VM in group to perform DR job on
    ${ReplicationId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Whether to skip disabling network adapter in DR job
    ${SkipDisableNetworkAdapter},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Group = 'CommvaultPowershell.private\Group-CVPlannedFailover_Group';
            GroupViaIdentity = 'CommvaultPowershell.private\Group-CVPlannedFailover_GroupViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
To install MediaAgent package on a server
.Description
To install MediaAgent package on a server
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IInstallMediaAgent
.Outputs
System.String
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IInstallMediaAgent>: .
  HostNames <String[]>: Host names where MediaAgent package is required to be installed
  Username <String>: Username to access hostnames
  [InstallLocation <String>]: Holds install path according to the chosen OSType
  [OSType <String>]: 
  [Password <String>]: password should be in base64 encoded string. password is optional only if SSHKeyFilePassphrase is specified
  [RebootIfRequired <Boolean?>]: 
  [SshKeyFilePassphrase <String>]: Applicable only for Unix OSType and should be in base64 encoded string
  [SshKeyPath <String>]: Applicable only for Unix OSType. Path provided should be valid on the CommServ Client
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/install-cvmediaagent
#>
function Install-CVMediaAgent {
[OutputType([System.String])]
[CmdletBinding(DefaultParameterSetName='InstallExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Install', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IInstallMediaAgent]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='InstallExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Host names where MediaAgent package is required to be installed
    ${HostNames},

    [Parameter(ParameterSetName='InstallExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Username to access hostnames
    ${Username},

    [Parameter(ParameterSetName='InstallExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Holds install path according to the chosen OSType
    ${InstallLocation},

    [Parameter(ParameterSetName='InstallExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OSType},

    [Parameter(ParameterSetName='InstallExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # password should be in base64 encoded string.
    # password is optional only if SSHKeyFilePassphrase is specified
    ${Password},

    [Parameter(ParameterSetName='InstallExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${RebootIfRequired},

    [Parameter(ParameterSetName='InstallExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Applicable only for Unix OSType and should be in base64 encoded string
    ${SshKeyFilePassphrase},

    [Parameter(ParameterSetName='InstallExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Applicable only for Unix OSType.
    # Path provided should be valid on the CommServ Client
    ${SshKeyPath},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Install = 'CommvaultPowershell.private\Install-CVMediaAgent_Install';
            InstallExpanded = 'CommvaultPowershell.private\Install-CVMediaAgent_InstallExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get all namespaces of a Kubernetes cluster with clusterId
.Description
API to get all namespaces of a Kubernetes cluster with clusterId
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IKubernetesClusterBrowseItem
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvbrowsekubernetenamespace
#>
function Invoke-CVBrowseKuberneteNamespace {
[OutputType([Commvault.Powershell.Models.IKubernetesClusterBrowseItem], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Browse', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Browse', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # clusterId is the ID of the Kubernetes cluster client
    ${ClusterId},

    [Parameter(ParameterSetName='BrowseViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Browse = 'CommvaultPowershell.private\Invoke-CVBrowseKuberneteNamespace_Browse';
            BrowseViaIdentity = 'CommvaultPowershell.private\Invoke-CVBrowseKuberneteNamespace_BrowseViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to get all StorageClasses of a Kubernetes cluster with clusterId
.Description
API to get all StorageClasses of a Kubernetes cluster with clusterId
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IKubernetesClusterBrowseItem
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvbrowsekubernetestorageclass
#>
function Invoke-CVBrowseKuberneteStorageClass {
[OutputType([Commvault.Powershell.Models.IKubernetesClusterBrowseItem], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Browse', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Browse', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # clusterId is the ID of the Kubernetes cluster client
    ${ClusterId},

    [Parameter(ParameterSetName='BrowseViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Browse = 'CommvaultPowershell.private\Invoke-CVBrowseKuberneteStorageClass_Browse';
            BrowseViaIdentity = 'CommvaultPowershell.private\Invoke-CVBrowseKuberneteStorageClass_BrowseViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to browse applications in a namespace
.Description
API to browse applications in a namespace
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IKubernetesClusterBrowseItem
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvbrowsenamespaceapplication
#>
function Invoke-CVBrowseNamespaceApplication {
[OutputType([Commvault.Powershell.Models.IKubernetesClusterBrowseItem], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Browse', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Browse', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # clusterId is the ID of the Kubernetes cluster client
    ${ClusterId},

    [Parameter(ParameterSetName='Browse', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # Name of the namespace to browse for content
    ${NameSpace},

    [Parameter(ParameterSetName='BrowseViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Browse = 'CommvaultPowershell.private\Invoke-CVBrowseNamespaceApplication_Browse';
            BrowseViaIdentity = 'CommvaultPowershell.private\Invoke-CVBrowseNamespaceApplication_BrowseViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to browse labels in a namespace
.Description
API to browse labels in a namespace
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IKubernetesClusterBrowseItem
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvbrowsenamespacelabel
#>
function Invoke-CVBrowseNamespaceLabel {
[OutputType([Commvault.Powershell.Models.IKubernetesClusterBrowseItem], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Browse', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Browse', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # clusterId is the ID of the Kubernetes cluster client
    ${ClusterId},

    [Parameter(ParameterSetName='Browse', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # Name of the namespace to browse for content
    ${NameSpace},

    [Parameter(ParameterSetName='BrowseViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Browse = 'CommvaultPowershell.private\Invoke-CVBrowseNamespaceLabel_Browse';
            BrowseViaIdentity = 'CommvaultPowershell.private\Invoke-CVBrowseNamespaceLabel_BrowseViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to browse volumes in a namespace
.Description
API to browse volumes in a namespace
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IKubernetesClusterBrowseItem
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvbrowsenamespacevolume
#>
function Invoke-CVBrowseNamespaceVolume {
[OutputType([Commvault.Powershell.Models.IKubernetesClusterBrowseItem], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Browse', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Browse', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # clusterId is the ID of the Kubernetes cluster client
    ${ClusterId},

    [Parameter(ParameterSetName='Browse', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # Name of the namespace to browse for content
    ${NameSpace},

    [Parameter(ParameterSetName='BrowseViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Browse = 'CommvaultPowershell.private\Invoke-CVBrowseNamespaceVolume_Browse';
            BrowseViaIdentity = 'CommvaultPowershell.private\Invoke-CVBrowseNamespaceVolume_BrowseViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to fetch available media agents which can be added as access paths for cloud storage
.Description
Used to fetch available media agents which can be added as access paths for cloud storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IIdNameDisplayName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvcloudgeteligiblemediaagent
#>
function Invoke-CVCloudGetEligibleMediaAgent {
[OutputType([Commvault.Powershell.Models.IIdNameDisplayName])]
[CmdletBinding(DefaultParameterSetName='Cloud', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Cloud', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the access path of which media agent has to be shared
    ${BucketId},

    [Parameter(ParameterSetName='Cloud', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the cloud storage pool for which media agent has to be added
    ${CloudStorageId},

    [Parameter(ParameterSetName='CloudViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Cloud = 'CommvaultPowershell.private\Invoke-CVCloudGetEligibleMediaAgent_Cloud';
            CloudViaIdentity = 'CommvaultPowershell.private\Invoke-CVCloudGetEligibleMediaAgent_CloudViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to reconfigure a Kubernetes cluster with clusterId
.Description
API to reconfigure a Kubernetes cluster with clusterId
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IGenericRespWithWarning
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvclusterreconfigurekubernete
#>
function Invoke-CVClusterReconfigureKubernete {
[OutputType([Commvault.Powershell.Models.IGenericRespWithWarning], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Cluster', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Cluster', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # clusterId is the ID of the Kubernetes cluster client
    ${ClusterId},

    [Parameter(ParameterSetName='ClusterViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Cluster = 'CommvaultPowershell.private\Invoke-CVClusterReconfigureKubernete_Cluster';
            ClusterViaIdentity = 'CommvaultPowershell.private\Invoke-CVClusterReconfigureKubernete_ClusterViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
To lock a configuration
.Description
To lock a configuration
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericRespWithWarning
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvcreatelockconfiguration
#>
function Invoke-CVCreatelockConfiguration {
[OutputType([Commvault.Powershell.Models.IGenericRespWithWarning])]
[CmdletBinding(DefaultParameterSetName='Createlock', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Createlock = 'CommvaultPowershell.private\Invoke-CVCreatelockConfiguration_Createlock';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
To unlock a configuration
.Description
To unlock a configuration
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericRespWithWarning
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvcreatelunlockconfiguration
#>
function Invoke-CVCreatelunlockConfiguration {
[OutputType([Commvault.Powershell.Models.IGenericRespWithWarning])]
[CmdletBinding(DefaultParameterSetName='Createlunlock', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Createlunlock = 'CommvaultPowershell.private\Invoke-CVCreatelunlockConfiguration_Createlunlock';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete a Modifier
.Description
Delete a Modifier
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvdeletek8smodifier
#>
function Invoke-CVDeletek8SModifier {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Deletek8', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Deletek8', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the cluster whose modifier has to be deleted.
    ${ClusterId},

    [Parameter(ParameterSetName='Deletek8', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # Name of the modifier to be deleted.
    ${ModifierName},

    [Parameter(ParameterSetName='Deletek8ViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Deletek8 = 'CommvaultPowershell.private\Invoke-CVDeletek8SModifier_Deletek8';
            Deletek8ViaIdentity = 'CommvaultPowershell.private\Invoke-CVDeletek8SModifier_Deletek8ViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete given tagValue for tagId
.Description
Delete given tagValue for tagId
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvdeletetagvalue
#>
function Invoke-CVDeletetagvalue {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Deletetagvalue', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Deletetagvalue', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # tag id
    ${TagId},

    [Parameter(ParameterSetName='Deletetagvalue', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # tag value to delete
    ${TagValue},

    [Parameter(ParameterSetName='DeletetagvalueViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Deletetagvalue = 'CommvaultPowershell.private\Invoke-CVDeletetagvalue_Deletetagvalue';
            DeletetagvalueViaIdentity = 'CommvaultPowershell.private\Invoke-CVDeletetagvalue_DeletetagvalueViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to fetch available media agents which can be added as access paths for disk storage
.Description
Used to fetch available media agents which can be added as access paths for disk storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IIdNameDisplayName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvdiskgeteligiblemediaagent
#>
function Invoke-CVDiskGetEligibleMediaAgent {
[OutputType([Commvault.Powershell.Models.IIdNameDisplayName])]
[CmdletBinding(DefaultParameterSetName='Disk', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Disk', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the back up location of which media agent has to be shared
    ${BackupLocationId},

    [Parameter(ParameterSetName='Disk', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the disk storage pool whose media agent has to be shared
    ${StoragePoolId},

    [Parameter(ParameterSetName='DiskViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disk = 'CommvaultPowershell.private\Invoke-CVDiskGetEligibleMediaAgent_Disk';
            DiskViaIdentity = 'CommvaultPowershell.private\Invoke-CVDiskGetEligibleMediaAgent_DiskViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Perform DDB disk management operations on MediaAgent
.Description
Perform DDB disk management operations on MediaAgent
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IMaddbDiskMgmtReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IMaddbDiskMgmtResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IMaddbDiskMgmtReq>: Request to perform DDB disk management operations on MediaAgent
  OpType <String>: Type of operation to be performed on the input disks
  [Disks <IDdbDiskInfo[]>]: 
    [ClientInfoId <Int64?>]: 
    [ClientInfoName <String>]: 
    [ConsumedSpaceMb <Int64?>]: Amount of space consumed by the DDB partitions hosted on this disk
    [DiskId <Int64?>]: Id of the DDB disk
    [DiskPath <String>]: File path of the DDB disk
    [FreeSpaceMb <Int64?>]: Available usable free space on the disk path
    [NumOfPartitions <Int64?>]: Number of DDB partitions hosted on this disk
    [PartitionList <IDdbSubStoreInfo[]>]: List of DDB partitions hosted on this disk
      [EstimatedSubstoreSizeInMb <Int64?>]: Estimated size in MBs occupied by the substore
      [IsSealed <Boolean?>]: Specify whether the substore is sealed or not
      [LastFailedMoveJobId <Int64?>]: JobId of the last failed move job for this substore
      [MoveStatusCode <Int64?>]: Status code for the move partition attempt on this substore
      [MoveStatusMsg <String>]: Status message for the move partition attempt on this substore
      [StoreId <Int64?>]: Id of the DDB store
      [StoreName <String>]: Name of the DDB store
      [SubStoreId <Int64?>]: Id of the DDB substore
    [Status <String>]: Satus of the disk
    [TotalSpaceMb <Int64?>]: Total space capacity of the disk path
  [TargetDiskId <Int64?>]: Id of the target DDB disk for Move DDB disk operation
  [TargetMaId <Int64?>]: Id of the target MediaAgent for Move DDB disk operation
  [TargetPath <String>]: Target path for Move DDB disk operation

DISKS <IDdbDiskInfo[]>: .
  [ClientInfoId <Int64?>]: 
  [ClientInfoName <String>]: 
  [ConsumedSpaceMb <Int64?>]: Amount of space consumed by the DDB partitions hosted on this disk
  [DiskId <Int64?>]: Id of the DDB disk
  [DiskPath <String>]: File path of the DDB disk
  [FreeSpaceMb <Int64?>]: Available usable free space on the disk path
  [NumOfPartitions <Int64?>]: Number of DDB partitions hosted on this disk
  [PartitionList <IDdbSubStoreInfo[]>]: List of DDB partitions hosted on this disk
    [EstimatedSubstoreSizeInMb <Int64?>]: Estimated size in MBs occupied by the substore
    [IsSealed <Boolean?>]: Specify whether the substore is sealed or not
    [LastFailedMoveJobId <Int64?>]: JobId of the last failed move job for this substore
    [MoveStatusCode <Int64?>]: Status code for the move partition attempt on this substore
    [MoveStatusMsg <String>]: Status message for the move partition attempt on this substore
    [StoreId <Int64?>]: Id of the DDB store
    [StoreName <String>]: Name of the DDB store
    [SubStoreId <Int64?>]: Id of the DDB substore
  [Status <String>]: Satus of the disk
  [TotalSpaceMb <Int64?>]: Total space capacity of the disk path

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvdisk
#>
function Invoke-CVDisk {
[OutputType([Commvault.Powershell.Models.IMaddbDiskMgmtResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='DiskExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Disk', Mandatory)]
    [Parameter(ParameterSetName='DiskExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the MediaAgent
    ${MediaAgentId},

    [Parameter(ParameterSetName='DiskViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='DiskViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Disk', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='DiskViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IMaddbDiskMgmtReq]
    # Request to perform DDB disk management operations on MediaAgent
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='DiskExpanded', Mandatory)]
    [Parameter(ParameterSetName='DiskViaIdentityExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Type of operation to be performed on the input disks
    ${OpType},

    [Parameter(ParameterSetName='DiskExpanded')]
    [Parameter(ParameterSetName='DiskViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDdbDiskInfo[]]
    # .
    # To construct, see NOTES section for DISKS properties and create a hash table.
    ${Disks},

    [Parameter(ParameterSetName='DiskExpanded')]
    [Parameter(ParameterSetName='DiskViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Id of the target DDB disk for Move DDB disk operation
    ${TargetDiskId},

    [Parameter(ParameterSetName='DiskExpanded')]
    [Parameter(ParameterSetName='DiskViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Id of the target MediaAgent for Move DDB disk operation
    ${TargetMaId},

    [Parameter(ParameterSetName='DiskExpanded')]
    [Parameter(ParameterSetName='DiskViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Target path for Move DDB disk operation
    ${TargetPath},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Disk = 'CommvaultPowershell.private\Invoke-CVDisk_Disk';
            DiskExpanded = 'CommvaultPowershell.private\Invoke-CVDisk_DiskExpanded';
            DiskViaIdentity = 'CommvaultPowershell.private\Invoke-CVDisk_DiskViaIdentity';
            DiskViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVDisk_DiskViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Download or Copy Software
.Description
Download or Copy Software
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IDownloadOrCopySoftware
.Outputs
System.Int64
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IDownloadOrCopySoftware>: Request body for download or copy software
  [CopyConfigurationDownloadPath <String>]: Path from where the software has to be downloaded.
  [CopyConfigurationPassword <String>]: Corresponding password of the user
  [CopyConfigurationUsername <String>]: If impersonation a user the, give the username of the user.
  [DownloadConfigurationFeatureRelease <String>]: Which specific feature release to download.
  [DownloadConfigurationLatestFixesForCurrentRelease <Boolean?>]: Boolean which determines whether to download latest fixews for current release.
  [DownloadConfigurationUnixDownloadOptions <String[]>]: gives list of all the target unix and MAC operating systems to download software for.
  [DownloadConfigurationUpgradeToLatestRelease <Boolean?>]: Boolean which determines whether to upgrade to latest release.
  [DownloadConfigurationWindowsDownloadOptions <String[]>]: gives list of all the target windows operating systems to download software for.
  [NotifyWhenJobCompletes <Boolean?>]: Boolean which determines whether to notify when software is downloaded or copied.
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvdownloadsoftware
#>
function Invoke-CVDownloadSoftware {
[OutputType([System.Int64])]
[CmdletBinding(DefaultParameterSetName='DownloadExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Download', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDownloadOrCopySoftware]
    # Request body for download or copy software
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='DownloadExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Path from where the software has to be downloaded.
    ${CopyConfigurationDownloadPath},

    [Parameter(ParameterSetName='DownloadExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Corresponding password of the user
    ${CopyConfigurationPassword},

    [Parameter(ParameterSetName='DownloadExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # If impersonation a user the, give the username of the user.
    ${CopyConfigurationUsername},

    [Parameter(ParameterSetName='DownloadExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Which specific feature release to download.
    ${DownloadConfigurationFeatureRelease},

    [Parameter(ParameterSetName='DownloadExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean which determines whether to download latest fixews for current release.
    ${DownloadConfigurationLatestFixesForCurrentRelease},

    [Parameter(ParameterSetName='DownloadExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # gives list of all the target unix and MAC operating systems to download software for.
    ${DownloadConfigurationUnixDownloadOptions},

    [Parameter(ParameterSetName='DownloadExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean which determines whether to upgrade to latest release.
    ${DownloadConfigurationUpgradeToLatestRelease},

    [Parameter(ParameterSetName='DownloadExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # gives list of all the target windows operating systems to download software for.
    ${DownloadConfigurationWindowsDownloadOptions},

    [Parameter(ParameterSetName='DownloadExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean which determines whether to notify when software is downloaded or copied.
    ${NotifyWhenJobCompletes},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Download = 'CommvaultPowershell.private\Invoke-CVDownloadSoftware_Download';
            DownloadExpanded = 'CommvaultPowershell.private\Invoke-CVDownloadSoftware_DownloadExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to exclude instance from SLA.
Applicable for Salesforce & Office365
.Description
Used to exclude instance from SLA.
Applicable for Salesforce & Office365
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvexcludeslainstance
#>
function Invoke-CVExcludeSlaInstance {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Exclude', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Exclude', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the instance to modify
    ${InstanceId},

    [Parameter(ParameterSetName='ExcludeViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Exclude = 'CommvaultPowershell.private\Invoke-CVExcludeSlaInstance_Exclude';
            ExcludeViaIdentity = 'CommvaultPowershell.private\Invoke-CVExcludeSlaInstance_ExcludeViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Fetch local authentication details of the company
.Description
Fetch local authentication details of the company
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ILocalAuthenticationDetailsResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvfetchlocalauthenticationdetil
#>
function Invoke-CVFetchLocalAuthenticationDetil {
[OutputType([Commvault.Powershell.Models.ILocalAuthenticationDetailsResponse])]
[CmdletBinding(DefaultParameterSetName='Fetch', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Fetch', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the company
    ${CompanyId},

    [Parameter(ParameterSetName='FetchViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Fetch = 'CommvaultPowershell.private\Invoke-CVFetchLocalAuthenticationDetil_Fetch';
            FetchViaIdentity = 'CommvaultPowershell.private\Invoke-CVFetchLocalAuthenticationDetil_FetchViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Fetches tape details based on the tape library Id provided
.Description
Fetches tape details based on the tape library Id provided
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ITapeDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvfetchtapedetail
#>
function Invoke-CVFetchTapeDetail {
[OutputType([Commvault.Powershell.Models.ITapeDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Fetch', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Fetch', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the library to view the data
    ${LibraryId},

    [Parameter(ParameterSetName='FetchViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Fetch = 'CommvaultPowershell.private\Invoke-CVFetchTapeDetail_Fetch';
            FetchViaIdentity = 'CommvaultPowershell.private\Invoke-CVFetchTapeDetail_FetchViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Fetch tape media details based on the tape library Id
.Description
Fetch tape media details based on the tape library Id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ITapeMediaDetails
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvfetchtapemediadetail
#>
function Invoke-CVFetchTapeMediaDetail {
[OutputType([Commvault.Powershell.Models.ITapeMediaDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Fetch', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Fetch', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the library to view the data
    ${LibraryId},

    [Parameter(ParameterSetName='FetchViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Fetch = 'CommvaultPowershell.private\Invoke-CVFetchTapeMediaDetail_Fetch';
            FetchViaIdentity = 'CommvaultPowershell.private\Invoke-CVFetchTapeMediaDetail_FetchViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint is used to create network topology.
.Description
This endpoint is used to create network topology.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IFirewallTopologyCreateReq
.Outputs
Commvault.Powershell.Models.IFirewallTopologyCreateResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IFirewallTopologyCreateReq>: FirewallTopologyReq
  [ClientType <String>]: The type of clients associated with the topology.
  [EncryptTraffic <Boolean?>]: Flag determining if we want the data from tunnel to use HTTPS protocol
  [FirewallGroups <IFirewallTopologyGroups[]>]: 
    [AdvancedOptionKeepAliveInterval <Int64?>]: The interval in seconds for sending keep-alive packets, to maintain the session if backup traffic has an extended pause.
    [AdvancedOptionTunnelPort <Int64?>]: The port defined for communications
    [ClientGroupId <Int64?>]: The id of the client group
    [GroupType <String>]: FirewallFwGroupType
    [Mnemonic <String>]: Custom names(mnemonics) given to pre-defined smart client groups
  [TopologyName <String>]: 
  [TopologyType <String>]: The type of topology of client groups (and sometimes network gateway) for this instance.
  [TunnelProtocol <String>]: The protocol for outgoing communication
  [TunnelsPerRoute <Int64?>]: The number of tunnel connections per route
  [UseWildCardProxy <Boolean?>]: Flag determining wether network gateways are used to connect all infrastructure machines

FIREWALLGROUPS <IFirewallTopologyGroups[]>: .
  [AdvancedOptionKeepAliveInterval <Int64?>]: The interval in seconds for sending keep-alive packets, to maintain the session if backup traffic has an extended pause.
  [AdvancedOptionTunnelPort <Int64?>]: The port defined for communications
  [ClientGroupId <Int64?>]: The id of the client group
  [GroupType <String>]: FirewallFwGroupType
  [Mnemonic <String>]: Custom names(mnemonics) given to pre-defined smart client groups
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvfirewalltopology
#>
function Invoke-CVFirewallTopology {
[OutputType([Commvault.Powershell.Models.IFirewallTopologyCreateResp])]
[CmdletBinding(DefaultParameterSetName='PostExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Post', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IFirewallTopologyCreateReq]
    # FirewallTopologyReq
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PostExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The type of clients associated with the topology.
    ${ClientType},

    [Parameter(ParameterSetName='PostExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag determining if we want the data from tunnel to use HTTPS protocol
    ${EncryptTraffic},

    [Parameter(ParameterSetName='PostExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IFirewallTopologyGroups[]]
    # .
    # To construct, see NOTES section for FIREWALLGROUPS properties and create a hash table.
    ${FirewallGroups},

    [Parameter(ParameterSetName='PostExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${TopologyName},

    [Parameter(ParameterSetName='PostExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The type of topology of client groups (and sometimes network gateway) for this instance.
    ${TopologyType},

    [Parameter(ParameterSetName='PostExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The protocol for outgoing communication
    ${TunnelProtocol},

    [Parameter(ParameterSetName='PostExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The number of tunnel connections per route
    ${TunnelsPerRoute},

    [Parameter(ParameterSetName='PostExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag determining wether network gateways are used to connect all infrastructure machines
    ${UseWildCardProxy},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Post = 'CommvaultPowershell.private\Invoke-CVFirewallTopology_Post';
            PostExpanded = 'CommvaultPowershell.private\Invoke-CVFirewallTopology_PostExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API for snap multi node force unmount operation.
Please be aware, triggering this API will not physically unmount the clones from the storage array or MA, so ensure that you unmapped the clones on the array and cleanup the mount host and LVM before using this operation.
.Description
API for snap multi node force unmount operation.
Please be aware, triggering this API will not physically unmount the clones from the storage array or MA, so ensure that you unmapped the clones on the array and cleanup the mount host and LVM before using this operation.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ISnapNodeReq
.Outputs
Commvault.Powershell.Models.ISnapReconResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISnapNodeReq>: Request template for multi node unmount and instant clone delete
  [MountVolumeIds <Int64[]>]: Volume Ids of the Snaps to include for multi node unmount or instant clone delete
  [Volume <ISnapVolumes[]>]: Array of volumes to include for the operation
    SmVolumeId <Int64>: smVolumeId of the snap
    [CommCellId <Int64?>]: Commcell Id of the setup

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

VOLUME <ISnapVolumes[]>: Array of volumes to include for the operation
  SmVolumeId <Int64>: smVolumeId of the snap
  [CommCellId <Int64?>]: Commcell Id of the setup
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvforce
#>
function Invoke-CVForce {
[OutputType([Commvault.Powershell.Models.ISnapReconResp])]
[CmdletBinding(DefaultParameterSetName='ForceExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Force', Mandatory)]
    [Parameter(ParameterSetName='ForceExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='ForceViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ForceViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Force', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ForceViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapNodeReq]
    # Request template for multi node unmount and instant clone delete
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ForceExpanded')]
    [Parameter(ParameterSetName='ForceViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64[]]
    # Volume Ids of the Snaps to include for multi node unmount or instant clone delete
    ${MountVolumeIds},

    [Parameter(ParameterSetName='ForceExpanded')]
    [Parameter(ParameterSetName='ForceViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapVolumes[]]
    # Array of volumes to include for the operation
    # To construct, see NOTES section for VOLUME properties and create a hash table.
    ${Volume},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Force = 'CommvaultPowershell.private\Invoke-CVForce_Force';
            ForceExpanded = 'CommvaultPowershell.private\Invoke-CVForce_ForceExpanded';
            ForceViaIdentity = 'CommvaultPowershell.private\Invoke-CVForce_ForceViaIdentity';
            ForceViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVForce_ForceViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to include instance in SLA.
Applicable for Salesforce
.Description
Used to include instance in SLA.
Applicable for Salesforce
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvincludeslainstance
#>
function Invoke-CVIncludeSlaInstance {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Include', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Include', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the instance to modify
    ${InstanceId},

    [Parameter(ParameterSetName='IncludeViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Include = 'CommvaultPowershell.private\Invoke-CVIncludeSlaInstance_Include';
            IncludeViaIdentity = 'CommvaultPowershell.private\Invoke-CVIncludeSlaInstance_IncludeViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
To start the data collection job on inventory
.Description
To start the data collection job on inventory
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvinventorycrawl
#>
function Invoke-CVInventoryCrawl {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Inventory', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Inventory', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${InventoryId},

    [Parameter(ParameterSetName='InventoryViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Inventory = 'CommvaultPowershell.private\Invoke-CVInventoryCrawl_Inventory';
            InventoryViaIdentity = 'CommvaultPowershell.private\Invoke-CVInventoryCrawl_InventoryViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Launching recovery action for a recovery group
.Description
Launching recovery action for a recovery group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IRecoveryActionRequest
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
System.Int64
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IRecoveryActionRequest>: RecoveryActionRequest
  [Entities <IIdName[]>]: 
    [Id <Int64?>]: 
    [Name <String>]: 
  [RecoveryGroupId <Int64?>]: 
  [RecoveryGroupName <String>]: 

ENTITIES <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvinvokerecoverygrouprecover
#>
function Invoke-CVInvokeRecoveryGroupRecover {
[OutputType([System.Int64], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='InvokeExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Invoke', Mandatory)]
    [Parameter(ParameterSetName='InvokeExpanded', Mandatory)]
    [Parameter(ParameterSetName='InvokeViaIdentityExpanded')]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Recovery group Id
    ${RecoveryGroupId},

    [Parameter(ParameterSetName='InvokeViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='InvokeViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Invoke', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='InvokeViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRecoveryActionRequest]
    # RecoveryActionRequest
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='InvokeExpanded')]
    [Parameter(ParameterSetName='InvokeViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for ENTITIES properties and create a hash table.
    ${Entities},

    [Parameter(ParameterSetName='InvokeExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(ParameterSetName='InvokeExpanded')]
    [Parameter(ParameterSetName='InvokeViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RecoveryGroupName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Invoke = 'CommvaultPowershell.private\Invoke-CVInvokeRecoveryGroupRecover_Invoke';
            InvokeExpanded = 'CommvaultPowershell.private\Invoke-CVInvokeRecoveryGroupRecover_InvokeExpanded';
            InvokeViaIdentity = 'CommvaultPowershell.private\Invoke-CVInvokeRecoveryGroupRecover_InvokeViaIdentity';
            InvokeViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVInvokeRecoveryGroupRecover_InvokeViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to create laptop owner mappings
.Description
API to create laptop owner mappings
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICreateLaptopOwnerMapping
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ICreateLaptopOwnerMapping>: POST request for adding new laptop owner mapping, The mandotary fields are combination of multiple properties SerialNumber AND (host OR laptopName) AND (ownerEmail OR ownerUPN)
  [LaptopOwnerMapping <ICreateLaptopOwnerInfo[]>]: 
    [CompanyId <Int64?>]: 
    [CompanyName <String>]: 
    [Host <String>]: Host name of the laptop
    [LaptopName <String>]: Display name of the laptop
    [OSType <String>]: Operating system of the owner
    [OwnerEmail <String>]: Email address of the owner
    [OwnerUpn <String>]: UPN of the owner
    [SerialNumber <String>]: Serial number of the laptop

LAPTOPOWNERMAPPING <ICreateLaptopOwnerInfo[]>: .
  [CompanyId <Int64?>]: 
  [CompanyName <String>]: 
  [Host <String>]: Host name of the laptop
  [LaptopName <String>]: Display name of the laptop
  [OSType <String>]: Operating system of the owner
  [OwnerEmail <String>]: Email address of the owner
  [OwnerUpn <String>]: UPN of the owner
  [SerialNumber <String>]: Serial number of the laptop
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvlaptopownermapping
#>
function Invoke-CVLaptopOwnerMapping {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='PostExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Post', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICreateLaptopOwnerMapping]
    # POST request for adding new laptop owner mapping, The mandotary fields are combination of multiple properties SerialNumber AND (host OR laptopName) AND (ownerEmail OR ownerUPN)
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PostExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICreateLaptopOwnerInfo[]]
    # .
    # To construct, see NOTES section for LAPTOPOWNERMAPPING properties and create a hash table.
    ${LaptopOwnerMapping},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Post = 'CommvaultPowershell.private\Invoke-CVLaptopOwnerMapping_Post';
            PostExpanded = 'CommvaultPowershell.private\Invoke-CVLaptopOwnerMapping_PostExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Simplified API to create a laptop
.Description
Simplified API to create a laptop
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IAddLaptop
.Outputs
Commvault.Powershell.Models.IAddLaptopResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IAddLaptop>: .
  ClientNames <String[]>: list of hostName of computers
  OS <String>: the os type of computers
  Password <String>: password (base64 encoded) required for authentication of jobs
  UserName <String>: username required for authentication of jobs
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvlaptop
#>
function Invoke-CVLaptop {
[OutputType([Commvault.Powershell.Models.IAddLaptopResp])]
[CmdletBinding(DefaultParameterSetName='PostExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Post', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAddLaptop]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PostExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # list of hostName of computers
    ${ClientNames},

    [Parameter(ParameterSetName='PostExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # the os type of computers
    ${OS},

    [Parameter(ParameterSetName='PostExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # password (base64 encoded) required for authentication of jobs
    ${Password},

    [Parameter(ParameterSetName='PostExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # username required for authentication of jobs
    ${UserName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Post = 'CommvaultPowershell.private\Invoke-CVLaptop_Post';
            PostExpanded = 'CommvaultPowershell.private\Invoke-CVLaptop_PostExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
To Backup the virtual machines in vmgroup
.Description
To Backup the virtual machines in vmgroup
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ICreateTaskRespforBackup
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmachine
#>
function Invoke-CVMachine {
[OutputType([Commvault.Powershell.Models.ICreateTaskRespforBackup], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Machine', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Machine', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # Id of the Virtual Machine to backup
    ${VMUuid},

    [Parameter(ParameterSetName='MachineViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Backup level , Default :Incremental
    ${BackupLevel},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Machine = 'CommvaultPowershell.private\Invoke-CVMachine_Machine';
            MachineViaIdentity = 'CommvaultPowershell.private\Invoke-CVMachine_MachineViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify access path details of specific bucket of a specific cloud storage
.Description
Modify access path details of specific bucket of a specific cloud storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICloudStorageAdvanced
.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ICloudStorageAdvanced>: CloudStorageAdvanced
  [Access <String>]: The access type for the access path can be either read (writing to path not allowed) or read and write (writing to path allowed).
  [Enable <Boolean?>]: Enable/Disable access of bucket to a media Agent

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyaccesspath
#>
function Invoke-CVModifyAccessPath {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of access path (can be fetched from GET Bucket Details API)
    ${AccessPathId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of Bucket
    ${BucketId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of cloud Storage
    ${CloudStorageId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICloudStorageAdvanced]
    # CloudStorageAdvanced
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The access type for the access path can be either read (writing to path not allowed) or read and write (writing to path allowed).
    ${Access},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable/Disable access of bucket to a media Agent
    ${Enable},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyAccessPath_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyAccessPath_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyAccessPath_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyAccessPath_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify Backup Destination for a Plan
.Description
Modify Backup Destination for a Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateArchivePlanBackupDestination
.Outputs
Commvault.Powershell.Models.IPlanBackupDestinationResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateArchivePlanBackupDestination>: .
  [EnableDataAging <Boolean?>]: Tells if this copy has data aging enabled
  [NewName <String>]: New name for backup destination
  [OverrideRetentionSettings <Boolean?>]: Tells if this copy should use storage pool retention period days or the retention defined for this copy. Set as true to use retention defined on this copy.
  [RetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention.
  [SourceCopyId <Int64?>]: 
  [SourceCopyName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyarchivebackupdestination
#>
function Invoke-CVModifyArchiveBackupDestination {
[OutputType([Commvault.Powershell.Models.IPlanBackupDestinationResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backupDestination to be modified
    ${BackupDestinationId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to modify
    ${PlanId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateArchivePlanBackupDestination]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Tells if this copy has data aging enabled
    ${EnableDataAging},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # New name for backup destination
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Tells if this copy should use storage pool retention period days or the retention defined for this copy.
    # Set as true to use retention defined on this copy.
    ${OverrideRetentionSettings},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Retention period in days.
    # -1 can be specified for infinite retention.
    ${RetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SourceCopyId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SourceCopyName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyArchiveBackupDestination_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyArchiveBackupDestination_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyArchiveBackupDestination_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyArchiveBackupDestination_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify existing archive plan details
.Description
Modify existing archive plan details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateArchivePlan
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateArchivePlan>: .
  [AllowPlanOverride <Boolean?>]: Flag to enable overriding of plan. Once enabled, cannot be disabled.
  [ArchivingRuleAfterArchiving <String>]: After an archive job, replace the file that meets the archiving rules with a stub or delete the file that meets the archiving rules
  [ArchivingRuleFileSize <Int64?>]: To archive files based on the size of the file, specify the minimum file size in KB.
  [ArchivingRuleFileTimestamp <Int64?>]: To archive files based on the last accessed or modified date of each file within the folder, specify the number of days. Should be supplied with fileTimestampMethod.
  [ArchivingRuleFileTimestampMethod <String>]: 
  [BackupFrequency <Int64?>]: Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
  [BackupFrequencyDayOfMonth <Int64?>]: Day on which to run the schedule, applicable for monthly, yearly
  [BackupFrequencyDayOfWeek <String>]: 
  [BackupFrequencyMonthOfYear <String>]: 
  [BackupFrequencyScheduleFrequencyType <String>]: schedule frequency type
  [BackupFrequencyStartTime <Int64?>]: start time of schedule in seconds for daily, weekly, monthly, yearly frequency
  [BackupFrequencyWeekOfMonth <String>]: Specific week of a month
  [BackupFrequencyWeeklyDays <String[]>]: Days of the week for weekly frequency
  [NewName <String>]: New plan name to update
  [OverrideRestrictionArchivingRules <String>]: 
  [OverrideRestrictionRpo <String>]: 
  [OverrideRestrictionStoragePool <String>]: 
  [RegionToConfigureId <Int64?>]: 
  [RegionToConfigureName <String>]: 
  [RpoBackupWindow <IDayAndTime[]>]: Archive job will run only in the specified archive window
    [DayOfWeek <String[]>]: 
    [EndTime <Int64?>]: Time in seconds since the beginning of the day
    [StartTime <Int64?>]: Time in seconds since the beginning of the day
  [SlaEnableAfterDelay <Int64?>]: Time provided in Unix format. Give 0 to reset any existing delay.
  [SlaExcludeFromSla <Boolean?>]: Flag to set to exclude plan from SLA
  [SlaExclusionReason <String>]: Reason for exclusion from SLA
  [SlaLogSlaMinutes <Int64?>]: Database log SLA period in Minutes
  [SlaPeriod <Int64?>]: SLA Period in Days
  [SlaUseSystemDefaultSla <Boolean?>]: Flag to set to use System Default Service Level Agreement

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

RPOBACKUPWINDOW <IDayAndTime[]>: Archive job will run only in the specified archive window
  [DayOfWeek <String[]>]: 
  [EndTime <Int64?>]: Time in seconds since the beginning of the day
  [StartTime <Int64?>]: Time in seconds since the beginning of the day
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyarchiveplan
#>
function Invoke-CVModifyArchivePlan {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the plan
    ${PlanId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateArchivePlan]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to enable overriding of plan.
    # Once enabled, cannot be disabled.
    ${AllowPlanOverride},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # After an archive job, replace the file that meets the archiving rules with a stub or delete the file that meets the archiving rules
    ${ArchivingRuleAfterArchiving},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # To archive files based on the size of the file, specify the minimum file size in KB.
    ${ArchivingRuleFileSize},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # To archive files based on the last accessed or modified date of each file within the folder, specify the number of days.
    # Should be supplied with fileTimestampMethod.
    ${ArchivingRuleFileTimestamp},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ArchivingRuleFileTimestampMethod},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Frequency of the schedule based on schedule frequency type eg.
    # for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days.
    # for Monthly 2 is it repeats every 2 months
    ${BackupFrequency},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Day on which to run the schedule, applicable for monthly, yearly
    ${BackupFrequencyDayOfMonth},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${BackupFrequencyDayOfWeek},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${BackupFrequencyMonthOfYear},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # schedule frequency type
    ${BackupFrequencyScheduleFrequencyType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # start time of schedule in seconds for daily, weekly, monthly, yearly frequency
    ${BackupFrequencyStartTime},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specific week of a month
    ${BackupFrequencyWeekOfMonth},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Days of the week for weekly frequency
    ${BackupFrequencyWeeklyDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # New plan name to update
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionArchivingRules},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionRpo},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionStoragePool},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RegionToConfigureId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RegionToConfigureName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDayAndTime[]]
    # Archive job will run only in the specified archive window
    # To construct, see NOTES section for RPOBACKUPWINDOW properties and create a hash table.
    ${RpoBackupWindow},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Time provided in Unix format.
    # Give 0 to reset any existing delay.
    ${SlaEnableAfterDelay},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to set to exclude plan from SLA
    ${SlaExcludeFromSla},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Reason for exclusion from SLA
    ${SlaExclusionReason},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Database log SLA period in Minutes
    ${SlaLogSlaMinutes},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # SLA Period in Days
    ${SlaPeriod},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to set to use System Default Service Level Agreement
    ${SlaUseSystemDefaultSla},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyArchivePlan_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyArchivePlan_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyArchivePlan_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyArchivePlan_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify Backup Destination details for a Plan
.Description
Modify Backup Destination details for a Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdatePlanBackupDestinationDetails
.Outputs
Commvault.Powershell.Models.IPlanBackupDestinationResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdatePlanBackupDestinationDetails>: .
  [BackupTypeBackupTypesCopiedFrom <Int64?>]: Tells what start date, backup types should be copied from. The date is provided in unix time format in number of seconds. -1 means initial backup date.
  [BackupTypeBackupTypesToCopy <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [BackupTypeFullBackupTypesToCopy <String>]: Which type of backup type should be copied for the given backup destination when backup type is not all jobs. Default is LAST while adding new backup destination.
  [FirstExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [FirstExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [FirstExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [GeneralIsActive <Boolean?>]: Toggle to keep backup destination active
  [Mappings <ISnapshotCopyMapping[]>]: 
    [SourceId <Int64?>]: 
    [SourceName <String>]: 
    [SourceVendorId <Int64?>]: 
    [SourceVendorName <String>]: 
    [TargetId <Int64?>]: 
    [TargetName <String>]: 
    [TargetVendorId <Int64?>]: 
    [TargetVendorName <String>]: 
    [Vendor <String>]: Snapshot vendors available for Snap Copy mappings
  [NewName <String>]: New name for backup destination
  [RetentionRuleEnableDataAging <Boolean?>]: Tells if this copy has data aging enabled
  [RetentionRuleFullBackupTypesToBeRetained <String>]: Which type of backup type should be copied for the given backup destination when backup type is not all jobs. Default is LAST while adding new backup destination.
  [RetentionRuleOverrideRetentionSettings <Boolean?>]: Tells if this copy should use storage pool retention period days or the retention defined for this copy. Set as true to use retention defined on this copy.
  [RetentionRuleRetentionPeriodDays <Int64?>]: Retention period in days
  [RetentionRuleSnapRecoveryPoints <Int64?>]: Number of snap recovery points for snap copy for retention
  [RetentionRuleType <String>]: Which type of retention rule should be used for the given backup destination
  [RetentionRuleUseExtendedRetentionRules <Boolean?>]: Should extended retention rules be used
  [SecondExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [SecondExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [SecondExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [SourceId <Int64?>]: 
  [SourceName <String>]: 
  [ThirdExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [ThirdExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [ThirdExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

MAPPINGS <ISnapshotCopyMapping[]>: .
  [SourceId <Int64?>]: 
  [SourceName <String>]: 
  [SourceVendorId <Int64?>]: 
  [SourceVendorName <String>]: 
  [TargetId <Int64?>]: 
  [TargetName <String>]: 
  [TargetVendorId <Int64?>]: 
  [TargetVendorName <String>]: 
  [Vendor <String>]: Snapshot vendors available for Snap Copy mappings
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifybackupdestinationdetail
#>
function Invoke-CVModifyBackupDestinationDetail {
[OutputType([Commvault.Powershell.Models.IPlanBackupDestinationResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backupDestination to be modified
    ${BackupDestinationId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to modify
    ${PlanId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdatePlanBackupDestinationDetails]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Tells what start date, backup types should be copied from.
    # The date is provided in unix time format in number of seconds.
    # -1 means initial backup date.
    ${BackupTypeBackupTypesCopiedFrom},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${BackupTypeBackupTypesToCopy},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Which type of backup type should be copied for the given backup destination when backup type is not all jobs.
    # Default is LAST while adding new backup destination.
    ${BackupTypeFullBackupTypesToCopy},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If this is set as true, no need to specify retentionPeriodDays.
    ${FirstExtendedRetentionRuleIsInfiniteRetention},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # If this is set, no need to specify isInfiniteRetention as false.
    ${FirstExtendedRetentionRuleRetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${FirstExtendedRetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Toggle to keep backup destination active
    ${GeneralIsActive},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapshotCopyMapping[]]
    # .
    # To construct, see NOTES section for MAPPINGS properties and create a hash table.
    ${Mappings},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # New name for backup destination
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Tells if this copy has data aging enabled
    ${RetentionRuleEnableDataAging},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Which type of backup type should be copied for the given backup destination when backup type is not all jobs.
    # Default is LAST while adding new backup destination.
    ${RetentionRuleFullBackupTypesToBeRetained},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Tells if this copy should use storage pool retention period days or the retention defined for this copy.
    # Set as true to use retention defined on this copy.
    ${RetentionRuleOverrideRetentionSettings},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Retention period in days
    ${RetentionRuleRetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of snap recovery points for snap copy for retention
    ${RetentionRuleSnapRecoveryPoints},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Which type of retention rule should be used for the given backup destination
    ${RetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Should extended retention rules be used
    ${RetentionRuleUseExtendedRetentionRules},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If this is set as true, no need to specify retentionPeriodDays.
    ${SecondExtendedRetentionRuleIsInfiniteRetention},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # If this is set, no need to specify isInfiniteRetention as false.
    ${SecondExtendedRetentionRuleRetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${SecondExtendedRetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SourceId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SourceName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If this is set as true, no need to specify retentionPeriodDays.
    ${ThirdExtendedRetentionRuleIsInfiniteRetention},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # If this is set, no need to specify isInfiniteRetention as false.
    ${ThirdExtendedRetentionRuleRetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${ThirdExtendedRetentionRuleType},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyBackupDestinationDetail_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyBackupDestinationDetail_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyBackupDestinationDetail_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyBackupDestinationDetail_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify Backup Destination.
Only primary backup destination will be considered for region updation.\nIf the primary backup destination is not associated with a plan, only then the region associaion can be modified.
.Description
Modify Backup Destination.
Only primary backup destination will be considered for region updation.\nIf the primary backup destination is not associated with a plan, only then the region associaion can be modified.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateBackupDestination
.Outputs
Commvault.Powershell.Models.IPlanBackupDestinationResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateBackupDestination>: Region can be modified only when the backup destination does not belong to a region already
  [BackupStartTime <Int64?>]: Specify the Backup start time in seconds. The time is provided in unix time format.
  [BackupsToCopy <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [EnableDataAging <Boolean?>]: Tells if this copy has data aging enabled
  [FirstExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [FirstExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [FirstExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [Mappings <ISnapshotCopyMapping[]>]: 
    [SourceId <Int64?>]: 
    [SourceName <String>]: 
    [SourceVendorId <Int64?>]: 
    [SourceVendorName <String>]: 
    [TargetId <Int64?>]: 
    [TargetName <String>]: 
    [TargetVendorId <Int64?>]: 
    [TargetVendorName <String>]: 
    [Vendor <String>]: Snapshot vendors available for Snap Copy mappings
  [Name <String>]: Name of backup destination
  [OverrideRetentionSettings <Boolean?>]: Tells if this copy should use storage pool retention period days or the retention defined for this copy. Set as true to use retention defined on this copy.
  [RegionId <Int64?>]: 
  [RegionName <String>]: 
  [RetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention.
  [RetentionRuleType <String>]: Which type of retention rule should be used for the given backup destination
  [SecondExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [SecondExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [SecondExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [SnapRecoveryPoints <Int64?>]: Number of snap recovery points for snap copy for retention. Can be specified instead of retention period in Days for snap copy.
  [SourceCopyId <Int64?>]: 
  [SourceCopyName <String>]: 
  [ThirdExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [ThirdExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [ThirdExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [UseExtendedRetentionRules <Boolean?>]: Use extended retention rules. Must specify if updating extended retention rules.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

MAPPINGS <ISnapshotCopyMapping[]>: .
  [SourceId <Int64?>]: 
  [SourceName <String>]: 
  [SourceVendorId <Int64?>]: 
  [SourceVendorName <String>]: 
  [TargetId <Int64?>]: 
  [TargetName <String>]: 
  [TargetVendorId <Int64?>]: 
  [TargetVendorName <String>]: 
  [Vendor <String>]: Snapshot vendors available for Snap Copy mappings
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifybackupdestinationwithoutplaninfo
#>
function Invoke-CVModifyBackupDestinationWithoutPlanInfo {
[OutputType([Commvault.Powershell.Models.IPlanBackupDestinationResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backupDestination to be modified
    ${BackupDestinationId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateBackupDestination]
    # Region can be modified only when the backup destination does not belong to a region already
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify the Backup start time in seconds.
    # The time is provided in unix time format.
    ${BackupStartTime},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${BackupsToCopy},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Tells if this copy has data aging enabled
    ${EnableDataAging},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If this is set as true, no need to specify retentionPeriodDays.
    ${FirstExtendedRetentionRuleIsInfiniteRetention},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # If this is set, no need to specify isInfiniteRetention as false.
    ${FirstExtendedRetentionRuleRetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${FirstExtendedRetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapshotCopyMapping[]]
    # .
    # To construct, see NOTES section for MAPPINGS properties and create a hash table.
    ${Mappings},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of backup destination
    ${Name},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Tells if this copy should use storage pool retention period days or the retention defined for this copy.
    # Set as true to use retention defined on this copy.
    ${OverrideRetentionSettings},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RegionId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RegionName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Retention period in days.
    # -1 can be specified for infinite retention.
    ${RetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Which type of retention rule should be used for the given backup destination
    ${RetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If this is set as true, no need to specify retentionPeriodDays.
    ${SecondExtendedRetentionRuleIsInfiniteRetention},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # If this is set, no need to specify isInfiniteRetention as false.
    ${SecondExtendedRetentionRuleRetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${SecondExtendedRetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of snap recovery points for snap copy for retention.
    # Can be specified instead of retention period in Days for snap copy.
    ${SnapRecoveryPoints},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SourceCopyId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SourceCopyName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If this is set as true, no need to specify retentionPeriodDays.
    ${ThirdExtendedRetentionRuleIsInfiniteRetention},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # If this is set, no need to specify isInfiniteRetention as false.
    ${ThirdExtendedRetentionRuleRetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${ThirdExtendedRetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Use extended retention rules.
    # Must specify if updating extended retention rules.
    ${UseExtendedRetentionRules},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyBackupDestinationWithoutPlanInfo_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyBackupDestinationWithoutPlanInfo_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyBackupDestinationWithoutPlanInfo_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyBackupDestinationWithoutPlanInfo_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify Backup Destination for a Plan
.Description
Modify Backup Destination for a Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdatePlanBackupDestination
.Outputs
Commvault.Powershell.Models.IPlanBackupDestinationResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdatePlanBackupDestination>: .
  [BackupStartTime <Int64?>]: Specify the Backup start time in seconds. The time is provided in unix time format.
  [BackupsToCopy <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [EnableDataAging <Boolean?>]: Tells if this copy has data aging enabled
  [FirstExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [FirstExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [FirstExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [Mappings <ISnapshotCopyMapping[]>]: 
    [SourceId <Int64?>]: 
    [SourceName <String>]: 
    [SourceVendorId <Int64?>]: 
    [SourceVendorName <String>]: 
    [TargetId <Int64?>]: 
    [TargetName <String>]: 
    [TargetVendorId <Int64?>]: 
    [TargetVendorName <String>]: 
    [Vendor <String>]: Snapshot vendors available for Snap Copy mappings
  [NewName <String>]: New name for backup destination
  [OverrideRetentionSettings <Boolean?>]: Tells if this copy should use storage pool retention period days or the retention defined for this copy. Set as true to use retention defined on this copy.
  [RetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention.
  [RetentionRuleType <String>]: Which type of retention rule should be used for the given backup destination
  [SecondExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [SecondExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [SecondExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [SnapRecoveryPoints <Int64?>]: Number of snap recovery points for snap copy for retention. Can be specified instead of retention period in Days for snap copy.
  [SourceCopyId <Int64?>]: 
  [SourceCopyName <String>]: 
  [ThirdExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [ThirdExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [ThirdExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [UseExtendedRetentionRules <Boolean?>]: Use extended retention rules. Must specify if updating extended retention rules.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

MAPPINGS <ISnapshotCopyMapping[]>: .
  [SourceId <Int64?>]: 
  [SourceName <String>]: 
  [SourceVendorId <Int64?>]: 
  [SourceVendorName <String>]: 
  [TargetId <Int64?>]: 
  [TargetName <String>]: 
  [TargetVendorId <Int64?>]: 
  [TargetVendorName <String>]: 
  [Vendor <String>]: Snapshot vendors available for Snap Copy mappings
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifybackupdestination
#>
function Invoke-CVModifyBackupDestination {
[OutputType([Commvault.Powershell.Models.IPlanBackupDestinationResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backupDestination to be modified
    ${BackupDestinationId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to modify
    ${PlanId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdatePlanBackupDestination]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify the Backup start time in seconds.
    # The time is provided in unix time format.
    ${BackupStartTime},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${BackupsToCopy},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Tells if this copy has data aging enabled
    ${EnableDataAging},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If this is set as true, no need to specify retentionPeriodDays.
    ${FirstExtendedRetentionRuleIsInfiniteRetention},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # If this is set, no need to specify isInfiniteRetention as false.
    ${FirstExtendedRetentionRuleRetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${FirstExtendedRetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapshotCopyMapping[]]
    # .
    # To construct, see NOTES section for MAPPINGS properties and create a hash table.
    ${Mappings},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # New name for backup destination
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Tells if this copy should use storage pool retention period days or the retention defined for this copy.
    # Set as true to use retention defined on this copy.
    ${OverrideRetentionSettings},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Retention period in days.
    # -1 can be specified for infinite retention.
    ${RetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Which type of retention rule should be used for the given backup destination
    ${RetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If this is set as true, no need to specify retentionPeriodDays.
    ${SecondExtendedRetentionRuleIsInfiniteRetention},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # If this is set, no need to specify isInfiniteRetention as false.
    ${SecondExtendedRetentionRuleRetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${SecondExtendedRetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of snap recovery points for snap copy for retention.
    # Can be specified instead of retention period in Days for snap copy.
    ${SnapRecoveryPoints},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SourceCopyId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SourceCopyName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If this is set as true, no need to specify retentionPeriodDays.
    ${ThirdExtendedRetentionRuleIsInfiniteRetention},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # If this is set, no need to specify isInfiniteRetention as false.
    ${ThirdExtendedRetentionRuleRetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${ThirdExtendedRetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Use extended retention rules.
    # Must specify if updating extended retention rules.
    ${UseExtendedRetentionRules},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyBackupDestination_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyBackupDestination_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyBackupDestination_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyBackupDestination_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify the properties of an existing mount path
.Description
Modify the properties of an existing mount path
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateBackupLocation
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateBackupLocation>: While adding network access path, please add credentials or saved credentials. If both are provided, credentials will be selected.
  [Access <String>]: The access type for the access path can be either read (writing to path not allowed) or read and write (writing to path allowed).
  [BackupLocation <String>]: Can be used to change the disk access path.
  [ConfigurationDisableBackupLocationforFutureBackups <Boolean?>]: Used to determine if backup location has to be disabled or enabled for future backups
  [ConfigurationEnableBackupLocation <Boolean?>]: Used to enable or disable backup location
  [ConfigurationPrepareForRetirement <Boolean?>]: Used to determine if the backup location has to be prepared for retirement
  [CredentialsName <String>]: username to access the network path
  [CredentialsPassword <String>]: password to access the network path
  [Enabled <Boolean?>]: 
  [MediaAgentId <Int64?>]: 
  [MediaAgentName <String>]: 
  [SavedCredentialsId <Int64?>]: 
  [SavedCredentialsName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifybackuplocation
#>
function Invoke-CVModifyBackupLocation {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backup location to update
    ${BackupLocationId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the disk storage to update
    ${StoragePoolId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateBackupLocation]
    # While adding network access path, please add credentials or saved credentials.
    # If both are provided, credentials will be selected.
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The access type for the access path can be either read (writing to path not allowed) or read and write (writing to path allowed).
    ${Access},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Can be used to change the disk access path.
    ${BackupLocation},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Used to determine if backup location has to be disabled or enabled for future backups
    ${ConfigurationDisableBackupLocationforFutureBackups},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Used to enable or disable backup location
    ${ConfigurationEnableBackupLocation},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Used to determine if the backup location has to be prepared for retirement
    ${ConfigurationPrepareForRetirement},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # username to access the network path
    ${CredentialsName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # password to access the network path
    ${CredentialsPassword},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${Enabled},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${MediaAgentId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${MediaAgentName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SavedCredentialsId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SavedCredentialsName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyBackupLocation_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyBackupLocation_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyBackupLocation_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyBackupLocation_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify the properties of an existing Blackout Window
.Description
Modify the properties of an existing Blackout Window
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateBlackoutWindow
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ALLDAYS <IDaysAndTimes[]>: Days of the week along with the time on which the black out window will be in effect.
  [Days <String[]>]: Days of the week when the blackout window will be in effect.
  [TimeEnd <Int64?>]: the blackout window is no longer in effect from this point on.
  [TimeStart <Int64?>]: the blackout window comes into effect at this point.

BODY <IUpdateBlackoutWindow>: company-refers to company to which the blackout window is associated.Dates have to be provided in unix time format.
  [AllDays <IDaysAndTimes[]>]: Days of the week along with the time on which the black out window will be in effect.
    [Days <String[]>]: Days of the week when the blackout window will be in effect.
    [TimeEnd <Int64?>]: the blackout window is no longer in effect from this point on.
    [TimeStart <Int64?>]: the blackout window comes into effect at this point.
  [BackupOperations <String[]>]: Refers to backup types to include in the blackout window
  [BetweenDateEnd <Int64?>]: the blackout window is no longer in effect from this point on.
  [BetweenDateStart <Int64?>]: the blackout window comes into effect at this point.
  [CompanyId <Int64?>]: 
  [CompanyName <String>]: 
  [DoNotSubmitJob <Boolean?>]: Allows or Denies submitting a job when the blackout window is in effect. If allowed, the job is submitted and resumed once the blackout window ends.
  [NewName <String>]: Refers to the newName given to the blackout Window.
  [Weeks <String[]>]: Refers to the weeks of the month that the blackout window will be in effect.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyblackoutwindow
#>
function Invoke-CVModifyBlackoutWindow {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Blackout Window to update
    ${BlackoutWindowId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateBlackoutWindow]
    # company-refers to company to which the blackout window is associated.Dates have to be provided in unix time format.
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDaysAndTimes[]]
    # Days of the week along with the time on which the black out window will be in effect.
    # To construct, see NOTES section for ALLDAYS properties and create a hash table.
    ${AllDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Refers to backup types to include in the blackout window
    ${BackupOperations},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # the blackout window is no longer in effect from this point on.
    ${BetweenDateEnd},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # the blackout window comes into effect at this point.
    ${BetweenDateStart},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${CompanyId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${CompanyName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Allows or Denies submitting a job when the blackout window is in effect.
    # If allowed, the job is submitted and resumed once the blackout window ends.
    ${DoNotSubmitJob},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Refers to the newName given to the blackout Window.
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Refers to the weeks of the month that the blackout window will be in effect.
    ${Weeks},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyBlackoutWindow_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyBlackoutWindow_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyBlackoutWindow_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyBlackoutWindow_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify details like credentials and path for metadata Cache of a cloud storage based on Id
.Description
Modify details like credentials and path for metadata Cache of a cloud storage based on Id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateMetadataCacheConfiguration
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateMetadataCacheConfiguration>: If updating to a network access path, Please add credentials or saved credentials. If both are provided, credentials will be taken into consideration.
  Path <String>: Metadata cache will be stored on this path
  [CredentialsName <String>]: username to access the network path
  [CredentialsPassword <String>]: password to access the network path
  [SavedCredentialsId <Int64?>]: 
  [SavedCredentialsName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifycloudstoragemetadatacache
#>
function Invoke-CVModifyCloudStorageMetaDataCache {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of cloud Storage
    ${CloudStorageId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of metadata cache
    ${MetadataCacheId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateMetadataCacheConfiguration]
    # If updating to a network access path, Please add credentials or saved credentials.
    # If both are provided, credentials will be taken into consideration.
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Metadata cache will be stored on this path
    ${Path},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # username to access the network path
    ${CredentialsName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # password to access the network path
    ${CredentialsPassword},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SavedCredentialsId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SavedCredentialsName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyCloudStorageMetaDataCache_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyCloudStorageMetaDataCache_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyCloudStorageMetaDataCache_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyCloudStorageMetaDataCache_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify details like name, encryption, security of a specific cloud storage
.Description
Modify details like name, encryption, security of a specific cloud storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateCloudStorage
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateCloudStorage>: .
  [EncryptionCipher <String>]: The different types of encryption keys that can be used for encrypting the data. The values are case sensitive
  [EncryptionEncrypt <Boolean?>]: 
  [EncryptionKeyLength <Int64?>]: Different keylengths are present for different kinds of ciphers. Blowfish,Twofish,AES and Serpent all accept both 128 and 256. DES3 accepts only 192. GOST accepts only 256. 
  [KeyProviderId <Int64?>]: 
  [KeyProviderName <String>]: 
  [NewName <String>]: change the name of the cloud storage
  [Security <IUpdateSecurityAssoc[]>]: 
    [RoleId <Int64?>]: 
    [RoleName <String>]: 
    [UserGroupId <Int64?>]: 
    [UserGroupName <String>]: 
    [UserId <Int64?>]: 
    [UserName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

SECURITY <IUpdateSecurityAssoc[]>: .
  [RoleId <Int64?>]: 
  [RoleName <String>]: 
  [UserGroupId <Int64?>]: 
  [UserGroupName <String>]: 
  [UserId <Int64?>]: 
  [UserName <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifycloudstorage
#>
function Invoke-CVModifyCloudStorage {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of cloud Storage
    ${CloudStorageId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateCloudStorage]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The different types of encryption keys that can be used for encrypting the data.
    # The values are case sensitive
    ${EncryptionCipher},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${EncryptionEncrypt},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Different keylengths are present for different kinds of ciphers.
    # Blowfish,Twofish,AES and Serpent all accept both 128 and 256.
    # DES3 accepts only 192.
    # GOST accepts only 256.
    ${EncryptionKeyLength},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${KeyProviderId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${KeyProviderName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # change the name of the cloud storage
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateSecurityAssoc[]]
    # .
    # To construct, see NOTES section for SECURITY properties and create a hash table.
    ${Security},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyCloudStorage_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyCloudStorage_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyCloudStorage_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyCloudStorage_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify the properties of an existing company
.Description
Modify the properties of an existing company
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateCompany
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateCompany>: Used to update the properties of an existing company
  [DefaultPlans <IDefaultPlan[]>]: Refers to default data protection plans to use for the company.
    [Id <Int64?>]: Id of the default plan. Either id or name can be provided. If both id and name are provided, id is given first preference.
    [Name <String>]: Name of the default plan. Either id or name can be provided. If both id and name are provided, id is given first preference.
    [Subtype <String>]: 
  [EmailSettingSenderEmail <String>]: Email id of the sender
  [EmailSettingSenderName <String>]: Name of the sender sending the email
  [FileExceptionUnix <String>]: Unix file paths to be excluded.Comma separated string.
  [FileExceptionUseCompanyGlobalFilter <Boolean?>]: Enable or disable the use of the file path filters on all subclients. By default, it is enabled when filters are added for either Windows or Unix or both.
  [FileExceptionWindows <String>]: Window file paths to be excluded.Comma separated string.
  [GeneralAssignLaptopOwners <String>]: Used to assign owners to laptops automatically after installation. The owners can be all the logged in active directory users, the first user to login into the laptop after installation or the users belonging to the laptop's local user group list. The option to assign automatically can also be disabled.
  [GeneralAuthcodeForInstallation <Boolean?>]: Enable or disable authcode for installation.
  [GeneralAutoDiscoverApp <Boolean?>]: Enable or Disable Auto Discover Applications.When Auto discover applications is enabled, each member server of this company is searched once every 24 hours to discover any applications that need to be backed up. For any newly-discovered and unprotected applications, the agent software is automatically installed on the server.
  [GeneralEmailSuffix <String>]: Supported domains for the company
  [GeneralEnableDataEncryption <Boolean?>]: Enable or disable data encryption
  [GeneralInfrastructureType <String>]: These are different types of infrastructure provided for storage in companies. It can be rented from the provider, owned or can be a hybrid. Cannot move back to rented storage from owned storage and cannot move back to rented storage/owned storage from rented and owned storage.
  [GeneralNewAlias <String>]: The company domain or NetBIOS name
  [GeneralResellerMode <Boolean?>]: Enable reseller mode. A reseller is a user or user groups who can operate multiple tenant environments. The service provider can assign one or more resellers as the tenant operator for a company. The reseller can switch to any of their assigned tenant environment and operate on the company as a tenant user. Once enabled, the reseller mode cannot be disabled.
  [GeneralServiceCommcells <IIdName[]>]: Service commcells associated with the master commcell.
    [Id <Int64?>]: 
    [Name <String>]: 
  [GeneralSupportedSolutions <String[]>]: 
  [GeneralUpnInsteadOfEmail <Boolean?>]: Enable or disable the use of User Pricipal Name in place of an email address.
  [NewName <String>]: Used to change the name of a company
  [OptionDisableBackup <Boolean?>]: Enable or disable backup. This option can only be set or unset for a deactivated company.
  [OptionDisableLogin <Boolean?>]: Enable or disable login. This option can only be set or unset for a deactivated company.
  [OptionDisableRestore <Boolean?>]: Enable or disable restore. This option can only be set or unset for a deactivated company.
  [Plans <IIdName[]>]: Provide a list of data protection plans to use for the company. The plans that are provided are the plans that the tenant administrator can choose from.
  [Security <IUpdateSecurityAssoc[]>]: 
    [RoleId <Int64?>]: 
    [RoleName <String>]: 
    [UserGroupId <Int64?>]: 
    [UserGroupName <String>]: 
    [UserId <Int64?>]: 
    [UserName <String>]: 
  [SitePrimarySiteName <String>]: Primary site name
  [SiteSecondarySiteNames <String[]>]: Secondary site names
  [StatusDeactivate <Boolean?>]: Used to activate or deactivate the company.
  [TenantOperators <ITenantOperator[]>]: 
    [RoleId <Int64?>]: 
    [RoleName <String>]: 
    [UserGroupId <Int64?>]: 
    [UserGroupName <String>]: 
    [UserId <Int64?>]: 
    [UserName <String>]: 
  [TwoFactorAuthAll <Boolean?>]: enable two factor authentication for every entity. if set to false when Two factor authentication is enabled, provide userGroupId or userGroupName. If both are provided, userGroupId is taken
  [TwoFactorAuthEnable <Boolean?>]: enable or disable two factor authentication. if enabled, all or userGroups value should be provided.
  [TwoFactorAuthUserGroups <IIdName[]>]: 

DEFAULTPLANS <IDefaultPlan[]>: Refers to default data protection plans to use for the company.
  [Id <Int64?>]: Id of the default plan. Either id or name can be provided. If both id and name are provided, id is given first preference.
  [Name <String>]: Name of the default plan. Either id or name can be provided. If both id and name are provided, id is given first preference.
  [Subtype <String>]: 

GENERALSERVICECOMMCELLS <IIdName[]>: Service commcells associated with the master commcell.
  [Id <Int64?>]: 
  [Name <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

PLANS <IIdName[]>: Provide a list of data protection plans to use for the company. The plans that are provided are the plans that the tenant administrator can choose from.
  [Id <Int64?>]: 
  [Name <String>]: 

SECURITY <IUpdateSecurityAssoc[]>: .
  [RoleId <Int64?>]: 
  [RoleName <String>]: 
  [UserGroupId <Int64?>]: 
  [UserGroupName <String>]: 
  [UserId <Int64?>]: 
  [UserName <String>]: 

TENANTOPERATORS <ITenantOperator[]>: .
  [RoleId <Int64?>]: 
  [RoleName <String>]: 
  [UserGroupId <Int64?>]: 
  [UserGroupName <String>]: 
  [UserId <Int64?>]: 
  [UserName <String>]: 

TWOFACTORAUTHUSERGROUPS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifycompany
#>
function Invoke-CVModifyCompany {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the company to update
    ${CompanyId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateCompany]
    # Used to update the properties of an existing company
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDefaultPlan[]]
    # Refers to default data protection plans to use for the company.
    # To construct, see NOTES section for DEFAULTPLANS properties and create a hash table.
    ${DefaultPlans},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Email id of the sender
    ${EmailSettingSenderEmail},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the sender sending the email
    ${EmailSettingSenderName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Unix file paths to be excluded.Comma separated string.
    ${FileExceptionUnix},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable or disable the use of the file path filters on all subclients.
    # By default, it is enabled when filters are added for either Windows or Unix or both.
    ${FileExceptionUseCompanyGlobalFilter},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Window file paths to be excluded.Comma separated string.
    ${FileExceptionWindows},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Used to assign owners to laptops automatically after installation.
    # The owners can be all the logged in active directory users, the first user to login into the laptop after installation or the users belonging to the laptop's local user group list.
    # The option to assign automatically can also be disabled.
    ${GeneralAssignLaptopOwners},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable or disable authcode for installation.
    ${GeneralAuthcodeForInstallation},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable or Disable Auto Discover Applications.When Auto discover applications is enabled, each member server of this company is searched once every 24 hours to discover any applications that need to be backed up.
    # For any newly-discovered and unprotected applications, the agent software is automatically installed on the server.
    ${GeneralAutoDiscoverApp},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Supported domains for the company
    ${GeneralEmailSuffix},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable or disable data encryption
    ${GeneralEnableDataEncryption},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # These are different types of infrastructure provided for storage in companies.
    # It can be rented from the provider, owned or can be a hybrid.
    # Cannot move back to rented storage from owned storage and cannot move back to rented storage/owned storage from rented and owned storage.
    ${GeneralInfrastructureType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The company domain or NetBIOS name
    ${GeneralNewAlias},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable reseller mode.
    # A reseller is a user or user groups who can operate multiple tenant environments.
    # The service provider can assign one or more resellers as the tenant operator for a company.
    # The reseller can switch to any of their assigned tenant environment and operate on the company as a tenant user.
    # Once enabled, the reseller mode cannot be disabled.
    ${GeneralResellerMode},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Service commcells associated with the master commcell.
    # To construct, see NOTES section for GENERALSERVICECOMMCELLS properties and create a hash table.
    ${GeneralServiceCommcells},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # .
    ${GeneralSupportedSolutions},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable or disable the use of User Pricipal Name in place of an email address.
    ${GeneralUpnInsteadOfEmail},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Used to change the name of a company
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable or disable backup.
    # This option can only be set or unset for a deactivated company.
    ${OptionDisableBackup},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable or disable login.
    # This option can only be set or unset for a deactivated company.
    ${OptionDisableLogin},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable or disable restore.
    # This option can only be set or unset for a deactivated company.
    ${OptionDisableRestore},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Provide a list of data protection plans to use for the company.
    # The plans that are provided are the plans that the tenant administrator can choose from.
    # To construct, see NOTES section for PLANS properties and create a hash table.
    ${Plans},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateSecurityAssoc[]]
    # .
    # To construct, see NOTES section for SECURITY properties and create a hash table.
    ${Security},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Primary site name
    ${SitePrimarySiteName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Secondary site names
    ${SiteSecondarySiteNames},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Used to activate or deactivate the company.
    ${StatusDeactivate},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ITenantOperator[]]
    # .
    # To construct, see NOTES section for TENANTOPERATORS properties and create a hash table.
    ${TenantOperators},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # enable two factor authentication for every entity.
    # if set to false when Two factor authentication is enabled, provide userGroupId or userGroupName.
    # If both are provided, userGroupId is taken
    ${TwoFactorAuthAll},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # enable or disable two factor authentication.
    # if enabled, all or userGroups value should be provided.
    ${TwoFactorAuthEnable},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for TWOFACTORAUTHUSERGROUPS properties and create a hash table.
    ${TwoFactorAuthUserGroups},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyCompany_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyCompany_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyCompany_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyCompany_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to modify an existing data classification plan
.Description
Used to modify an existing data classification plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateDcPlan
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateDcPlan>: Describes Input to Update Data Classification Plan
  [ContentAnalyzer <IIdName[]>]: 
    [Id <Int64?>]: 
    [Name <String>]: 
  [ContentIndexingBackupCopy <IDcBackupCopy[]>]: 
    [CopyId <Int64?>]: 
    [StoragePoolId <Int64?>]: 
  [ContentIndexingContentLanguage <String>]: OCR Languages Supported By DC Plan
  [ContentIndexingDomainName <String>]: Associated Domain of user having access to preview path
  [ContentIndexingExactSearch <Boolean?>]: Whether Exact Search is enabled or disabled
  [ContentIndexingExtractTextFromImage <Boolean?>]: Whether Image Extraction is Enabled
  [ContentIndexingPreviewPath <String>]: Describes the Preview path for Content Indexed Data when search type is METADATA_CONTENT_PREVIEW
  [ContentIndexingSearchType <String>]: Describes the Content Indexing Operation Type for Data Classification Plan
  [ContentIndexingUserName <String>]: Associated user name of user having access to preview path
  [EntityDetectionClassifiers <IIdName[]>]: Classifier TagId For Extraction
  [EntityDetectionCopyPrecendence <Int64?>]: 
  [EntityDetectionEntities <IIdName[]>]: Entity TagId for Extraction
  [FileFilterExcludePaths <String[]>]: 
  [FileFilterIncludeDocTypes <String>]: 
  [FileFilterMaxDocSize <Int64?>]: 
  [FileFilterMinDocSize <Int64?>]: 
  [Name <String>]: Name of the Data Classification plan
  [PatternDayOfMonth <Int64?>]: Day on which to run the schedule, applicable for monthly, yearly
  [PatternDayOfWeek <String>]: 
  [PatternExceptions <IScheduleRunException[]>]: Exceptions to when a schedule should not run, either in dates or week of month and day
    [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
    [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
    [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
  [PatternFrequency <Int64?>]: Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
  [PatternMonthOfYear <String>]: 
  [PatternScheduleFrequencyType <String>]: schedule frequency type
  [PatternStartDate <Int64?>]: start date of schedule in epoch format
  [PatternStartTime <Int64?>]: start time of schedule in seconds for daily, weekly, monthly, yearly frequency
  [PatternWeekOfMonth <String>]: Specific week of a month
  [PatternWeeklyDays <String[]>]: Days of the week for weekly frequency
  [ScheduleName <String>]: 
  [ThreatAnalysis <Int64?>]: Enables\Disables Threat Analysis support for DC Plan

CONTENTANALYZER <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 

CONTENTINDEXINGBACKUPCOPY <IDcBackupCopy[]>: .
  [CopyId <Int64?>]: 
  [StoragePoolId <Int64?>]: 

ENTITYDETECTIONCLASSIFIERS <IIdName[]>: Classifier TagId For Extraction
  [Id <Int64?>]: 
  [Name <String>]: 

ENTITYDETECTIONENTITIES <IIdName[]>: Entity TagId for Extraction
  [Id <Int64?>]: 
  [Name <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

PATTERNEXCEPTIONS <IScheduleRunException[]>: Exceptions to when a schedule should not run, either in dates or week of month and day
  [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
  [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
  [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifydcplan
#>
function Invoke-CVModifyDcPlan {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateDcPlan]
    # Describes Input to Update Data Classification Plan
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for CONTENTANALYZER properties and create a hash table.
    ${ContentAnalyzer},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDcBackupCopy[]]
    # .
    # To construct, see NOTES section for CONTENTINDEXINGBACKUPCOPY properties and create a hash table.
    ${ContentIndexingBackupCopy},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # OCR Languages Supported By DC Plan
    ${ContentIndexingContentLanguage},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Associated Domain of user having access to preview path
    ${ContentIndexingDomainName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Whether Exact Search is enabled or disabled
    ${ContentIndexingExactSearch},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Whether Image Extraction is Enabled
    ${ContentIndexingExtractTextFromImage},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Describes the Preview path for Content Indexed Data when search type is METADATA_CONTENT_PREVIEW
    ${ContentIndexingPreviewPath},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Describes the Content Indexing Operation Type for Data Classification Plan
    ${ContentIndexingSearchType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Associated user name of user having access to preview path
    ${ContentIndexingUserName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Classifier TagId For Extraction
    # To construct, see NOTES section for ENTITYDETECTIONCLASSIFIERS properties and create a hash table.
    ${EntityDetectionClassifiers},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${EntityDetectionCopyPrecendence},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Entity TagId for Extraction
    # To construct, see NOTES section for ENTITYDETECTIONENTITIES properties and create a hash table.
    ${EntityDetectionEntities},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # .
    ${FileFilterExcludePaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${FileFilterIncludeDocTypes},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${FileFilterMaxDocSize},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${FileFilterMinDocSize},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the Data Classification plan
    ${Name},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Day on which to run the schedule, applicable for monthly, yearly
    ${PatternDayOfMonth},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PatternDayOfWeek},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IScheduleRunException[]]
    # Exceptions to when a schedule should not run, either in dates or week of month and day
    # To construct, see NOTES section for PATTERNEXCEPTIONS properties and create a hash table.
    ${PatternExceptions},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Frequency of the schedule based on schedule frequency type eg.
    # for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days.
    # for Monthly 2 is it repeats every 2 months
    ${PatternFrequency},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PatternMonthOfYear},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # schedule frequency type
    ${PatternScheduleFrequencyType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # start date of schedule in epoch format
    ${PatternStartDate},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # start time of schedule in seconds for daily, weekly, monthly, yearly frequency
    ${PatternStartTime},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specific week of a month
    ${PatternWeekOfMonth},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Days of the week for weekly frequency
    ${PatternWeeklyDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ScheduleName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Enables\Disables Threat Analysis support for DC Plan
    ${ThreatAnalysis},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyDcPlan_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyDcPlan_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyDcPlan_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyDcPlan_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to modify a disk access path
.Description
Used to modify a disk access path
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateDiskAccessPath
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateDiskAccessPath>: While adding network access path, please add credentials or saved credentials. If both are provided, credentials will be selected.
  [Access <String>]: The access type for the access path can be either read (writing to path not allowed) or read and write (writing to path allowed).
  [Enabled <Boolean?>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifydiskaccesspath
#>
function Invoke-CVModifyDiskAccessPath {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the mount path whose access path has to be modified
    ${AccessPathId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the mount path whose access path has to be modified
    ${BackupLocationId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the disk storage pool whose access path has to be modified
    ${StoragePoolId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateDiskAccessPath]
    # While adding network access path, please add credentials or saved credentials.
    # If both are provided, credentials will be selected.
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The access type for the access path can be either read (writing to path not allowed) or read and write (writing to path allowed).
    ${Access},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${Enabled},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyDiskAccessPath_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyDiskAccessPath_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyDiskAccessPath_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyDiskAccessPath_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify the properties of an existing disk storage pool
.Description
Modify the properties of an existing disk storage pool
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateDiskStorage
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateDiskStorage>: .
  [DataEncryptionCipher <String>]: The different types of encryption keys that can be used for encrypting the data. The values are case sensitive
  [DataEncryptionEncrypt <Boolean?>]: 
  [DataEncryptionKeyLength <Int64?>]: Different keylengths are present for different kinds of ciphers. Blowfish,Twofish,AES and Serpent all accept both 128 and 256. DES3 accepts only 192. GOST accepts only 256. 
  [KeyProviderId <Int64?>]: 
  [KeyProviderName <String>]: 
  [NewName <String>]: change the name of the storage pool
  [Security <IUpdateSecurityAssoc[]>]: 
    [RoleId <Int64?>]: 
    [RoleName <String>]: 
    [UserGroupId <Int64?>]: 
    [UserGroupName <String>]: 
    [UserId <Int64?>]: 
    [UserName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

SECURITY <IUpdateSecurityAssoc[]>: .
  [RoleId <Int64?>]: 
  [RoleName <String>]: 
  [UserGroupId <Int64?>]: 
  [UserGroupName <String>]: 
  [UserId <Int64?>]: 
  [UserName <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifydiskstorage
#>
function Invoke-CVModifyDiskStorage {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the disk storage to update
    ${StoragePoolId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateDiskStorage]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The different types of encryption keys that can be used for encrypting the data.
    # The values are case sensitive
    ${DataEncryptionCipher},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${DataEncryptionEncrypt},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Different keylengths are present for different kinds of ciphers.
    # Blowfish,Twofish,AES and Serpent all accept both 128 and 256.
    # DES3 accepts only 192.
    # GOST accepts only 256.
    ${DataEncryptionKeyLength},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${KeyProviderId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${KeyProviderName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # change the name of the storage pool
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateSecurityAssoc[]]
    # .
    # To construct, see NOTES section for SECURITY properties and create a hash table.
    ${Security},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyDiskStorage_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyDiskStorage_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyDiskStorage_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyDiskStorage_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify entity settings used to change default behaviour for linked entity like servers or server groups
.Description
Modify entity settings used to change default behaviour for linked entity like servers or server groups
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IModifyEntitySettings
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IModifyEntitySettings>: ModifyEntitySettings
  [EntitySettings <IModifyEntitySettingsItem[]>]: 
    Category <String>: Category of the setting to be modified. This cannot be modified but is required to identify the setting for which the new value is to be set.
    Name <String>: Name of the setting to be modified. This cannot be modified but is required to identify the setting for which the new value is to be set.
    Type <String>: Type of the setting to be modified. This cannot be modified but is required to identify the setting for which the new value is to be set.
    [Comment <String>]: Comment to specify why this value was set for the specified setting
    [NewValue <String>]: New value which will be set for the specified setting, there can be fixed acceptables values for some settings. To get more details about what are acceptable value for a setting, use GET GlobalSettings or GET EntitySettings.
    [Reset <Boolean?>]: To reset the value of any already modified setting, set this to true to reset the value and regain default behaviour
    [EntityId <Int64?>]: 
    [EntityType <String>]: 

ENTITYSETTINGS <IModifyEntitySettingsItem[]>: .
  Category <String>: Category of the setting to be modified. This cannot be modified but is required to identify the setting for which the new value is to be set.
  Name <String>: Name of the setting to be modified. This cannot be modified but is required to identify the setting for which the new value is to be set.
  Type <String>: Type of the setting to be modified. This cannot be modified but is required to identify the setting for which the new value is to be set.
  [Comment <String>]: Comment to specify why this value was set for the specified setting
  [NewValue <String>]: New value which will be set for the specified setting, there can be fixed acceptables values for some settings. To get more details about what are acceptable value for a setting, use GET GlobalSettings or GET EntitySettings.
  [Reset <Boolean?>]: To reset the value of any already modified setting, set this to true to reset the value and regain default behaviour
  [EntityId <Int64?>]: 
  [EntityType <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyentitysetting
#>
function Invoke-CVModifyEntitySetting {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IModifyEntitySettings]
    # ModifyEntitySettings
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IModifyEntitySettingsItem[]]
    # .
    # To construct, see NOTES section for ENTITYSETTINGS properties and create a hash table.
    ${EntitySettings},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyEntitySetting_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyEntitySetting_ModifyExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to create failover group DR operation schedule
.Description
API to create failover group DR operation schedule
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IPlanSchedule
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IPlanSchedule>: Used to describe single plan schedule information
  BackupType <String>: Schedule Backup level
  SchedulePatternScheduleFrequencyType <String>: schedule frequency type
  [ForDatabasesOnly <Boolean?>]: Boolean to indicate if schedule is for database agents
  [IsRetentionBasedSyntheticFull <Boolean?>]: Boolean to indicate if synthetic full schedule is based on retention rules
  [PolicyId <Int64?>]: Schedule policy Id to which the schedule belongs
  [ScheduleId <Int64?>]: Id of the schedule if available, required for modifying, deleting schedule
  [ScheduleName <String>]: Name of the schedule, for modify
  [ScheduleOperation <String>]: Operation being performed on schedule
  [ScheduleOptionCommitFrequencyInHours <Int64?>]: Commit frequency in hours for disk cache backups from automatic schedules
  [ScheduleOptionDaysBetweenAutoConvert <Int64?>]: Number of days between auto conversion of backup level applicable for databases on incremental and differential schedules of server plan
  [ScheduleOptionJobRunningTimeInMins <Int64?>]: total job running time in minutes
  [ScheduleOptionLogFilesThreshold <Int64?>]: The min number of archived log files before a backup job should start
  [ScheduleOptionLogsDiskUtilizationPercent <Int64?>]: The min log destination disk threshold percentage
  [ScheduleOptionMinBackupIntervalInMins <Int64?>]: The min number of mins to check for file activity on automatic schedule.
  [ScheduleOptionO365ItemSelectionOption <String>]: item backup option for O365 V2 backup jobs
  [ScheduleOptionUseDiskCacheForLogBackups <Boolean?>]: Used to enable disk caching feature on databases for automatic schedules on server plan
  [SchedulePatternDayOfMonth <Int64?>]: Day on which to run the schedule, applicable for monthly, yearly
  [SchedulePatternDayOfWeek <String>]: 
  [SchedulePatternDaysBetweenSyntheticFulls <Int64?>]: No of days between two synthetic full jobs
  [SchedulePatternEndDate <Int64?>]: Schedule end date in epoch format
  [SchedulePatternExceptions <IScheduleRunException[]>]: Exceptions to when a schedule should not run, either in dates or week of month and days
    [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
    [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
    [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
  [SchedulePatternFrequency <Int64?>]: Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
  [SchedulePatternMaxBackupIntervalInMins <Int64?>]: The number of mins to force a backup on automatic schedule.
  [SchedulePatternMonthOfYear <String>]: 
  [SchedulePatternNoOfTimes <Int64?>]: The number of times you want the schedule to run.
  [SchedulePatternRepeatIntervalInMinutes <Int64?>]: How often in minutes in a day the schedule runs, applicable for daily, weekly, monthly and yearly frequency types.
  [SchedulePatternRepeatUntilTime <Int64?>]: Until what time to repeat the schedule in a day, requires repeatIntervalInMinutes
  [SchedulePatternStartDate <Int64?>]: start date of schedule in epoch format
  [SchedulePatternStartTime <Int64?>]: start time of schedule in seconds
  [SchedulePatternWeekOfMonth <String>]: Specific week of a month
  [SchedulePatternWeeklyDays <String[]>]: Days of the week for weekly frequency
  [TimezoneId <Int64?>]: 
  [TimezoneName <String>]: 
  [VMOperationType <String>]: Type of DR operation (only applicable for Failover groups)

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

SCHEDULEPATTERNEXCEPTIONS <IScheduleRunException[]>: Exceptions to when a schedule should not run, either in dates or week of month and days
  [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
  [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
  [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyfailovergroupschedule
#>
function Invoke-CVModifyFailoverGroupSchedule {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the failover group
    ${FailoverGroupId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the DR operation schedule
    ${ScheduleId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanSchedule]
    # Used to describe single plan schedule information
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Schedule Backup level
    ${BackupType},

    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # schedule frequency type
    ${SchedulePatternScheduleFrequencyType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean to indicate if schedule is for database agents
    ${ForDatabasesOnly},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean to indicate if synthetic full schedule is based on retention rules
    ${IsRetentionBasedSyntheticFull},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Schedule policy Id to which the schedule belongs
    ${PolicyId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Id of the schedule if available, required for modifying, deleting schedule
    ${ScheduleId1},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the schedule, for modify
    ${ScheduleName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Operation being performed on schedule
    ${ScheduleOperation},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Commit frequency in hours for disk cache backups from automatic schedules
    ${ScheduleOptionCommitFrequencyInHours},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of days between auto conversion of backup level applicable for databases on incremental and differential schedules of server plan
    ${ScheduleOptionDaysBetweenAutoConvert},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # total job running time in minutes
    ${ScheduleOptionJobRunningTimeInMins},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The min number of archived log files before a backup job should start
    ${ScheduleOptionLogFilesThreshold},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The min log destination disk threshold percentage
    ${ScheduleOptionLogsDiskUtilizationPercent},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The min number of mins to check for file activity on automatic schedule.
    ${ScheduleOptionMinBackupIntervalInMins},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # item backup option for O365 V2 backup jobs
    ${ScheduleOptionO365ItemSelectionOption},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Used to enable disk caching feature on databases for automatic schedules on server plan
    ${ScheduleOptionUseDiskCacheForLogBackups},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Day on which to run the schedule, applicable for monthly, yearly
    ${SchedulePatternDayOfMonth},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SchedulePatternDayOfWeek},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # No of days between two synthetic full jobs
    ${SchedulePatternDaysBetweenSyntheticFulls},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Schedule end date in epoch format
    ${SchedulePatternEndDate},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IScheduleRunException[]]
    # Exceptions to when a schedule should not run, either in dates or week of month and days
    # To construct, see NOTES section for SCHEDULEPATTERNEXCEPTIONS properties and create a hash table.
    ${SchedulePatternExceptions},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Frequency of the schedule based on schedule frequency type eg.
    # for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days.
    # for Monthly 2 is it repeats every 2 months
    ${SchedulePatternFrequency},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The number of mins to force a backup on automatic schedule.
    ${SchedulePatternMaxBackupIntervalInMins},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SchedulePatternMonthOfYear},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The number of times you want the schedule to run.
    ${SchedulePatternNoOfTimes},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # How often in minutes in a day the schedule runs, applicable for daily, weekly, monthly and yearly frequency types.
    ${SchedulePatternRepeatIntervalInMinutes},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Until what time to repeat the schedule in a day, requires repeatIntervalInMinutes
    ${SchedulePatternRepeatUntilTime},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # start date of schedule in epoch format
    ${SchedulePatternStartDate},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # start time of schedule in seconds
    ${SchedulePatternStartTime},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specific week of a month
    ${SchedulePatternWeekOfMonth},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Days of the week for weekly frequency
    ${SchedulePatternWeeklyDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${TimezoneId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${TimezoneName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Type of DR operation (only applicable for Failover groups)
    ${VMOperationType},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyFailoverGroupSchedule_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyFailoverGroupSchedule_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyFailoverGroupSchedule_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyFailoverGroupSchedule_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to modify failover group
.Description
API to modify failover group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IModifyFailoverGroupRequest
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ARRAYREPLICATIONPAIRS <IFailoverGroupArrayReplicationPair[]>: List of all array replication pairs for failover group
  [DestinationId <Int64?>]: The id of the destination machine
  [DestinationName <String>]: The name of the destination machine
  [Guid <String>]: The GUID of the source of array replication pair
  [Hostname <String>]: The hostname specified for the destination machine
  [IPSettings <IIPAddressSettingVmwareCreate[]>]: The settings for IP address mapping
    [DestinationAlternateDns <String>]: The alternate DNS server for the destination VM.  Provide only if DHCP is not enabled
    [DestinationAlternateWins <String>]: The alternate WINS server for the destination VM.  Provide only if DHCP is not enabled
    [DestinationDefaultGateway <String>]: The default gateway for the destination VM.  Provide only if DHCP is not enabled.
    [DestinationIP <String>]: The full IP address or an IP address pattern for the destination VM. Provide only if DHCP is not enabled.
    [DestinationPreferredDns <String>]: The preferred DNS server for the destination VM.  Provide only if DHCP is not enabled
    [DestinationPreferredWins <String>]: The preferred WINS server for the destination VM.  Provide only if DHCP is not enabled
    [DestinationSubnetMask <String>]: The subnet mask for the destination VM.  Provide only if DHCP is not enabled.
    [SourceDefaultGateway <String>]: The default gateway of the source VM.
    [SourceIP <String>]: The full IP address or an IP address pattern of the source VM.
    [SourceSubnetMask <String>]: The subnet mask of the source VM.
    [UseDhcp <Boolean?>]: Automatically assigns available IP addresses to be used with the specified destination network.
  [Id <Int64?>]: The ID of the array replication pair
  [Priority <Int64?>]: The priority of the array replication pair for DR operation in failover group. The lower values signify higher priority
  [SourceId <Int64?>]: The id of the source machine
  [SourceName <String>]: The name of the source machine

BODY <IModifyFailoverGroupRequest>: Modify failover group request
  [ArrayReplicationPairs <IFailoverGroupArrayReplicationPair[]>]: List of all array replication pairs for failover group
    [DestinationId <Int64?>]: The id of the destination machine
    [DestinationName <String>]: The name of the destination machine
    [Guid <String>]: The GUID of the source of array replication pair
    [Hostname <String>]: The hostname specified for the destination machine
    [IPSettings <IIPAddressSettingVmwareCreate[]>]: The settings for IP address mapping
      [DestinationAlternateDns <String>]: The alternate DNS server for the destination VM.  Provide only if DHCP is not enabled
      [DestinationAlternateWins <String>]: The alternate WINS server for the destination VM.  Provide only if DHCP is not enabled
      [DestinationDefaultGateway <String>]: The default gateway for the destination VM.  Provide only if DHCP is not enabled.
      [DestinationIP <String>]: The full IP address or an IP address pattern for the destination VM. Provide only if DHCP is not enabled.
      [DestinationPreferredDns <String>]: The preferred DNS server for the destination VM.  Provide only if DHCP is not enabled
      [DestinationPreferredWins <String>]: The preferred WINS server for the destination VM.  Provide only if DHCP is not enabled
      [DestinationSubnetMask <String>]: The subnet mask for the destination VM.  Provide only if DHCP is not enabled.
      [SourceDefaultGateway <String>]: The default gateway of the source VM.
      [SourceIP <String>]: The full IP address or an IP address pattern of the source VM.
      [SourceSubnetMask <String>]: The subnet mask of the source VM.
      [UseDhcp <Boolean?>]: Automatically assigns available IP addresses to be used with the specified destination network.
    [Id <Int64?>]: The ID of the array replication pair
    [Priority <Int64?>]: The priority of the array replication pair for DR operation in failover group. The lower values signify higher priority
    [SourceId <Int64?>]: The id of the source machine
    [SourceName <String>]: The name of the source machine
  [ContinueDrOnFailure <Boolean?>]: Whether to continue to next priority on DR job failure
  [EsxServerMappings <IEsxServerMapping[]>]: The list of all ESX server mappings
    [DestinationServer <String>]: The name of destination ESX server
    [NetworkSettings <INetworkSetting[]>]: The list of all source network interface to destination network interface mapping
      [Destination <String>]: Destination network name
      [Source <String>]: Source network name
      [SourceId <String>]: Source network ID
    [SourceServer <String>]: The name of source ESX server
  [IsApprovalRequired <Boolean?>]: Whether a user approval is required for DR operations
  [Name <String>]: Failover Group name
  [PriorityIntervalInMinutes <Int64?>]: The interval between DR operations of different priorities
  [RecoveryTargetId <Int64?>]: 
  [RecoveryTargetName <String>]: 
  [ReplicationPairs <IFailoverGroupReplicationPair[]>]: List of all replication pairs that are part of the failover group
    [CopyPrecedence <Int64?>]: The copy precedence of replication pair
    [DestinationId <Int64?>]: The id of the destination machine
    [DestinationName <String>]: The name of the destination machine
    [Guid <String>]: The GUID of the source of replication pair
    [Id <Int64?>]: The ID of the replication pair
    [PostFailbackScriptGuestCredentialsCredentialsName <String>]: username to access the network path
    [PostFailbackScriptGuestCredentialsCredentialsPassword <String>]: password to access the network path
    [PostFailbackScriptGuestCredentialsSavedCredentialsId <Int64?>]: 
    [PostFailbackScriptGuestCredentialsSavedCredentialsName <String>]: 
    [PostFailbackScriptGuid <String>]: Unique script identifier string
    [PostFailbackScriptOSType <String>]: OS types
    [PostFailbackScriptPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [PostFailbackScriptReset <Boolean?>]: On set to true, resets the script to empty
    [PostFailbackScriptScriptCredentialsCredentialsName <String>]: username to access the network path
    [PostFailbackScriptScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [PostFailbackScriptScriptCredentialsSavedCredentialsId <Int64?>]: 
    [PostFailbackScriptScriptCredentialsSavedCredentialsName <String>]: 
    [PostFailbackScriptType <String>]: The type of path being used for DR operation script
    [PostFailoverScriptGuestCredentialsCredentialsName <String>]: username to access the network path
    [PostFailoverScriptGuestCredentialsCredentialsPassword <String>]: password to access the network path
    [PostFailoverScriptGuestCredentialsSavedCredentialsId <Int64?>]: 
    [PostFailoverScriptGuestCredentialsSavedCredentialsName <String>]: 
    [PostFailoverScriptGuid <String>]: Unique script identifier string
    [PostFailoverScriptOSType <String>]: OS types
    [PostFailoverScriptPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [PostFailoverScriptReset <Boolean?>]: On set to true, resets the script to empty
    [PostFailoverScriptScriptCredentialsCredentialsName <String>]: username to access the network path
    [PostFailoverScriptScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [PostFailoverScriptScriptCredentialsSavedCredentialsId <Int64?>]: 
    [PostFailoverScriptScriptCredentialsSavedCredentialsName <String>]: 
    [PostFailoverScriptType <String>]: The type of path being used for DR operation script
    [PreFailbackScriptGuestCredentialsCredentialsName <String>]: username to access the network path
    [PreFailbackScriptGuestCredentialsCredentialsPassword <String>]: password to access the network path
    [PreFailbackScriptGuestCredentialsSavedCredentialsId <Int64?>]: 
    [PreFailbackScriptGuestCredentialsSavedCredentialsName <String>]: 
    [PreFailbackScriptGuid <String>]: Unique script identifier string
    [PreFailbackScriptOSType <String>]: OS types
    [PreFailbackScriptPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [PreFailbackScriptReset <Boolean?>]: On set to true, resets the script to empty
    [PreFailbackScriptScriptCredentialsCredentialsName <String>]: username to access the network path
    [PreFailbackScriptScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [PreFailbackScriptScriptCredentialsSavedCredentialsId <Int64?>]: 
    [PreFailbackScriptScriptCredentialsSavedCredentialsName <String>]: 
    [PreFailbackScriptType <String>]: The type of path being used for DR operation script
    [PreFailoverScriptGuestCredentialsCredentialsName <String>]: username to access the network path
    [PreFailoverScriptGuestCredentialsCredentialsPassword <String>]: password to access the network path
    [PreFailoverScriptGuestCredentialsSavedCredentialsId <Int64?>]: 
    [PreFailoverScriptGuestCredentialsSavedCredentialsName <String>]: 
    [PreFailoverScriptGuid <String>]: Unique script identifier string
    [PreFailoverScriptOSType <String>]: OS types
    [PreFailoverScriptPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [PreFailoverScriptReset <Boolean?>]: On set to true, resets the script to empty
    [PreFailoverScriptScriptCredentialsCredentialsName <String>]: username to access the network path
    [PreFailoverScriptScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [PreFailoverScriptScriptCredentialsSavedCredentialsId <Int64?>]: 
    [PreFailoverScriptScriptCredentialsSavedCredentialsName <String>]: 
    [PreFailoverScriptType <String>]: The type of path being used for DR operation script
    [Priority <Int64?>]: The priority of the replication pair for DR operation in failover group. The lower values signify higher priority
    [SourceId <Int64?>]: The id of the source machine
    [SourceName <String>]: The name of the source machine
  [Script <IReplicationGroupScript>]: Pre/post failover and failback scripts at group level
    [PostFailbackGuestCredentialsCredentialsName <String>]: username to access the network path
    [PostFailbackGuestCredentialsCredentialsPassword <String>]: password to access the network path
    [PostFailbackGuestCredentialsSavedCredentialsId <Int64?>]: 
    [PostFailbackGuestCredentialsSavedCredentialsName <String>]: 
    [PostFailbackGuid <String>]: Unique script identifier string
    [PostFailbackOSType <String>]: OS types
    [PostFailbackPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [PostFailbackReset <Boolean?>]: On set to true, resets the script to empty
    [PostFailbackScriptCredentialsCredentialsName <String>]: username to access the network path
    [PostFailbackScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [PostFailbackScriptCredentialsSavedCredentialsId <Int64?>]: 
    [PostFailbackScriptCredentialsSavedCredentialsName <String>]: 
    [PostFailbackType <String>]: The type of path being used for DR operation script
    [PostFailoverGuestCredentialsCredentialsName <String>]: username to access the network path
    [PostFailoverGuestCredentialsCredentialsPassword <String>]: password to access the network path
    [PostFailoverGuestCredentialsSavedCredentialsId <Int64?>]: 
    [PostFailoverGuestCredentialsSavedCredentialsName <String>]: 
    [PostFailoverGuid <String>]: Unique script identifier string
    [PostFailoverOSType <String>]: OS types
    [PostFailoverPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [PostFailoverReset <Boolean?>]: On set to true, resets the script to empty
    [PostFailoverScriptCredentialsCredentialsName <String>]: username to access the network path
    [PostFailoverScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [PostFailoverScriptCredentialsSavedCredentialsId <Int64?>]: 
    [PostFailoverScriptCredentialsSavedCredentialsName <String>]: 
    [PostFailoverType <String>]: The type of path being used for DR operation script
    [PreFailbackGuestCredentialsCredentialsName <String>]: username to access the network path
    [PreFailbackGuestCredentialsCredentialsPassword <String>]: password to access the network path
    [PreFailbackGuestCredentialsSavedCredentialsId <Int64?>]: 
    [PreFailbackGuestCredentialsSavedCredentialsName <String>]: 
    [PreFailbackGuid <String>]: Unique script identifier string
    [PreFailbackOSType <String>]: OS types
    [PreFailbackPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [PreFailbackReset <Boolean?>]: On set to true, resets the script to empty
    [PreFailbackScriptCredentialsCredentialsName <String>]: username to access the network path
    [PreFailbackScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [PreFailbackScriptCredentialsSavedCredentialsId <Int64?>]: 
    [PreFailbackScriptCredentialsSavedCredentialsName <String>]: 
    [PreFailbackType <String>]: The type of path being used for DR operation script
    [PreFailoverGuestCredentialsCredentialsName <String>]: username to access the network path
    [PreFailoverGuestCredentialsCredentialsPassword <String>]: password to access the network path
    [PreFailoverGuestCredentialsSavedCredentialsId <Int64?>]: 
    [PreFailoverGuestCredentialsSavedCredentialsName <String>]: 
    [PreFailoverGuid <String>]: Unique script identifier string
    [PreFailoverOSType <String>]: OS types
    [PreFailoverPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [PreFailoverReset <Boolean?>]: On set to true, resets the script to empty
    [PreFailoverScriptCredentialsCredentialsName <String>]: username to access the network path
    [PreFailoverScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [PreFailoverScriptCredentialsSavedCredentialsId <Int64?>]: 
    [PreFailoverScriptCredentialsSavedCredentialsName <String>]: 
    [PreFailoverType <String>]: The type of path being used for DR operation script
  [UsersToNotify <IIdNameDisplayNameCompany[]>]: Users to notify/for approval of DR operations
    [CompanyId <Int64?>]: 
    [CompanyName <String>]: 
    [DisplayName <String>]: 
    [Id <Int64?>]: 
    [Name <String>]: 

ESXSERVERMAPPINGS <IEsxServerMapping[]>: The list of all ESX server mappings
  [DestinationServer <String>]: The name of destination ESX server
  [NetworkSettings <INetworkSetting[]>]: The list of all source network interface to destination network interface mapping
    [Destination <String>]: Destination network name
    [Source <String>]: Source network name
    [SourceId <String>]: Source network ID
  [SourceServer <String>]: The name of source ESX server

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

REPLICATIONPAIRS <IFailoverGroupReplicationPair[]>: List of all replication pairs that are part of the failover group
  [CopyPrecedence <Int64?>]: The copy precedence of replication pair
  [DestinationId <Int64?>]: The id of the destination machine
  [DestinationName <String>]: The name of the destination machine
  [Guid <String>]: The GUID of the source of replication pair
  [Id <Int64?>]: The ID of the replication pair
  [PostFailbackScriptGuestCredentialsCredentialsName <String>]: username to access the network path
  [PostFailbackScriptGuestCredentialsCredentialsPassword <String>]: password to access the network path
  [PostFailbackScriptGuestCredentialsSavedCredentialsId <Int64?>]: 
  [PostFailbackScriptGuestCredentialsSavedCredentialsName <String>]: 
  [PostFailbackScriptGuid <String>]: Unique script identifier string
  [PostFailbackScriptOSType <String>]: OS types
  [PostFailbackScriptPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [PostFailbackScriptReset <Boolean?>]: On set to true, resets the script to empty
  [PostFailbackScriptScriptCredentialsCredentialsName <String>]: username to access the network path
  [PostFailbackScriptScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [PostFailbackScriptScriptCredentialsSavedCredentialsId <Int64?>]: 
  [PostFailbackScriptScriptCredentialsSavedCredentialsName <String>]: 
  [PostFailbackScriptType <String>]: The type of path being used for DR operation script
  [PostFailoverScriptGuestCredentialsCredentialsName <String>]: username to access the network path
  [PostFailoverScriptGuestCredentialsCredentialsPassword <String>]: password to access the network path
  [PostFailoverScriptGuestCredentialsSavedCredentialsId <Int64?>]: 
  [PostFailoverScriptGuestCredentialsSavedCredentialsName <String>]: 
  [PostFailoverScriptGuid <String>]: Unique script identifier string
  [PostFailoverScriptOSType <String>]: OS types
  [PostFailoverScriptPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [PostFailoverScriptReset <Boolean?>]: On set to true, resets the script to empty
  [PostFailoverScriptScriptCredentialsCredentialsName <String>]: username to access the network path
  [PostFailoverScriptScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [PostFailoverScriptScriptCredentialsSavedCredentialsId <Int64?>]: 
  [PostFailoverScriptScriptCredentialsSavedCredentialsName <String>]: 
  [PostFailoverScriptType <String>]: The type of path being used for DR operation script
  [PreFailbackScriptGuestCredentialsCredentialsName <String>]: username to access the network path
  [PreFailbackScriptGuestCredentialsCredentialsPassword <String>]: password to access the network path
  [PreFailbackScriptGuestCredentialsSavedCredentialsId <Int64?>]: 
  [PreFailbackScriptGuestCredentialsSavedCredentialsName <String>]: 
  [PreFailbackScriptGuid <String>]: Unique script identifier string
  [PreFailbackScriptOSType <String>]: OS types
  [PreFailbackScriptPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [PreFailbackScriptReset <Boolean?>]: On set to true, resets the script to empty
  [PreFailbackScriptScriptCredentialsCredentialsName <String>]: username to access the network path
  [PreFailbackScriptScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [PreFailbackScriptScriptCredentialsSavedCredentialsId <Int64?>]: 
  [PreFailbackScriptScriptCredentialsSavedCredentialsName <String>]: 
  [PreFailbackScriptType <String>]: The type of path being used for DR operation script
  [PreFailoverScriptGuestCredentialsCredentialsName <String>]: username to access the network path
  [PreFailoverScriptGuestCredentialsCredentialsPassword <String>]: password to access the network path
  [PreFailoverScriptGuestCredentialsSavedCredentialsId <Int64?>]: 
  [PreFailoverScriptGuestCredentialsSavedCredentialsName <String>]: 
  [PreFailoverScriptGuid <String>]: Unique script identifier string
  [PreFailoverScriptOSType <String>]: OS types
  [PreFailoverScriptPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [PreFailoverScriptReset <Boolean?>]: On set to true, resets the script to empty
  [PreFailoverScriptScriptCredentialsCredentialsName <String>]: username to access the network path
  [PreFailoverScriptScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [PreFailoverScriptScriptCredentialsSavedCredentialsId <Int64?>]: 
  [PreFailoverScriptScriptCredentialsSavedCredentialsName <String>]: 
  [PreFailoverScriptType <String>]: The type of path being used for DR operation script
  [Priority <Int64?>]: The priority of the replication pair for DR operation in failover group. The lower values signify higher priority
  [SourceId <Int64?>]: The id of the source machine
  [SourceName <String>]: The name of the source machine

SCRIPT <IReplicationGroupScript>: Pre/post failover and failback scripts at group level
  [PostFailbackGuestCredentialsCredentialsName <String>]: username to access the network path
  [PostFailbackGuestCredentialsCredentialsPassword <String>]: password to access the network path
  [PostFailbackGuestCredentialsSavedCredentialsId <Int64?>]: 
  [PostFailbackGuestCredentialsSavedCredentialsName <String>]: 
  [PostFailbackGuid <String>]: Unique script identifier string
  [PostFailbackOSType <String>]: OS types
  [PostFailbackPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [PostFailbackReset <Boolean?>]: On set to true, resets the script to empty
  [PostFailbackScriptCredentialsCredentialsName <String>]: username to access the network path
  [PostFailbackScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [PostFailbackScriptCredentialsSavedCredentialsId <Int64?>]: 
  [PostFailbackScriptCredentialsSavedCredentialsName <String>]: 
  [PostFailbackType <String>]: The type of path being used for DR operation script
  [PostFailoverGuestCredentialsCredentialsName <String>]: username to access the network path
  [PostFailoverGuestCredentialsCredentialsPassword <String>]: password to access the network path
  [PostFailoverGuestCredentialsSavedCredentialsId <Int64?>]: 
  [PostFailoverGuestCredentialsSavedCredentialsName <String>]: 
  [PostFailoverGuid <String>]: Unique script identifier string
  [PostFailoverOSType <String>]: OS types
  [PostFailoverPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [PostFailoverReset <Boolean?>]: On set to true, resets the script to empty
  [PostFailoverScriptCredentialsCredentialsName <String>]: username to access the network path
  [PostFailoverScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [PostFailoverScriptCredentialsSavedCredentialsId <Int64?>]: 
  [PostFailoverScriptCredentialsSavedCredentialsName <String>]: 
  [PostFailoverType <String>]: The type of path being used for DR operation script
  [PreFailbackGuestCredentialsCredentialsName <String>]: username to access the network path
  [PreFailbackGuestCredentialsCredentialsPassword <String>]: password to access the network path
  [PreFailbackGuestCredentialsSavedCredentialsId <Int64?>]: 
  [PreFailbackGuestCredentialsSavedCredentialsName <String>]: 
  [PreFailbackGuid <String>]: Unique script identifier string
  [PreFailbackOSType <String>]: OS types
  [PreFailbackPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [PreFailbackReset <Boolean?>]: On set to true, resets the script to empty
  [PreFailbackScriptCredentialsCredentialsName <String>]: username to access the network path
  [PreFailbackScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [PreFailbackScriptCredentialsSavedCredentialsId <Int64?>]: 
  [PreFailbackScriptCredentialsSavedCredentialsName <String>]: 
  [PreFailbackType <String>]: The type of path being used for DR operation script
  [PreFailoverGuestCredentialsCredentialsName <String>]: username to access the network path
  [PreFailoverGuestCredentialsCredentialsPassword <String>]: password to access the network path
  [PreFailoverGuestCredentialsSavedCredentialsId <Int64?>]: 
  [PreFailoverGuestCredentialsSavedCredentialsName <String>]: 
  [PreFailoverGuid <String>]: Unique script identifier string
  [PreFailoverOSType <String>]: OS types
  [PreFailoverPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [PreFailoverReset <Boolean?>]: On set to true, resets the script to empty
  [PreFailoverScriptCredentialsCredentialsName <String>]: username to access the network path
  [PreFailoverScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [PreFailoverScriptCredentialsSavedCredentialsId <Int64?>]: 
  [PreFailoverScriptCredentialsSavedCredentialsName <String>]: 
  [PreFailoverType <String>]: The type of path being used for DR operation script

USERSTONOTIFY <IIdNameDisplayNameCompany[]>: Users to notify/for approval of DR operations
  [CompanyId <Int64?>]: 
  [CompanyName <String>]: 
  [DisplayName <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyfailovergroup
#>
function Invoke-CVModifyFailoverGroup {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the failover group
    ${FailoverGroupId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IModifyFailoverGroupRequest]
    # Modify failover group request
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IFailoverGroupArrayReplicationPair[]]
    # List of all array replication pairs for failover group
    # To construct, see NOTES section for ARRAYREPLICATIONPAIRS properties and create a hash table.
    ${ArrayReplicationPairs},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Whether to continue to next priority on DR job failure
    ${ContinueDrOnFailure},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IEsxServerMapping[]]
    # The list of all ESX server mappings
    # To construct, see NOTES section for ESXSERVERMAPPINGS properties and create a hash table.
    ${EsxServerMappings},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Whether a user approval is required for DR operations
    ${IsApprovalRequired},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Failover Group name
    ${Name},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The interval between DR operations of different priorities
    ${PriorityIntervalInMinutes},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RecoveryTargetId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RecoveryTargetName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IFailoverGroupReplicationPair[]]
    # List of all replication pairs that are part of the failover group
    # To construct, see NOTES section for REPLICATIONPAIRS properties and create a hash table.
    ${ReplicationPairs},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IReplicationGroupScript]
    # Pre/post failover and failback scripts at group level
    # To construct, see NOTES section for SCRIPT properties and create a hash table.
    ${Script},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdNameDisplayNameCompany[]]
    # Users to notify/for approval of DR operations
    # To construct, see NOTES section for USERSTONOTIFY properties and create a hash table.
    ${UsersToNotify},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyFailoverGroup_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyFailoverGroup_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyFailoverGroup_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyFailoverGroup_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify global settings used to override system default behaviour
.Description
Modify global settings used to override system default behaviour
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IModifyGlobalSettings
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IModifyGlobalSettings>: ModifyGlobalSettings
  [GlobalSettings <IModifyAdditionalSetting[]>]: 
    Category <String>: Category of the setting to be modified. This cannot be modified but is required to identify the setting for which the new value is to be set.
    Name <String>: Name of the setting to be modified. This cannot be modified but is required to identify the setting for which the new value is to be set.
    Type <String>: Type of the setting to be modified. This cannot be modified but is required to identify the setting for which the new value is to be set.
    [Comment <String>]: Comment to specify why this value was set for the specified setting
    [NewValue <String>]: New value which will be set for the specified setting, there can be fixed acceptables values for some settings. To get more details about what are acceptable value for a setting, use GET GlobalSettings or GET EntitySettings.
    [Reset <Boolean?>]: To reset the value of any already modified setting, set this to true to reset the value and regain default behaviour

GLOBALSETTINGS <IModifyAdditionalSetting[]>: .
  Category <String>: Category of the setting to be modified. This cannot be modified but is required to identify the setting for which the new value is to be set.
  Name <String>: Name of the setting to be modified. This cannot be modified but is required to identify the setting for which the new value is to be set.
  Type <String>: Type of the setting to be modified. This cannot be modified but is required to identify the setting for which the new value is to be set.
  [Comment <String>]: Comment to specify why this value was set for the specified setting
  [NewValue <String>]: New value which will be set for the specified setting, there can be fixed acceptables values for some settings. To get more details about what are acceptable value for a setting, use GET GlobalSettings or GET EntitySettings.
  [Reset <Boolean?>]: To reset the value of any already modified setting, set this to true to reset the value and regain default behaviour
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyglobalsetting
#>
function Invoke-CVModifyGlobalSetting {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IModifyGlobalSettings]
    # ModifyGlobalSettings
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IModifyAdditionalSetting[]]
    # .
    # To construct, see NOTES section for GLOBALSETTINGS properties and create a hash table.
    ${GlobalSettings},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyGlobalSetting_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyGlobalSetting_ModifyExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify details like name, encryption, security of a specific hyperscale storage
.Description
Modify details like name, encryption, security of a specific hyperscale storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateHyperScaleStorage
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateHyperScaleStorage>: UpdateHyperScaleStorage
  [EncryptionCipher <String>]: The different types of encryption keys that can be used for encrypting the data. The values are case sensitive
  [EncryptionEncrypt <Boolean?>]: 
  [EncryptionKeyLength <Int64?>]: Different keylengths are present for different kinds of ciphers. Blowfish,Twofish,AES and Serpent all accept both 128 and 256. DES3 accepts only 192. GOST accepts only 256. 
  [KeyProviderId <Int64?>]: 
  [KeyProviderName <String>]: 
  [NewName <String>]: change the name of the HyperScale storage
  [Security <IUpdateSecurityAssoc[]>]: 
    [RoleId <Int64?>]: 
    [RoleName <String>]: 
    [UserGroupId <Int64?>]: 
    [UserGroupName <String>]: 
    [UserId <Int64?>]: 
    [UserName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

SECURITY <IUpdateSecurityAssoc[]>: .
  [RoleId <Int64?>]: 
  [RoleName <String>]: 
  [UserGroupId <Int64?>]: 
  [UserGroupName <String>]: 
  [UserId <Int64?>]: 
  [UserName <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyhyperscalestorage
#>
function Invoke-CVModifyHyperScaleStorage {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of hyperscale storage
    ${HyperScaleStorageId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateHyperScaleStorage]
    # UpdateHyperScaleStorage
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The different types of encryption keys that can be used for encrypting the data.
    # The values are case sensitive
    ${EncryptionCipher},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${EncryptionEncrypt},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Different keylengths are present for different kinds of ciphers.
    # Blowfish,Twofish,AES and Serpent all accept both 128 and 256.
    # DES3 accepts only 192.
    # GOST accepts only 256.
    ${EncryptionKeyLength},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${KeyProviderId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${KeyProviderName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # change the name of the HyperScale storage
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateSecurityAssoc[]]
    # .
    # To construct, see NOTES section for SECURITY properties and create a hash table.
    ${Security},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyHyperScaleStorage_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyHyperScaleStorage_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyHyperScaleStorage_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyHyperScaleStorage_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify Backup Destination for a Plan
.Description
Modify Backup Destination for a Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdatePlanBackupDestination
.Outputs
Commvault.Powershell.Models.IPlanBackupDestinationResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdatePlanBackupDestination>: .
  [BackupStartTime <Int64?>]: Specify the Backup start time in seconds. The time is provided in unix time format.
  [BackupsToCopy <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [EnableDataAging <Boolean?>]: Tells if this copy has data aging enabled
  [FirstExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [FirstExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [FirstExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [Mappings <ISnapshotCopyMapping[]>]: 
    [SourceId <Int64?>]: 
    [SourceName <String>]: 
    [SourceVendorId <Int64?>]: 
    [SourceVendorName <String>]: 
    [TargetId <Int64?>]: 
    [TargetName <String>]: 
    [TargetVendorId <Int64?>]: 
    [TargetVendorName <String>]: 
    [Vendor <String>]: Snapshot vendors available for Snap Copy mappings
  [NewName <String>]: New name for backup destination
  [OverrideRetentionSettings <Boolean?>]: Tells if this copy should use storage pool retention period days or the retention defined for this copy. Set as true to use retention defined on this copy.
  [RetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention.
  [RetentionRuleType <String>]: Which type of retention rule should be used for the given backup destination
  [SecondExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [SecondExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [SecondExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [SnapRecoveryPoints <Int64?>]: Number of snap recovery points for snap copy for retention. Can be specified instead of retention period in Days for snap copy.
  [SourceCopyId <Int64?>]: 
  [SourceCopyName <String>]: 
  [ThirdExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [ThirdExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [ThirdExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [UseExtendedRetentionRules <Boolean?>]: Use extended retention rules. Must specify if updating extended retention rules.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

MAPPINGS <ISnapshotCopyMapping[]>: .
  [SourceId <Int64?>]: 
  [SourceName <String>]: 
  [SourceVendorId <Int64?>]: 
  [SourceVendorName <String>]: 
  [TargetId <Int64?>]: 
  [TargetName <String>]: 
  [TargetVendorId <Int64?>]: 
  [TargetVendorName <String>]: 
  [Vendor <String>]: Snapshot vendors available for Snap Copy mappings
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifylaptopbackupdestination
#>
function Invoke-CVModifyLaptopBackupDestination {
[OutputType([Commvault.Powershell.Models.IPlanBackupDestinationResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backupDestination to be modified
    ${BackupDestinationId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to modify
    ${PlanId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdatePlanBackupDestination]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify the Backup start time in seconds.
    # The time is provided in unix time format.
    ${BackupStartTime},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${BackupsToCopy},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Tells if this copy has data aging enabled
    ${EnableDataAging},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If this is set as true, no need to specify retentionPeriodDays.
    ${FirstExtendedRetentionRuleIsInfiniteRetention},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # If this is set, no need to specify isInfiniteRetention as false.
    ${FirstExtendedRetentionRuleRetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${FirstExtendedRetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapshotCopyMapping[]]
    # .
    # To construct, see NOTES section for MAPPINGS properties and create a hash table.
    ${Mappings},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # New name for backup destination
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Tells if this copy should use storage pool retention period days or the retention defined for this copy.
    # Set as true to use retention defined on this copy.
    ${OverrideRetentionSettings},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Retention period in days.
    # -1 can be specified for infinite retention.
    ${RetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Which type of retention rule should be used for the given backup destination
    ${RetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If this is set as true, no need to specify retentionPeriodDays.
    ${SecondExtendedRetentionRuleIsInfiniteRetention},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # If this is set, no need to specify isInfiniteRetention as false.
    ${SecondExtendedRetentionRuleRetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${SecondExtendedRetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of snap recovery points for snap copy for retention.
    # Can be specified instead of retention period in Days for snap copy.
    ${SnapRecoveryPoints},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SourceCopyId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SourceCopyName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If this is set as true, no need to specify retentionPeriodDays.
    ${ThirdExtendedRetentionRuleIsInfiniteRetention},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # If this is set, no need to specify isInfiniteRetention as false.
    ${ThirdExtendedRetentionRuleRetentionPeriodDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    ${ThirdExtendedRetentionRuleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Use extended retention rules.
    # Must specify if updating extended retention rules.
    ${UseExtendedRetentionRules},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyLaptopBackupDestination_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyLaptopBackupDestination_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyLaptopBackupDestination_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyLaptopBackupDestination_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify existing laptop plan details
.Description
Modify existing laptop plan details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateLaptopPlan
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ALERTS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 

ALLOWEDFEATURES <ILaptopPlanAllowedFeatures>: Create/modify allowed features of laptop plan
  [Archiving <Boolean?>]: Flag to enable archiving of laptop data
  [ArchivingRuleAfterArchiving <String>]: After an archive job, replace the file that meets the archiving rules with a stub or delete the file that meets the archiving rules
  [ArchivingRuleArchiveReadOnlyFiles <Boolean?>]: To archive files based on the Read-Only attribute, set to TRUE
  [ArchivingRuleFileAccessTimeOlderThan <Int64?>]: To archive files based on the last accessed date of each file within the folder, specify the number of days
  [ArchivingRuleFileCreatedTimeOlderThan <Int64?>]: To archive files based on the time the files were created within the folder, specify the number of days
  [ArchivingRuleFileModifiedTimeOlderThan <Int64?>]: To archive files based on the last modified date of each file within the folder, specify the number of days
  [ArchivingRuleFileSizeGreaterThan <Int64?>]: To archive files based on the size of the file, specify the minimum file size in KB. All files whose size ranges between the minimum and maximum values are archived.
  [ArchivingRuleMaximumFileSize <Int64?>]: To archive files based on the size of the file, specify the maximum file size in KB. All files whose size ranges between the minimum and maximum values are archived.
  [ArchivingRuleStartCleaningIfLessThan <Int64?>]: When free disk space falls below specified amount (in percentage), start cleaning up the disk
  [ArchivingRuleStopCleaningIfupto <Int64?>]: When free disk space more than specified amount (in percentage), stop cleaning up the disk
  [ClientId <Int64?>]: 
  [ClientName <String>]: 
  [Dlp <Boolean?>]: Flag to enable Data loss protection
  [EdgeDrive <Boolean?>]: Flag to enable Edge Drive
  [EdgeDriveSettingAuditDriveOperations <Boolean?>]: Enable auditing which logs the activities based on user interaction like creating, editing, moving, renaming, downloading or deleting files.
  [EdgeDriveSettingCreateNewIndexServer <Boolean?>]: If set to false, uses existing edge index server and requires IndexServer IdName to be passed. If set to true, requires client IdName and indexCachePath to create a new Index Server.
  [EdgeDriveSettingEdgeDriveQuota <Int64?>]: Maximum number of gigabytes that you can store in the Edge Drive. Giving value as -1 means no quota.
  [EdgeDriveSettingIndexCachePath <String>]: 
  [EdgeDriveSettingNotificationsForShares <Boolean?>]: Enables alert notification feature which allows the share user or share owner to subscribe for share notifications when any activities are performed on the Edge Drive or the Collaborative share. The user can receive the notifications on the Web Console or as an email notification.
  [IndexServerId <Int64?>]: 
  [IndexServerName <String>]: 

ASSOCIATEDUSERSANDUSERGROUPS <IPlanUserOrGroups[]>: .
  [Id <Int64?>]: This gives Id of user or user group or external user group
  [Name <String>]: This gives name of user or user group or external user group
  [SendInvite <Boolean?>]: If set to true, will send an invite email to the user or group. Default is true.
  [Type <String>]: Tells what kind of user or user group it is

BODY <IUpdateLaptopPlan>: .
  [Alerts <IIdName[]>]: 
    [Id <Int64?>]: 
    [Name <String>]: 
  [AllowPlanOverride <Boolean?>]: Flag to enable overriding of plan
  [AllowedFeatures <ILaptopPlanAllowedFeatures>]: Create/modify allowed features of laptop plan
    [Archiving <Boolean?>]: Flag to enable archiving of laptop data
    [ArchivingRuleAfterArchiving <String>]: After an archive job, replace the file that meets the archiving rules with a stub or delete the file that meets the archiving rules
    [ArchivingRuleArchiveReadOnlyFiles <Boolean?>]: To archive files based on the Read-Only attribute, set to TRUE
    [ArchivingRuleFileAccessTimeOlderThan <Int64?>]: To archive files based on the last accessed date of each file within the folder, specify the number of days
    [ArchivingRuleFileCreatedTimeOlderThan <Int64?>]: To archive files based on the time the files were created within the folder, specify the number of days
    [ArchivingRuleFileModifiedTimeOlderThan <Int64?>]: To archive files based on the last modified date of each file within the folder, specify the number of days
    [ArchivingRuleFileSizeGreaterThan <Int64?>]: To archive files based on the size of the file, specify the minimum file size in KB. All files whose size ranges between the minimum and maximum values are archived.
    [ArchivingRuleMaximumFileSize <Int64?>]: To archive files based on the size of the file, specify the maximum file size in KB. All files whose size ranges between the minimum and maximum values are archived.
    [ArchivingRuleStartCleaningIfLessThan <Int64?>]: When free disk space falls below specified amount (in percentage), start cleaning up the disk
    [ArchivingRuleStopCleaningIfupto <Int64?>]: When free disk space more than specified amount (in percentage), stop cleaning up the disk
    [ClientId <Int64?>]: 
    [ClientName <String>]: 
    [Dlp <Boolean?>]: Flag to enable Data loss protection
    [EdgeDrive <Boolean?>]: Flag to enable Edge Drive
    [EdgeDriveSettingAuditDriveOperations <Boolean?>]: Enable auditing which logs the activities based on user interaction like creating, editing, moving, renaming, downloading or deleting files.
    [EdgeDriveSettingCreateNewIndexServer <Boolean?>]: If set to false, uses existing edge index server and requires IndexServer IdName to be passed. If set to true, requires client IdName and indexCachePath to create a new Index Server.
    [EdgeDriveSettingEdgeDriveQuota <Int64?>]: Maximum number of gigabytes that you can store in the Edge Drive. Giving value as -1 means no quota.
    [EdgeDriveSettingIndexCachePath <String>]: 
    [EdgeDriveSettingNotificationsForShares <Boolean?>]: Enables alert notification feature which allows the share user or share owner to subscribe for share notifications when any activities are performed on the Edge Drive or the Collaborative share. The user can receive the notifications on the Web Console or as an email notification.
    [IndexServerId <Int64?>]: 
    [IndexServerName <String>]: 
  [AssociatedUsersAndUserGroups <IPlanUserOrGroups[]>]: 
    [Id <Int64?>]: This gives Id of user or user group or external user group
    [Name <String>]: This gives name of user or user group or external user group
    [SendInvite <Boolean?>]: If set to true, will send an invite email to the user or group. Default is true.
    [Type <String>]: Tells what kind of user or user group it is
  [BackupContentFileSystemQuota <Int64?>]: Maximum number of gigabytes that you can store in the File System. Giving value as -1 means infinite file system quota.
  [BackupContentMacExcludedPaths <String[]>]: Paths to exclude for Mac
  [BackupContentMacIncludedPaths <String[]>]: Paths to include for Mac
  [BackupContentUnixExcludedPaths <String[]>]: Paths to exclude for UNIX
  [BackupContentUnixIncludedPaths <String[]>]: Paths to include for UNIX
  [BackupContentWindowsExcludedPaths <String[]>]: Paths to exclude for Windows
  [BackupContentWindowsIncludedPaths <String[]>]: Paths to include for Windows
  [FileVersionDailyVersions <Int64?>]: Custom version rule: Retain daily versions for this many day(s)
  [FileVersionDays <Int64?>]: Retain files for this many days. Year(s) or month(s) need to be converted to day(s)
  [FileVersionMonthlyVersions <Int64?>]: Custom version rule: Retain monthly versions for this many month(s)
  [FileVersionVersions <Int64?>]: Retain this many file versions. This is considered as default if no file retention rule is specified.
  [FileVersionWeeklyVersions <Int64?>]: Custom version rule: Retain weekly versions for this many week(s)
  [GeneralOptimizedForCloudBackups <Boolean?>]: This feature allows laptops to write backup directly to the cloud storage. It helps to optimize scale by reducing server dependency and extra data hops. Once the feature is enabled, the existing and the newly-added laptops use optimized backups.
  [NetworkResourceThrottleReceive <Int64?>]: Maximum kilobits per second to throttle the receiving speed of data. Giving value as -1 means infinite throttle send speed i.e. no limit
  [NetworkResourceThrottleSend <Int64?>]: Maximum kilobits per second to throttle the emitting speed of data. Giving value as -1 means infinite throttle send speed i.e. no limit
  [NewName <String>]: New plan name to update
  [OfflineLaptopDeleteAfterDays <Int64?>]: The offline laptops are automatically deleted when the number of days are met. -1 means never.
  [OfflineLaptopRetireAfterDays <Int64?>]: The offline laptops are retired when the number of days are met. -1 means never.
  [OverrideRestrictionBackupContent <String>]: 
  [OverrideRestrictionRetention <String>]: 
  [OverrideRestrictionRpo <String>]: 
  [OverrideRestrictionStoragePool <String>]: 
  [RegionToConfigureId <Int64?>]: 
  [RegionToConfigureName <String>]: 
  [RetentionDeletedItemRetention <Int64?>]: Amount of days after deletion of files to keep the items. Giving value as -1 means to retain files indefinitely.
  [RpoBackupFrequency <Int64?>]: Specify incremental backup frequency in minutes. Backup operation will start as per the time zone of the associated server.
  [SlaEnableAfterDelay <Int64?>]: Time provided in Unix format. Give 0 to reset any existing delay.
  [SlaExcludeFromSla <Boolean?>]: Flag to set to exclude plan from SLA
  [SlaExclusionReason <String>]: Reason for exclusion from SLA
  [SlaLogSlaMinutes <Int64?>]: Database log SLA period in Minutes
  [SlaPeriod <Int64?>]: SLA Period in Days
  [SlaUseSystemDefaultSla <Boolean?>]: Flag to set to use System Default Service Level Agreement

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifylaptopplan
#>
function Invoke-CVModifyLaptopPlan {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the plan
    ${PlanId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateLaptopPlan]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for ALERTS properties and create a hash table.
    ${Alerts},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to enable overriding of plan
    ${AllowPlanOverride},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ILaptopPlanAllowedFeatures]
    # Create/modify allowed features of laptop plan
    # To construct, see NOTES section for ALLOWEDFEATURES properties and create a hash table.
    ${AllowedFeatures},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanUserOrGroups[]]
    # .
    # To construct, see NOTES section for ASSOCIATEDUSERSANDUSERGROUPS properties and create a hash table.
    ${AssociatedUsersAndUserGroups},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Maximum number of gigabytes that you can store in the File System.
    # Giving value as -1 means infinite file system quota.
    ${BackupContentFileSystemQuota},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for Mac
    ${BackupContentMacExcludedPaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for Mac
    ${BackupContentMacIncludedPaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for UNIX
    ${BackupContentUnixExcludedPaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for UNIX
    ${BackupContentUnixIncludedPaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for Windows
    ${BackupContentWindowsExcludedPaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for Windows
    ${BackupContentWindowsIncludedPaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Custom version rule: Retain daily versions for this many day(s)
    ${FileVersionDailyVersions},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Retain files for this many days.
    # Year(s) or month(s) need to be converted to day(s)
    ${FileVersionDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Custom version rule: Retain monthly versions for this many month(s)
    ${FileVersionMonthlyVersions},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Retain this many file versions.
    # This is considered as default if no file retention rule is specified.
    ${FileVersionVersions},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Custom version rule: Retain weekly versions for this many week(s)
    ${FileVersionWeeklyVersions},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # This feature allows laptops to write backup directly to the cloud storage.
    # It helps to optimize scale by reducing server dependency and extra data hops.
    # Once the feature is enabled, the existing and the newly-added laptops use optimized backups.
    ${GeneralOptimizedForCloudBackups},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Maximum kilobits per second to throttle the receiving speed of data.
    # Giving value as -1 means infinite throttle send speed i.e.
    # no limit
    ${NetworkResourceThrottleReceive},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Maximum kilobits per second to throttle the emitting speed of data.
    # Giving value as -1 means infinite throttle send speed i.e.
    # no limit
    ${NetworkResourceThrottleSend},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # New plan name to update
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The offline laptops are automatically deleted when the number of days are met.
    # -1 means never.
    ${OfflineLaptopDeleteAfterDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The offline laptops are retired when the number of days are met.
    # -1 means never.
    ${OfflineLaptopRetireAfterDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionBackupContent},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionRetention},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionRpo},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionStoragePool},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RegionToConfigureId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RegionToConfigureName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Amount of days after deletion of files to keep the items.
    # Giving value as -1 means to retain files indefinitely.
    ${RetentionDeletedItemRetention},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify incremental backup frequency in minutes.
    # Backup operation will start as per the time zone of the associated server.
    ${RpoBackupFrequency},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Time provided in Unix format.
    # Give 0 to reset any existing delay.
    ${SlaEnableAfterDelay},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to set to exclude plan from SLA
    ${SlaExcludeFromSla},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Reason for exclusion from SLA
    ${SlaExclusionReason},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Database log SLA period in Minutes
    ${SlaLogSlaMinutes},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # SLA Period in Days
    ${SlaPeriod},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to set to use System Default Service Level Agreement
    ${SlaUseSystemDefaultSla},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyLaptopPlan_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyLaptopPlan_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyLaptopPlan_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyLaptopPlan_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to modify a local storage access path
.Description
Used to modify a local storage access path
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateLocalAccessPath
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateLocalAccessPath>: Used to update access path
  [Access <String>]: The access type for the access path can be either read (writing to path not allowed) or read and write (writing to path allowed).
  [CredentialsName <String>]: username to access the network path
  [CredentialsPassword <String>]: password to access the network path
  [Enabled <Boolean?>]: 
  [MediaAgentId <Int64?>]: 
  [MediaAgentName <String>]: 
  [Path <String>]: Can be used to change the disk access path.
  [SavedCredentialsId <Int64?>]: 
  [SavedCredentialsName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifylocalaccesspath
#>
function Invoke-CVModifyLocalAccessPath {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the mount path whose access path has to be modified
    ${AccessPathId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the mount path whose access path has to be modified
    ${BackupLocationId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Local storage pool whose access path has to be modified
    ${StoragePoolId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateLocalAccessPath]
    # Used to update access path
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The access type for the access path can be either read (writing to path not allowed) or read and write (writing to path allowed).
    ${Access},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # username to access the network path
    ${CredentialsName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # password to access the network path
    ${CredentialsPassword},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${Enabled},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${MediaAgentId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${MediaAgentName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Can be used to change the disk access path.
    ${Path},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SavedCredentialsId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SavedCredentialsName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyLocalAccessPath_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyLocalAccessPath_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyLocalAccessPath_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyLocalAccessPath_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify the properties of an existing mount path of local storage pool
.Description
Modify the properties of an existing mount path of local storage pool
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateBackupLocation
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateBackupLocation>: While adding network access path, please add credentials or saved credentials. If both are provided, credentials will be selected.
  [Access <String>]: The access type for the access path can be either read (writing to path not allowed) or read and write (writing to path allowed).
  [BackupLocation <String>]: Can be used to change the disk access path.
  [ConfigurationDisableBackupLocationforFutureBackups <Boolean?>]: Used to determine if backup location has to be disabled or enabled for future backups
  [ConfigurationEnableBackupLocation <Boolean?>]: Used to enable or disable backup location
  [ConfigurationPrepareForRetirement <Boolean?>]: Used to determine if the backup location has to be prepared for retirement
  [CredentialsName <String>]: username to access the network path
  [CredentialsPassword <String>]: password to access the network path
  [Enabled <Boolean?>]: 
  [MediaAgentId <Int64?>]: 
  [MediaAgentName <String>]: 
  [SavedCredentialsId <Int64?>]: 
  [SavedCredentialsName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifylocalbackuplocation
#>
function Invoke-CVModifyLocalBackupLocation {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backup location to update
    ${BackupLocationId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the local storage pool to update
    ${StoragePoolId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateBackupLocation]
    # While adding network access path, please add credentials or saved credentials.
    # If both are provided, credentials will be selected.
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The access type for the access path can be either read (writing to path not allowed) or read and write (writing to path allowed).
    ${Access},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Can be used to change the disk access path.
    ${BackupLocation},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Used to determine if backup location has to be disabled or enabled for future backups
    ${ConfigurationDisableBackupLocationforFutureBackups},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Used to enable or disable backup location
    ${ConfigurationEnableBackupLocation},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Used to determine if the backup location has to be prepared for retirement
    ${ConfigurationPrepareForRetirement},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # username to access the network path
    ${CredentialsName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # password to access the network path
    ${CredentialsPassword},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${Enabled},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${MediaAgentId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${MediaAgentName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SavedCredentialsId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SavedCredentialsName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyLocalBackupLocation_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyLocalBackupLocation_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyLocalBackupLocation_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyLocalBackupLocation_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify the properties of an existing local storage pool
.Description
Modify the properties of an existing local storage pool
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateLocalStorage
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateLocalStorage>: .
  [DataEncryptionCipher <String>]: The different types of encryption keys that can be used for encrypting the data. The values are case sensitive
  [DataEncryptionEncrypt <Boolean?>]: 
  [DataEncryptionKeyLength <Int64?>]: Different keylengths are present for different kinds of ciphers. Blowfish,Twofish,AES and Serpent all accept both 128 and 256. DES3 accepts only 192. GOST accepts only 256. 
  [KeyProviderId <Int64?>]: 
  [KeyProviderName <String>]: 
  [Name <String>]: change the name of the storage pool
  [Security <IUpdateSecurityAssoc[]>]: 
    [RoleId <Int64?>]: 
    [RoleName <String>]: 
    [UserGroupId <Int64?>]: 
    [UserGroupName <String>]: 
    [UserId <Int64?>]: 
    [UserName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

SECURITY <IUpdateSecurityAssoc[]>: .
  [RoleId <Int64?>]: 
  [RoleName <String>]: 
  [UserGroupId <Int64?>]: 
  [UserGroupName <String>]: 
  [UserId <Int64?>]: 
  [UserName <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifylocalstorage
#>
function Invoke-CVModifyLocalStorage {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the local storage to update
    ${StoragePoolId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateLocalStorage]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The different types of encryption keys that can be used for encrypting the data.
    # The values are case sensitive
    ${DataEncryptionCipher},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${DataEncryptionEncrypt},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Different keylengths are present for different kinds of ciphers.
    # Blowfish,Twofish,AES and Serpent all accept both 128 and 256.
    # DES3 accepts only 192.
    # GOST accepts only 256.
    ${DataEncryptionKeyLength},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${KeyProviderId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${KeyProviderName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # change the name of the storage pool
    ${Name},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateSecurityAssoc[]]
    # .
    # To construct, see NOTES section for SECURITY properties and create a hash table.
    ${Security},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyLocalStorage_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyLocalStorage_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyLocalStorage_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyLocalStorage_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify the properties of an existing media agent
.Description
Modify the properties of an existing media agent
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateMediaAgent
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateMediaAgent>: .
  [ControlEnabled <Boolean?>]: Determines if the media agent is currently enabled or disabled.
  [ControlMaintenanceMode <Boolean?>]: Specifies whether the MediaAgent is available for data protection, data recovery and auxiliary copy operations.
  [ControlOptimizeForConcurrentLanBackups <Boolean?>]: Allows optimization for concurrent LAN backups. If set to true, default value for parallel data transfer operations will be 100. If set to false, default value of parallel data transfer operations will be set to 25.
  [ControlParallelDataTransferOperations <Int64?>]: Specifies the number of parallel data operations that can take place. 
  [ControlRansomwareProtection <Boolean?>]: If set to true, ransomware protection against the media agent is enabled. If set to false, ransomware protection against media agent is disabled.
  [Description <String>]: Provides the media agent with a new description.
  [IndexCachePath <String>]: Path where the index cache is maintained.
  [LogCacheEnabled <Boolean?>]: This tag determines if the logs cache has been enabled or not. 
  [LogCachePath <String>]: If the logs cache is enabled, this tag gives the path to store the logs cache.
  [RoleId <Int64?>]: 
  [RoleName <String>]: 
  [UserGroupId <Int64?>]: 
  [UserGroupName <String>]: 
  [UserId <Int64?>]: 
  [UserName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifymediaagent
#>
function Invoke-CVModifyMediaAgent {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the mediaAgent to update
    ${MediaAgentId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateMediaAgent]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Determines if the media agent is currently enabled or disabled.
    ${ControlEnabled},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Specifies whether the MediaAgent is available for data protection, data recovery and auxiliary copy operations.
    ${ControlMaintenanceMode},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Allows optimization for concurrent LAN backups.
    # If set to true, default value for parallel data transfer operations will be 100.
    # If set to false, default value of parallel data transfer operations will be set to 25.
    ${ControlOptimizeForConcurrentLanBackups},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specifies the number of parallel data operations that can take place.
    ${ControlParallelDataTransferOperations},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If set to true, ransomware protection against the media agent is enabled.
    # If set to false, ransomware protection against media agent is disabled.
    ${ControlRansomwareProtection},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Provides the media agent with a new description.
    ${Description},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Path where the index cache is maintained.
    ${IndexCachePath},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # This tag determines if the logs cache has been enabled or not.
    ${LogCacheEnabled},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # If the logs cache is enabled, this tag gives the path to store the logs cache.
    ${LogCachePath},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RoleId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RoleName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${UserGroupId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${UserGroupName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${UserId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${UserName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyMediaAgent_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyMediaAgent_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyMediaAgent_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyMediaAgent_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to modify an exsiting ObjectStore plan
.Description
Used to modify an exsiting ObjectStore plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateObjectStorePlan
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BACKUPDESTINATIONS <IObjectStorePlanUpdateBkpDest[]>: Copy destinations for the plan. Specify where you want to store your data.
  [EnableDataAging <Boolean?>]: enable or disable Datat aging on the backup destiantion
  [FirstExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [FirstExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [FirstExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [PlanBackupDestinationId <Int64?>]: Id of the backup destination to modify/delete
  [PlanBackupDestinationName <String>]: Backup Destination Name for add/modify operation
  [RetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention.
  [SecondExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [SecondExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [SecondExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [SourceCopyId <Int64?>]: 
  [SourceCopyName <String>]: 
  [StoragePoolId <Int64?>]: 
  [StoragePoolName <String>]: 
  [StorageType <String>]: StorageType
  [ThirdExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [ThirdExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [ThirdExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [UseExtendedRetentionRules <Boolean?>]: Use extended retention rules(not applicable to the Primary(Snap) copy)

BACKUPFREQUENCYSCHEDULES <IObjectStorePlanSchedule[]>: .
  SchedulePatternScheduleFrequencyType <String>: schedule frequency type
  [PolicyId <Int64?>]: Schedule policy Id to which the schedule belongs
  [ScheduleId <Int64?>]: Id of the schedule if available, required for modifying, deleting schedule
  [ScheduleName <String>]: Name of the schedule, for modify
  [ScheduleOperation <String>]: Operation being performed on schedule
  [SchedulePatternDayOfMonth <Int64?>]: Day on which to run the schedule, applicable for monthly, yearly
  [SchedulePatternDayOfWeek <String>]: 
  [SchedulePatternDaysBetweenSyntheticFulls <Int64?>]: No of days between two synthetic full jobs
  [SchedulePatternEndDate <Int64?>]: Schedule end date in epoch format
  [SchedulePatternExceptions <IScheduleRunException[]>]: Exceptions to when a schedule should not run, either in dates or week of month and days
    [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
    [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
    [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
  [SchedulePatternFrequency <Int64?>]: Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
  [SchedulePatternMaxBackupIntervalInMins <Int64?>]: The number of mins to force a backup on automatic schedule.
  [SchedulePatternMonthOfYear <String>]: 
  [SchedulePatternNoOfTimes <Int64?>]: The number of times you want the schedule to run.
  [SchedulePatternRepeatIntervalInMinutes <Int64?>]: How often in minutes in a day the schedule runs, applicable for daily, weekly, monthly and yearly frequency types.
  [SchedulePatternRepeatUntilTime <Int64?>]: Until what time to repeat the schedule in a day, requires repeatIntervalInMinutes
  [SchedulePatternStartDate <Int64?>]: start date of schedule in epoch format
  [SchedulePatternStartTime <Int64?>]: start time of schedule in seconds
  [SchedulePatternWeekOfMonth <String>]: Specific week of a month
  [SchedulePatternWeeklyDays <String[]>]: Days of the week for weekly frequency
  [TimezoneId <Int64?>]: 
  [TimezoneName <String>]: 

BODY <IUpdateObjectStorePlan>: .
  [BackupDestinationOperationType <String>]: Operation type for backup destination
  [BackupDestinations <IObjectStorePlanUpdateBkpDest[]>]: Copy destinations for the plan. Specify where you want to store your data.
    [EnableDataAging <Boolean?>]: enable or disable Datat aging on the backup destiantion
    [FirstExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
    [FirstExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
    [FirstExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    [PlanBackupDestinationId <Int64?>]: Id of the backup destination to modify/delete
    [PlanBackupDestinationName <String>]: Backup Destination Name for add/modify operation
    [RetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention.
    [SecondExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
    [SecondExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
    [SecondExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    [SourceCopyId <Int64?>]: 
    [SourceCopyName <String>]: 
    [StoragePoolId <Int64?>]: 
    [StoragePoolName <String>]: 
    [StorageType <String>]: StorageType
    [ThirdExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
    [ThirdExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
    [ThirdExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    [UseExtendedRetentionRules <Boolean?>]: Use extended retention rules(not applicable to the Primary(Snap) copy)
  [BackupFrequencyOperationType <String>]: Operation type for the list
  [BackupFrequencySchedules <IObjectStorePlanSchedule[]>]: 
    SchedulePatternScheduleFrequencyType <String>: schedule frequency type
    [PolicyId <Int64?>]: Schedule policy Id to which the schedule belongs
    [ScheduleId <Int64?>]: Id of the schedule if available, required for modifying, deleting schedule
    [ScheduleName <String>]: Name of the schedule, for modify
    [ScheduleOperation <String>]: Operation being performed on schedule
    [SchedulePatternDayOfMonth <Int64?>]: Day on which to run the schedule, applicable for monthly, yearly
    [SchedulePatternDayOfWeek <String>]: 
    [SchedulePatternDaysBetweenSyntheticFulls <Int64?>]: No of days between two synthetic full jobs
    [SchedulePatternEndDate <Int64?>]: Schedule end date in epoch format
    [SchedulePatternExceptions <IScheduleRunException[]>]: Exceptions to when a schedule should not run, either in dates or week of month and days
      [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
      [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
      [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
    [SchedulePatternFrequency <Int64?>]: Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
    [SchedulePatternMaxBackupIntervalInMins <Int64?>]: The number of mins to force a backup on automatic schedule.
    [SchedulePatternMonthOfYear <String>]: 
    [SchedulePatternNoOfTimes <Int64?>]: The number of times you want the schedule to run.
    [SchedulePatternRepeatIntervalInMinutes <Int64?>]: How often in minutes in a day the schedule runs, applicable for daily, weekly, monthly and yearly frequency types.
    [SchedulePatternRepeatUntilTime <Int64?>]: Until what time to repeat the schedule in a day, requires repeatIntervalInMinutes
    [SchedulePatternStartDate <Int64?>]: start date of schedule in epoch format
    [SchedulePatternStartTime <Int64?>]: start time of schedule in seconds
    [SchedulePatternWeekOfMonth <String>]: Specific week of a month
    [SchedulePatternWeeklyDays <String[]>]: Days of the week for weekly frequency
    [TimezoneId <Int64?>]: 
    [TimezoneName <String>]: 
  [Name <String>]: New plan name to update
  [RpoFullBackupWindow <IDayAndTime[]>]: Backup window for full backup
    [DayOfWeek <String[]>]: 
    [EndTime <Int64?>]: Time in seconds since the beginning of the day
    [StartTime <Int64?>]: Time in seconds since the beginning of the day
  [SlaEnableAfterDelay <Int64?>]: Time provided in Unix format. Give 0 to reset any existing delay.
  [SlaExcludeFromSla <Boolean?>]: Flag to set to exclude plan from SLA
  [SlaExclusionReason <String>]: Reason for exclusion from SLA
  [SlaLogSlaMinutes <Int64?>]: Database log SLA period in Minutes
  [SlaPeriod <Int64?>]: SLA Period in Days
  [SlaUseSystemDefaultSla <Boolean?>]: Flag to set to use System Default Service Level Agreement

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

RPOFULLBACKUPWINDOW <IDayAndTime[]>: Backup window for full backup
  [DayOfWeek <String[]>]: 
  [EndTime <Int64?>]: Time in seconds since the beginning of the day
  [StartTime <Int64?>]: Time in seconds since the beginning of the day
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyobjectstoreplan
#>
function Invoke-CVModifyObjectStorePlan {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to update
    ${PlanId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateObjectStorePlan]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Operation type for backup destination
    ${BackupDestinationOperationType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IObjectStorePlanUpdateBkpDest[]]
    # Copy destinations for the plan.
    # Specify where you want to store your data.
    # To construct, see NOTES section for BACKUPDESTINATIONS properties and create a hash table.
    ${BackupDestinations},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Operation type for the list
    ${BackupFrequencyOperationType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IObjectStorePlanSchedule[]]
    # .
    # To construct, see NOTES section for BACKUPFREQUENCYSCHEDULES properties and create a hash table.
    ${BackupFrequencySchedules},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # New plan name to update
    ${Name},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDayAndTime[]]
    # Backup window for full backup
    # To construct, see NOTES section for RPOFULLBACKUPWINDOW properties and create a hash table.
    ${RpoFullBackupWindow},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Time provided in Unix format.
    # Give 0 to reset any existing delay.
    ${SlaEnableAfterDelay},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to set to exclude plan from SLA
    ${SlaExcludeFromSla},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Reason for exclusion from SLA
    ${SlaExclusionReason},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Database log SLA period in Minutes
    ${SlaLogSlaMinutes},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # SLA Period in Days
    ${SlaPeriod},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to set to use System Default Service Level Agreement
    ${SlaUseSystemDefaultSla},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyObjectStorePlan_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyObjectStorePlan_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyObjectStorePlan_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyObjectStorePlan_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to modify an exsiting server plan
.Description
Used to modify an exsiting server plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateServerPlan
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BACKUPFREQUENCYSCHEDULES <IPlanSchedule[]>: .
  BackupType <String>: Schedule Backup level
  SchedulePatternScheduleFrequencyType <String>: schedule frequency type
  [ForDatabasesOnly <Boolean?>]: Boolean to indicate if schedule is for database agents
  [IsRetentionBasedSyntheticFull <Boolean?>]: Boolean to indicate if synthetic full schedule is based on retention rules
  [PolicyId <Int64?>]: Schedule policy Id to which the schedule belongs
  [ScheduleId <Int64?>]: Id of the schedule if available, required for modifying, deleting schedule
  [ScheduleName <String>]: Name of the schedule, for modify
  [ScheduleOperation <String>]: Operation being performed on schedule
  [ScheduleOptionCommitFrequencyInHours <Int64?>]: Commit frequency in hours for disk cache backups from automatic schedules
  [ScheduleOptionDaysBetweenAutoConvert <Int64?>]: Number of days between auto conversion of backup level applicable for databases on incremental and differential schedules of server plan
  [ScheduleOptionJobRunningTimeInMins <Int64?>]: total job running time in minutes
  [ScheduleOptionLogFilesThreshold <Int64?>]: The min number of archived log files before a backup job should start
  [ScheduleOptionLogsDiskUtilizationPercent <Int64?>]: The min log destination disk threshold percentage
  [ScheduleOptionMinBackupIntervalInMins <Int64?>]: The min number of mins to check for file activity on automatic schedule.
  [ScheduleOptionO365ItemSelectionOption <String>]: item backup option for O365 V2 backup jobs
  [ScheduleOptionUseDiskCacheForLogBackups <Boolean?>]: Used to enable disk caching feature on databases for automatic schedules on server plan
  [SchedulePatternDayOfMonth <Int64?>]: Day on which to run the schedule, applicable for monthly, yearly
  [SchedulePatternDayOfWeek <String>]: 
  [SchedulePatternDaysBetweenSyntheticFulls <Int64?>]: No of days between two synthetic full jobs
  [SchedulePatternEndDate <Int64?>]: Schedule end date in epoch format
  [SchedulePatternExceptions <IScheduleRunException[]>]: Exceptions to when a schedule should not run, either in dates or week of month and days
    [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
    [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
    [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
  [SchedulePatternFrequency <Int64?>]: Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
  [SchedulePatternMaxBackupIntervalInMins <Int64?>]: The number of mins to force a backup on automatic schedule.
  [SchedulePatternMonthOfYear <String>]: 
  [SchedulePatternNoOfTimes <Int64?>]: The number of times you want the schedule to run.
  [SchedulePatternRepeatIntervalInMinutes <Int64?>]: How often in minutes in a day the schedule runs, applicable for daily, weekly, monthly and yearly frequency types.
  [SchedulePatternRepeatUntilTime <Int64?>]: Until what time to repeat the schedule in a day, requires repeatIntervalInMinutes
  [SchedulePatternStartDate <Int64?>]: start date of schedule in epoch format
  [SchedulePatternStartTime <Int64?>]: start time of schedule in seconds
  [SchedulePatternWeekOfMonth <String>]: Specific week of a month
  [SchedulePatternWeeklyDays <String[]>]: Days of the week for weekly frequency
  [TimezoneId <Int64?>]: 
  [TimezoneName <String>]: 
  [VMOperationType <String>]: Type of DR operation (only applicable for Failover groups)

BODY <IUpdateServerPlan>: .
  [AllowPlanOverride <Boolean?>]: Flag to enable overriding of plan. Once enabled, cannot be disabled.
  [BackupContentBackupSystemState <Boolean?>]: Do you want to back up the system state? Applicable only for Windows
  [BackupContentBackupSystemStateOnlyWithFullBackup <Boolean?>]: Do you want to back up system state only with full backup? Applicable only if the value of backupSystemState is true
  [BackupContentForceUpdateProperties <Boolean?>]: Do you want to sync properties on associated subclients even if properties are overriden at subclient level?
  [BackupContentMacExcludedPaths <String[]>]: Paths to exclude for Mac
  [BackupContentMacFilterToExcludePaths <String[]>]: Paths that are exception to excluded paths for Mac
  [BackupContentMacIncludedPaths <String[]>]: Paths to include for Mac
  [BackupContentUnixExcludedPaths <String[]>]: Paths to exclude for UNIX
  [BackupContentUnixFilterToExcludePaths <String[]>]: Paths that are exception to excluded paths for Unix
  [BackupContentUnixIncludedPaths <String[]>]: Paths to include for UNIX
  [BackupContentUseVssForSystemState <Boolean?>]: Do you want to back up system state with VSS? Applicable only if the value of backupSystemState is true
  [BackupContentWindowsExcludedPaths <String[]>]: Paths to exclude for Windows
  [BackupContentWindowsFilterToExcludePaths <String[]>]: Paths that are exception to excluded paths for Windows
  [BackupContentWindowsIncludedPaths <String[]>]: Paths to include for Windows
  [BackupCopyFrequency <Int64?>]: Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
  [BackupCopyFrequencyDayOfMonth <Int64?>]: Day on which to run the schedule, applicable for monthly, yearly
  [BackupCopyFrequencyDayOfWeek <String>]: 
  [BackupCopyFrequencyMonthOfYear <String>]: 
  [BackupCopyFrequencyScheduleFrequencyType <String>]: schedule frequency type
  [BackupCopyFrequencyStartTime <Int64?>]: start time of schedule in seconds for daily, weekly, monthly, yearly frequency
  [BackupCopyFrequencyWeekOfMonth <String>]: Specific week of a month
  [BackupCopyFrequencyWeeklyDays <String[]>]: Days of the week for weekly frequency
  [BackupDestinationIds <Int64[]>]: Primary Backup Destination Ids (which were created before plan creation).
  [BackupFrequencyOperationType <String>]: Operation type for the list
  [BackupFrequencySchedules <IPlanSchedule[]>]: 
    BackupType <String>: Schedule Backup level
    SchedulePatternScheduleFrequencyType <String>: schedule frequency type
    [ForDatabasesOnly <Boolean?>]: Boolean to indicate if schedule is for database agents
    [IsRetentionBasedSyntheticFull <Boolean?>]: Boolean to indicate if synthetic full schedule is based on retention rules
    [PolicyId <Int64?>]: Schedule policy Id to which the schedule belongs
    [ScheduleId <Int64?>]: Id of the schedule if available, required for modifying, deleting schedule
    [ScheduleName <String>]: Name of the schedule, for modify
    [ScheduleOperation <String>]: Operation being performed on schedule
    [ScheduleOptionCommitFrequencyInHours <Int64?>]: Commit frequency in hours for disk cache backups from automatic schedules
    [ScheduleOptionDaysBetweenAutoConvert <Int64?>]: Number of days between auto conversion of backup level applicable for databases on incremental and differential schedules of server plan
    [ScheduleOptionJobRunningTimeInMins <Int64?>]: total job running time in minutes
    [ScheduleOptionLogFilesThreshold <Int64?>]: The min number of archived log files before a backup job should start
    [ScheduleOptionLogsDiskUtilizationPercent <Int64?>]: The min log destination disk threshold percentage
    [ScheduleOptionMinBackupIntervalInMins <Int64?>]: The min number of mins to check for file activity on automatic schedule.
    [ScheduleOptionO365ItemSelectionOption <String>]: item backup option for O365 V2 backup jobs
    [ScheduleOptionUseDiskCacheForLogBackups <Boolean?>]: Used to enable disk caching feature on databases for automatic schedules on server plan
    [SchedulePatternDayOfMonth <Int64?>]: Day on which to run the schedule, applicable for monthly, yearly
    [SchedulePatternDayOfWeek <String>]: 
    [SchedulePatternDaysBetweenSyntheticFulls <Int64?>]: No of days between two synthetic full jobs
    [SchedulePatternEndDate <Int64?>]: Schedule end date in epoch format
    [SchedulePatternExceptions <IScheduleRunException[]>]: Exceptions to when a schedule should not run, either in dates or week of month and days
      [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
      [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
      [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
    [SchedulePatternFrequency <Int64?>]: Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
    [SchedulePatternMaxBackupIntervalInMins <Int64?>]: The number of mins to force a backup on automatic schedule.
    [SchedulePatternMonthOfYear <String>]: 
    [SchedulePatternNoOfTimes <Int64?>]: The number of times you want the schedule to run.
    [SchedulePatternRepeatIntervalInMinutes <Int64?>]: How often in minutes in a day the schedule runs, applicable for daily, weekly, monthly and yearly frequency types.
    [SchedulePatternRepeatUntilTime <Int64?>]: Until what time to repeat the schedule in a day, requires repeatIntervalInMinutes
    [SchedulePatternStartDate <Int64?>]: start date of schedule in epoch format
    [SchedulePatternStartTime <Int64?>]: start time of schedule in seconds
    [SchedulePatternWeekOfMonth <String>]: Specific week of a month
    [SchedulePatternWeeklyDays <String[]>]: Days of the week for weekly frequency
    [TimezoneId <Int64?>]: 
    [TimezoneName <String>]: 
    [VMOperationType <String>]: Type of DR operation (only applicable for Failover groups)
  [DatabaseOptionCommitFrequencyInHours <Int64?>]: Commit frequency in hours
  [DatabaseOptionLogBackupRpoMins <Int64?>]: Log backup RPO in minutes
  [DatabaseOptionRunFullBackupEvery <Int64?>]: Full backup frequency in days
  [DatabaseOptionUseDiskCacheForLogBackups <Boolean?>]: Use disk cache for log backups
  [FileSearchEnabled <Boolean?>]: Flag for enabling indexing
  [FileSearchErrors <IPlanFileSearchSetupError[]>]: File search was enabled on plan but failed to process some of the storage pool(s) with these errors
    [ErrorCode <Int64?>]: 
    [ErrorMessage <String>]: Tells about the error occured during file search setup for given storage pool
    [StorageId <Int64?>]: 
    [StorageName <String>]: 
  [FileSearchStatus <String>]: Type of indexing status.
  [FileSearchStatusMessage <String>]: Tells what is happening behind the scene, so that user can knows why indexing is not enabled or if its in progress
  [FilesystemAddon <Boolean?>]: flag to enable backup content association for applicable file system workload.
  [MacNumberOfDataReaderCount <Int64?>]: Number of data readers.
  [MacNumberOfDataReaderUseOptimal <Boolean?>]: Set optimal number of data readers. if it is set to true, count will be ignored.
  [NewName <String>]: New plan name to update
  [OverrideInheritSettingBackupContent <Boolean?>]: Flag to specify if parent or derived plan backupContent should be used when inherit mode is optional. True - derived, False - Base.
  [OverrideInheritSettingBackupDestination <Boolean?>]: Flag to specify if parent or derived plan backupDestination should be used when inherit mode is optional. True - derived, False - Base.
  [OverrideInheritSettingRpo <Boolean?>]: Flag to specify if parent or derived plan rpo should be used when inherit mode is optional. True - derived, False - Base.
  [OverrideRestrictionBackupContent <String>]: 
  [OverrideRestrictionRpo <String>]: 
  [OverrideRestrictionStoragePool <String>]: 
  [RegionToConfigureId <Int64?>]: 
  [RegionToConfigureName <String>]: 
  [RpoBackupWindow <IDayAndTime[]>]: Backup window for incremental backup
    [DayOfWeek <String[]>]: 
    [EndTime <Int64?>]: Time in seconds since the beginning of the day
    [StartTime <Int64?>]: Time in seconds since the beginning of the day
  [RpoFullBackupWindow <IDayAndTime[]>]: Backup window for full backup
  [SettingEnableAdvancedView <Boolean?>]: Setting to suggest plan has some advanced settings present. Setting is OEM specific and not applicable for all cases.
  [SlaEnableAfterDelay <Int64?>]: Time provided in Unix format. Give 0 to reset any existing delay.
  [SlaExcludeFromSla <Boolean?>]: Flag to set to exclude plan from SLA
  [SlaExclusionReason <String>]: Reason for exclusion from SLA
  [SlaLogSlaMinutes <Int64?>]: Database log SLA period in Minutes
  [SlaPeriod <Int64?>]: SLA Period in Days
  [SlaUseSystemDefaultSla <Boolean?>]: Flag to set to use System Default Service Level Agreement
  [SnapshotOptionBackupCopyRpoMins <Int64?>]: Backup copy RPO in minutes
  [SnapshotOptionEnableBackupCopy <Boolean?>]: Flag to enable backup copy
  [UnixNumberOfDataReaderCount <Int64?>]: Number of data readers.
  [UnixNumberOfDataReaderUseOptimal <Boolean?>]: Set optimal number of data readers. if it is set to true, count will be ignored.
  [WindowNumberOfDataReaderCount <Int64?>]: Number of data readers.
  [WindowNumberOfDataReaderUseOptimal <Boolean?>]: Set optimal number of data readers. if it is set to true, count will be ignored.
  [WorkloadGroupTypes <String[]>]: 
  [WorkloadSolutions <IIdName[]>]: 
    [Id <Int64?>]: 
    [Name <String>]: 
  [WorkloadTypes <IIdName[]>]: 

FILESEARCHERRORS <IPlanFileSearchSetupError[]>: File search was enabled on plan but failed to process some of the storage pool(s) with these errors
  [ErrorCode <Int64?>]: 
  [ErrorMessage <String>]: Tells about the error occured during file search setup for given storage pool
  [StorageId <Int64?>]: 
  [StorageName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

RPOBACKUPWINDOW <IDayAndTime[]>: Backup window for incremental backup
  [DayOfWeek <String[]>]: 
  [EndTime <Int64?>]: Time in seconds since the beginning of the day
  [StartTime <Int64?>]: Time in seconds since the beginning of the day

RPOFULLBACKUPWINDOW <IDayAndTime[]>: Backup window for full backup
  [DayOfWeek <String[]>]: 
  [EndTime <Int64?>]: Time in seconds since the beginning of the day
  [StartTime <Int64?>]: Time in seconds since the beginning of the day

WORKLOADSOLUTIONS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 

WORKLOADTYPES <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyplan
#>
function Invoke-CVModifyPlan {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to update
    ${PlanId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateServerPlan]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to enable overriding of plan.
    # Once enabled, cannot be disabled.
    ${AllowPlanOverride},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Do you want to back up the system state Applicable only for Windows
    ${BackupContentBackupSystemState},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Do you want to back up system state only with full backup Applicable only if the value of backupSystemState is true
    ${BackupContentBackupSystemStateOnlyWithFullBackup},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Do you want to sync properties on associated subclients even if properties are overriden at subclient level
    ${BackupContentForceUpdateProperties},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for Mac
    ${BackupContentMacExcludedPaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths that are exception to excluded paths for Mac
    ${BackupContentMacFilterToExcludePaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for Mac
    ${BackupContentMacIncludedPaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for UNIX
    ${BackupContentUnixExcludedPaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths that are exception to excluded paths for Unix
    ${BackupContentUnixFilterToExcludePaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for UNIX
    ${BackupContentUnixIncludedPaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Do you want to back up system state with VSS Applicable only if the value of backupSystemState is true
    ${BackupContentUseVssForSystemState},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for Windows
    ${BackupContentWindowsExcludedPaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths that are exception to excluded paths for Windows
    ${BackupContentWindowsFilterToExcludePaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for Windows
    ${BackupContentWindowsIncludedPaths},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Frequency of the schedule based on schedule frequency type eg.
    # for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days.
    # for Monthly 2 is it repeats every 2 months
    ${BackupCopyFrequency},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Day on which to run the schedule, applicable for monthly, yearly
    ${BackupCopyFrequencyDayOfMonth},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${BackupCopyFrequencyDayOfWeek},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${BackupCopyFrequencyMonthOfYear},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # schedule frequency type
    ${BackupCopyFrequencyScheduleFrequencyType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # start time of schedule in seconds for daily, weekly, monthly, yearly frequency
    ${BackupCopyFrequencyStartTime},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specific week of a month
    ${BackupCopyFrequencyWeekOfMonth},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Days of the week for weekly frequency
    ${BackupCopyFrequencyWeeklyDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64[]]
    # Primary Backup Destination Ids (which were created before plan creation).
    ${BackupDestinationIds},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Operation type for the list
    ${BackupFrequencyOperationType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanSchedule[]]
    # .
    # To construct, see NOTES section for BACKUPFREQUENCYSCHEDULES properties and create a hash table.
    ${BackupFrequencySchedules},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Commit frequency in hours
    ${DatabaseOptionCommitFrequencyInHours},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Log backup RPO in minutes
    ${DatabaseOptionLogBackupRpoMins},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Full backup frequency in days
    ${DatabaseOptionRunFullBackupEvery},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Use disk cache for log backups
    ${DatabaseOptionUseDiskCacheForLogBackups},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag for enabling indexing
    ${FileSearchEnabled},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanFileSearchSetupError[]]
    # File search was enabled on plan but failed to process some of the storage pool(s) with these errors
    # To construct, see NOTES section for FILESEARCHERRORS properties and create a hash table.
    ${FileSearchErrors},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Type of indexing status.
    ${FileSearchStatus},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Tells what is happening behind the scene, so that user can knows why indexing is not enabled or if its in progress
    ${FileSearchStatusMessage},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # flag to enable backup content association for applicable file system workload.
    ${FilesystemAddon},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of data readers.
    ${MacNumberOfDataReaderCount},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Set optimal number of data readers.
    # if it is set to true, count will be ignored.
    ${MacNumberOfDataReaderUseOptimal},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # New plan name to update
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to specify if parent or derived plan backupContent should be used when inherit mode is optional.
    # True - derived, False - Base.
    ${OverrideInheritSettingBackupContent},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to specify if parent or derived plan backupDestination should be used when inherit mode is optional.
    # True - derived, False - Base.
    ${OverrideInheritSettingBackupDestination},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to specify if parent or derived plan rpo should be used when inherit mode is optional.
    # True - derived, False - Base.
    ${OverrideInheritSettingRpo},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionBackupContent},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionRpo},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionStoragePool},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RegionToConfigureId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RegionToConfigureName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDayAndTime[]]
    # Backup window for incremental backup
    # To construct, see NOTES section for RPOBACKUPWINDOW properties and create a hash table.
    ${RpoBackupWindow},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDayAndTime[]]
    # Backup window for full backup
    # To construct, see NOTES section for RPOFULLBACKUPWINDOW properties and create a hash table.
    ${RpoFullBackupWindow},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Setting to suggest plan has some advanced settings present.
    # Setting is OEM specific and not applicable for all cases.
    ${SettingEnableAdvancedView},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Time provided in Unix format.
    # Give 0 to reset any existing delay.
    ${SlaEnableAfterDelay},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to set to exclude plan from SLA
    ${SlaExcludeFromSla},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Reason for exclusion from SLA
    ${SlaExclusionReason},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Database log SLA period in Minutes
    ${SlaLogSlaMinutes},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # SLA Period in Days
    ${SlaPeriod},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to set to use System Default Service Level Agreement
    ${SlaUseSystemDefaultSla},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Backup copy RPO in minutes
    ${SnapshotOptionBackupCopyRpoMins},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to enable backup copy
    ${SnapshotOptionEnableBackupCopy},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of data readers.
    ${UnixNumberOfDataReaderCount},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Set optimal number of data readers.
    # if it is set to true, count will be ignored.
    ${UnixNumberOfDataReaderUseOptimal},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of data readers.
    ${WindowNumberOfDataReaderCount},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Set optimal number of data readers.
    # if it is set to true, count will be ignored.
    ${WindowNumberOfDataReaderUseOptimal},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # .
    ${WorkloadGroupTypes},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for WORKLOADSOLUTIONS properties and create a hash table.
    ${WorkloadSolutions},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for WORKLOADTYPES properties and create a hash table.
    ${WorkloadTypes},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyPlan_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyPlan_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyPlan_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyPlan_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify the properties of an existing replication group
.Description
Modify the properties of an existing replication group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateReplicationGroup
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ADVANCEDOPTIONSCRIPT <IReplicationGroupScript>: Pre/post failover and failback scripts at group level
  [PostFailbackGuestCredentialsCredentialsName <String>]: username to access the network path
  [PostFailbackGuestCredentialsCredentialsPassword <String>]: password to access the network path
  [PostFailbackGuestCredentialsSavedCredentialsId <Int64?>]: 
  [PostFailbackGuestCredentialsSavedCredentialsName <String>]: 
  [PostFailbackGuid <String>]: Unique script identifier string
  [PostFailbackOSType <String>]: OS types
  [PostFailbackPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [PostFailbackReset <Boolean?>]: On set to true, resets the script to empty
  [PostFailbackScriptCredentialsCredentialsName <String>]: username to access the network path
  [PostFailbackScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [PostFailbackScriptCredentialsSavedCredentialsId <Int64?>]: 
  [PostFailbackScriptCredentialsSavedCredentialsName <String>]: 
  [PostFailbackType <String>]: The type of path being used for DR operation script
  [PostFailoverGuestCredentialsCredentialsName <String>]: username to access the network path
  [PostFailoverGuestCredentialsCredentialsPassword <String>]: password to access the network path
  [PostFailoverGuestCredentialsSavedCredentialsId <Int64?>]: 
  [PostFailoverGuestCredentialsSavedCredentialsName <String>]: 
  [PostFailoverGuid <String>]: Unique script identifier string
  [PostFailoverOSType <String>]: OS types
  [PostFailoverPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [PostFailoverReset <Boolean?>]: On set to true, resets the script to empty
  [PostFailoverScriptCredentialsCredentialsName <String>]: username to access the network path
  [PostFailoverScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [PostFailoverScriptCredentialsSavedCredentialsId <Int64?>]: 
  [PostFailoverScriptCredentialsSavedCredentialsName <String>]: 
  [PostFailoverType <String>]: The type of path being used for DR operation script
  [PreFailbackGuestCredentialsCredentialsName <String>]: username to access the network path
  [PreFailbackGuestCredentialsCredentialsPassword <String>]: password to access the network path
  [PreFailbackGuestCredentialsSavedCredentialsId <Int64?>]: 
  [PreFailbackGuestCredentialsSavedCredentialsName <String>]: 
  [PreFailbackGuid <String>]: Unique script identifier string
  [PreFailbackOSType <String>]: OS types
  [PreFailbackPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [PreFailbackReset <Boolean?>]: On set to true, resets the script to empty
  [PreFailbackScriptCredentialsCredentialsName <String>]: username to access the network path
  [PreFailbackScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [PreFailbackScriptCredentialsSavedCredentialsId <Int64?>]: 
  [PreFailbackScriptCredentialsSavedCredentialsName <String>]: 
  [PreFailbackType <String>]: The type of path being used for DR operation script
  [PreFailoverGuestCredentialsCredentialsName <String>]: username to access the network path
  [PreFailoverGuestCredentialsCredentialsPassword <String>]: password to access the network path
  [PreFailoverGuestCredentialsSavedCredentialsId <Int64?>]: 
  [PreFailoverGuestCredentialsSavedCredentialsName <String>]: 
  [PreFailoverGuid <String>]: Unique script identifier string
  [PreFailoverOSType <String>]: OS types
  [PreFailoverPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [PreFailoverReset <Boolean?>]: On set to true, resets the script to empty
  [PreFailoverScriptCredentialsCredentialsName <String>]: username to access the network path
  [PreFailoverScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [PreFailoverScriptCredentialsSavedCredentialsId <Int64?>]: 
  [PreFailoverScriptCredentialsSavedCredentialsName <String>]: 
  [PreFailoverType <String>]: The type of path being used for DR operation script

BODY <IUpdateReplicationGroup>: UpdateReplicationGroupReq
  [AdvancedOptionContinueOnFailure <Boolean?>]: Set to true to continue to the next priority machines on failure.
  [AdvancedOptionDelayBetweenPriorityMachines <Int64?>]: The delay between machines in different priorities. Mention in minutes
  [AdvancedOptionScript <IReplicationGroupScript>]: Pre/post failover and failback scripts at group level
    [PostFailbackGuestCredentialsCredentialsName <String>]: username to access the network path
    [PostFailbackGuestCredentialsCredentialsPassword <String>]: password to access the network path
    [PostFailbackGuestCredentialsSavedCredentialsId <Int64?>]: 
    [PostFailbackGuestCredentialsSavedCredentialsName <String>]: 
    [PostFailbackGuid <String>]: Unique script identifier string
    [PostFailbackOSType <String>]: OS types
    [PostFailbackPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [PostFailbackReset <Boolean?>]: On set to true, resets the script to empty
    [PostFailbackScriptCredentialsCredentialsName <String>]: username to access the network path
    [PostFailbackScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [PostFailbackScriptCredentialsSavedCredentialsId <Int64?>]: 
    [PostFailbackScriptCredentialsSavedCredentialsName <String>]: 
    [PostFailbackType <String>]: The type of path being used for DR operation script
    [PostFailoverGuestCredentialsCredentialsName <String>]: username to access the network path
    [PostFailoverGuestCredentialsCredentialsPassword <String>]: password to access the network path
    [PostFailoverGuestCredentialsSavedCredentialsId <Int64?>]: 
    [PostFailoverGuestCredentialsSavedCredentialsName <String>]: 
    [PostFailoverGuid <String>]: Unique script identifier string
    [PostFailoverOSType <String>]: OS types
    [PostFailoverPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [PostFailoverReset <Boolean?>]: On set to true, resets the script to empty
    [PostFailoverScriptCredentialsCredentialsName <String>]: username to access the network path
    [PostFailoverScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [PostFailoverScriptCredentialsSavedCredentialsId <Int64?>]: 
    [PostFailoverScriptCredentialsSavedCredentialsName <String>]: 
    [PostFailoverType <String>]: The type of path being used for DR operation script
    [PreFailbackGuestCredentialsCredentialsName <String>]: username to access the network path
    [PreFailbackGuestCredentialsCredentialsPassword <String>]: password to access the network path
    [PreFailbackGuestCredentialsSavedCredentialsId <Int64?>]: 
    [PreFailbackGuestCredentialsSavedCredentialsName <String>]: 
    [PreFailbackGuid <String>]: Unique script identifier string
    [PreFailbackOSType <String>]: OS types
    [PreFailbackPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [PreFailbackReset <Boolean?>]: On set to true, resets the script to empty
    [PreFailbackScriptCredentialsCredentialsName <String>]: username to access the network path
    [PreFailbackScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [PreFailbackScriptCredentialsSavedCredentialsId <Int64?>]: 
    [PreFailbackScriptCredentialsSavedCredentialsName <String>]: 
    [PreFailbackType <String>]: The type of path being used for DR operation script
    [PreFailoverGuestCredentialsCredentialsName <String>]: username to access the network path
    [PreFailoverGuestCredentialsCredentialsPassword <String>]: password to access the network path
    [PreFailoverGuestCredentialsSavedCredentialsId <Int64?>]: 
    [PreFailoverGuestCredentialsSavedCredentialsName <String>]: 
    [PreFailoverGuid <String>]: Unique script identifier string
    [PreFailoverOSType <String>]: OS types
    [PreFailoverPath <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [PreFailoverReset <Boolean?>]: On set to true, resets the script to empty
    [PreFailoverScriptCredentialsCredentialsName <String>]: username to access the network path
    [PreFailoverScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [PreFailoverScriptCredentialsSavedCredentialsId <Int64?>]: 
    [PreFailoverScriptCredentialsSavedCredentialsName <String>]: 
    [PreFailoverType <String>]: The type of path being used for DR operation script
  [Disable <Boolean?>]: Used to disable a replication group
  [Enable <Boolean?>]: Used to enable a replication group
  [NewName <String>]: Used to change the name of a replication group

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyreplicationgroup
#>
function Invoke-CVModifyReplicationGroup {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ReplicationGroupId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateReplicationGroup]
    # UpdateReplicationGroupReq
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Set to true to continue to the next priority machines on failure.
    ${AdvancedOptionContinueOnFailure},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The delay between machines in different priorities.
    # Mention in minutes
    ${AdvancedOptionDelayBetweenPriorityMachines},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IReplicationGroupScript]
    # Pre/post failover and failback scripts at group level
    # To construct, see NOTES section for ADVANCEDOPTIONSCRIPT properties and create a hash table.
    ${AdvancedOptionScript},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Used to disable a replication group
    ${Disable},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Used to enable a replication group
    ${Enable},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Used to change the name of a replication group
    ${NewName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyReplicationGroup_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyReplicationGroup_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyReplicationGroup_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyReplicationGroup_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify the properties of an existing role
.Description
Modify the properties of an existing role
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateRole
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateRole>: .
  [Enabled <Boolean?>]: Used to determine if the role is enabled or disabled.
  [NewName <String>]: new name of the role
  [PermissionList <IPermissions[]>]: Used to update the list of permissions associated with the role.
    [CategoryId <Int64?>]: 
    [CategoryName <String>]: 
    [PermissionId <Int64?>]: 
    [PermissionName <String>]: 
  [PermissionOperationType <String>]: Type of operation to be performed on the permissionList. Default is OVERWRITE.
  [Security <IUpdateSecurityAssoc[]>]: Used to update the security association for the role
    [RoleId <Int64?>]: 
    [RoleName <String>]: 
    [UserGroupId <Int64?>]: 
    [UserGroupName <String>]: 
    [UserId <Int64?>]: 
    [UserName <String>]: 
  [VisibleToAll <Boolean?>]: Determines if the role is visible to everyone.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

PERMISSIONLIST <IPermissions[]>: Used to update the list of permissions associated with the role.
  [CategoryId <Int64?>]: 
  [CategoryName <String>]: 
  [PermissionId <Int64?>]: 
  [PermissionName <String>]: 

SECURITY <IUpdateSecurityAssoc[]>: Used to update the security association for the role
  [RoleId <Int64?>]: 
  [RoleName <String>]: 
  [UserGroupId <Int64?>]: 
  [UserGroupName <String>]: 
  [UserId <Int64?>]: 
  [UserName <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyrole
#>
function Invoke-CVModifyRole {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Role Id
    ${RoleId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateRole]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Used to determine if the role is enabled or disabled.
    ${Enabled},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # new name of the role
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPermissions[]]
    # Used to update the list of permissions associated with the role.
    # To construct, see NOTES section for PERMISSIONLIST properties and create a hash table.
    ${PermissionList},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Type of operation to be performed on the permissionList.
    # Default is OVERWRITE.
    ${PermissionOperationType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateSecurityAssoc[]]
    # Used to update the security association for the role
    # To construct, see NOTES section for SECURITY properties and create a hash table.
    ${Security},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Determines if the role is visible to everyone.
    ${VisibleToAll},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyRole_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyRole_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyRole_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyRole_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to update pattern for schedule in schedule policy
.Description
API to update pattern for schedule in schedule policy
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IPlanPattern
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IPlanPattern>: If updating pattern, the value which needs to be retained also needs to be provided along with the updated value
  [DailyFrequency <Int64?>]: Frequency in days
  [HourlyFrequency <Int64?>]: Frequency in hours per day. Precedence is hourly, daily, weekly and monthly, in that order.
  [MinuteFrequency <Int64?>]: Frequency in minutes
  [MonthlyFrequency <Int64?>]: Frequency in months. Only for incremental backup frequency.
  [MonthlyFrequencyDayOfMonth <Int64?>]: Only available for incremental backup frequency
  [MonthlyFrequencyDayOfWeek <String>]: 
  [MonthlyFrequencyWeekOfMonth <String>]: Specific week of a month
  [StartTime <Int64?>]: Time in seconds from the beginning of the day when the backup starts. This is a mandatory field for daily, weekly, monthly, yearly frequencies
  [WeeklyFrequency <Int64?>]: Frequency in weeks. Only for incremental backup frequency.
  [WeeklyFrequencyDays <String[]>]: Days of the week for weekly frequency
  [YearlyFrequencyDayOfMonth <Int64?>]: Only available for incremental backup frequency
  [YearlyFrequencyDayOfWeek <String>]: 
  [YearlyFrequencyMonthOfYear <String>]: 
  [YearlyFrequencyWeekOfMonth <String>]: Specific week of a month

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyschedulepattern
#>
function Invoke-CVModifySchedulePattern {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ScheduleId},

    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${SchedulePolicyId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanPattern]
    # If updating pattern, the value which needs to be retained also needs to be provided along with the updated value
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Frequency in days
    ${DailyFrequency},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Frequency in hours per day.
    # Precedence is hourly, daily, weekly and monthly, in that order.
    ${HourlyFrequency},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Frequency in minutes
    ${MinuteFrequency},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Frequency in months.
    # Only for incremental backup frequency.
    ${MonthlyFrequency},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Only available for incremental backup frequency
    ${MonthlyFrequencyDayOfMonth},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${MonthlyFrequencyDayOfWeek},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specific week of a month
    ${MonthlyFrequencyWeekOfMonth},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Time in seconds from the beginning of the day when the backup starts.
    # This is a mandatory field for daily, weekly, monthly, yearly frequencies
    ${StartTime},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Frequency in weeks.
    # Only for incremental backup frequency.
    ${WeeklyFrequency},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Days of the week for weekly frequency
    ${WeeklyFrequencyDays},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Only available for incremental backup frequency
    ${YearlyFrequencyDayOfMonth},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${YearlyFrequencyDayOfWeek},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${YearlyFrequencyMonthOfYear},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specific week of a month
    ${YearlyFrequencyWeekOfMonth},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifySchedulePattern_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifySchedulePattern_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifySchedulePattern_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifySchedulePattern_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify software cache details
.Description
Modify software cache details
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IModifySoftwareCacheDetails
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ASSOCIATIONS <IModifySoftwareCacheAssociations[]>: .
  OpType <String>: Basic operation types
  [Id <Int64?>]: Id of server or server group
  [Name <String>]: Name of server or server group
  [Type <String>]: ServerOrServerGroupTypes

BODY <IModifySoftwareCacheDetails>: Request to update software cache properties like associations, cache directory or enabled for a specific server.
  [Associations <IModifySoftwareCacheAssociations[]>]: 
    OpType <String>: Basic operation types
    [Id <Int64?>]: Id of server or server group
    [Name <String>]: Name of server or server group
    [Type <String>]: ServerOrServerGroupTypes
  [CacheDirectory <String>]: The software cache directory path where the media will be located
  [Enabled <Boolean?>]: Whether the software cache is enabled or not

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifysoftwarecachedetail
#>
function Invoke-CVModifySoftwareCacheDetail {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Software cache client id
    ${ClientId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IModifySoftwareCacheDetails]
    # Request to update software cache properties like associations, cache directory or enabled for a specific server.
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IModifySoftwareCacheAssociations[]]
    # .
    # To construct, see NOTES section for ASSOCIATIONS properties and create a hash table.
    ${Associations},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The software cache directory path where the media will be located
    ${CacheDirectory},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Whether the software cache is enabled or not
    ${Enabled},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifySoftwareCacheDetail_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifySoftwareCacheDetail_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifySoftwareCacheDetail_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifySoftwareCacheDetail_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Add, Modify and Delete notes for triggered alerts
.Description
Add, Modify and Delete notes for triggered alerts
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateTriggeredAlertsNotes
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateTriggeredAlertsNotes>: UpdateTriggeredAlertsNotes
  [Notes <String>]: Notes that you want to add to the triggered alerts. Leave it empty if you want to delete the alert

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifytriggeredalertnote
#>
function Invoke-CVModifyTriggeredAlertNote {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateTriggeredAlertsNotes]
    # UpdateTriggeredAlertsNotes
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Notes that you want to add to the triggered alerts.
    # Leave it empty if you want to delete the alert
    ${Notes},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyTriggeredAlertNote_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyTriggeredAlertNote_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyTriggeredAlertNote_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyTriggeredAlertNote_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify the properties of an existing user-group
.Description
Modify the properties of an existing user-group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateUserGroup
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ASSOCIATEDEXTERNALGROUPS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 

ASSOCIATEDLOCALGROUPS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 

BODY <IUpdateUserGroup>: .
  [AllowMultipleCompanyMembers <Boolean?>]: This property can be used to allow addition of users/groups from child companies. Only applicable for commcell and reseller company group.
  [AssociatedExternalGroups <IIdName[]>]: 
    [Id <Int64?>]: 
    [Name <String>]: 
  [AssociatedLocalGroups <IIdName[]>]: 
  [AzureGuid <String>]: Azure Object ID used to link this user group to Azure AD group and manage group membership of the user during SAML login
  [ConsoleTypeOperationType <String>]: 
  [DoNotInheritRestrictConsoleTypes <Boolean?>]: Option to not inherit the RestrictConsoleTypes from the parent. By default the value is false, parent RestrictConsoleTypes will be inherited.
  [EnableLocalAuthentication <String>]: Allows two-factor authentication to be enabled for the specific types of usergroups. it can be turned on or off based on user preferences. There will be usergroups that will not have this option.
  [EnableTwoFactorAuthentication <String>]: Allows two-factor authentication to be enabled for the specific types of usergroups. it can be turned on or off based on user preferences. There will be usergroups that will not have this option.
  [Enabled <Boolean?>]: allows the enabling/disabling of the user group.
  [EnforceFsQuota <Boolean?>]: determines if a data limit will be set for the user group.
  [ExternalUserGroupsOperationType <String>]: Allows adding, deleting or overwriting associated external user groups of a user group. Default is adding associated external user groups
  [LaptopAdmins <Boolean?>]: When set to true, users in this group cannot activate or be set as server owner
  [LaptopPlanId <Int64?>]: 
  [LaptopPlanName <String>]: 
  [LocalUserGroupsOperationType <String>]: Allows adding, deleting or overwriting associated local user groups of a user group. Default is adding associated local user groups
  [NewDescription <String>]: gives a new description to the user group.
  [NewName <String>]: gives a new name to the user group.
  [PlanOperationType <String>]: determines if an existing user has to be added to the user group or removed from the user group
  [QuotaLimitInGb <Int64?>]: if enforceFSquota is enabled, the quota limit can be provided in GBs
  [RestrictConsoleType <String[]>]: 
  [UserOperationType <String>]: determines if an existing user has to be added to the user group or removed from the user group
  [Users <IIdName[]>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

USERS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyusergroup
#>
function Invoke-CVModifyUserGroup {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the user-group to update
    ${UserGroupId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateUserGroup]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # This property can be used to allow addition of users/groups from child companies.
    # Only applicable for commcell and reseller company group.
    ${AllowMultipleCompanyMembers},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for ASSOCIATEDEXTERNALGROUPS properties and create a hash table.
    ${AssociatedExternalGroups},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for ASSOCIATEDLOCALGROUPS properties and create a hash table.
    ${AssociatedLocalGroups},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure Object ID used to link this user group to Azure AD group and manage group membership of the user during SAML login
    ${AzureGuid},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ConsoleTypeOperationType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Option to not inherit the RestrictConsoleTypes from the parent.
    # By default the value is false, parent RestrictConsoleTypes will be inherited.
    ${DoNotInheritRestrictConsoleTypes},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Allows two-factor authentication to be enabled for the specific types of usergroups.
    # it can be turned on or off based on user preferences.
    # There will be usergroups that will not have this option.
    ${EnableLocalAuthentication},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Allows two-factor authentication to be enabled for the specific types of usergroups.
    # it can be turned on or off based on user preferences.
    # There will be usergroups that will not have this option.
    ${EnableTwoFactorAuthentication},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # allows the enabling/disabling of the user group.
    ${Enabled},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # determines if a data limit will be set for the user group.
    ${EnforceFsQuota},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Allows adding, deleting or overwriting associated external user groups of a user group.
    # Default is adding associated external user groups
    ${ExternalUserGroupsOperationType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # When set to true, users in this group cannot activate or be set as server owner
    ${LaptopAdmins},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${LaptopPlanId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${LaptopPlanName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Allows adding, deleting or overwriting associated local user groups of a user group.
    # Default is adding associated local user groups
    ${LocalUserGroupsOperationType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # gives a new description to the user group.
    ${NewDescription},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # gives a new name to the user group.
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # determines if an existing user has to be added to the user group or removed from the user group
    ${PlanOperationType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # if enforceFSquota is enabled, the quota limit can be provided in GBs
    ${QuotaLimitInGb},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # .
    ${RestrictConsoleType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # determines if an existing user has to be added to the user group or removed from the user group
    ${UserOperationType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for USERS properties and create a hash table.
    ${Users},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyUserGroup_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyUserGroup_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyUserGroup_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyUserGroup_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to modify an existing user
.Description
Used to modify an existing user
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateUser
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateUser>: Used to update an existing user.
  [AuthenticationMethod <String>]: Change the current authentication method of user. SAML user association can be removed using this.
  [Email <String>]: Change email-id for existing user. This email-id can be used for logging-in.
  [Enabled <Boolean?>]: enable or disable the user.
  [FullName <String>]: Change name for existing user
  [NewName <String>]: Change user name for existing user. Username can be used for logging-in as an alternate to email-id if duplicate email-ids are present.
  [NewPassword <String>]: Change existing password for user. validationPassword must also be provided when changing password. Password should be in provided in Base64 format.
  [PlanId <Int64?>]: 
  [PlanName <String>]: 
  [UserGroupOperation <String>]: Allows adding to, overwriting and deleting existing user groups. default is adding to existing userGroups
  [UserGroups <IIdName[]>]: Provide a list of userGroups that the user should be a part of. Note that for external users, user groups cannot be modified.
    [Id <Int64?>]: 
    [Name <String>]: 
  [UserPrincipalName <String>]: Change User Principal Name(UPN) for existing user. This User Principal Name can be used for logging-in.
  [ValidationPassword <String>]: Provide the old password in Base64 format when updating the password. The new password has to be provided in the password tag.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

USERGROUPS <IIdName[]>: Provide a list of userGroups that the user should be a part of. Note that for external users, user groups cannot be modified.
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyuser
#>
function Invoke-CVModifyUser {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the User to update
    ${UserId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateUser]
    # Used to update an existing user.
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Change the current authentication method of user.
    # SAML user association can be removed using this.
    ${AuthenticationMethod},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Change email-id for existing user.
    # This email-id can be used for logging-in.
    ${Email},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # enable or disable the user.
    ${Enabled},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Change name for existing user
    ${FullName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Change user name for existing user.
    # Username can be used for logging-in as an alternate to email-id if duplicate email-ids are present.
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Change existing password for user.
    # validationPassword must also be provided when changing password.
    # Password should be in provided in Base64 format.
    ${NewPassword},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Allows adding to, overwriting and deleting existing user groups.
    # default is adding to existing userGroups
    ${UserGroupOperation},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Provide a list of userGroups that the user should be a part of.
    # Note that for external users, user groups cannot be modified.
    # To construct, see NOTES section for USERGROUPS properties and create a hash table.
    ${UserGroups},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Change User Principal Name(UPN) for existing user.
    # This User Principal Name can be used for logging-in.
    ${UserPrincipalName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Provide the old password in Base64 format when updating the password.
    # The new password has to be provided in the password tag.
    ${ValidationPassword},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyUser_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyUser_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyUser_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyUser_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify the properties of an existing Blackout Window
.Description
Modify the properties of an existing Blackout Window
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IV4UpdateBlackoutWindow
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IV4UpdateBlackoutWindow>: company-refers to company to which the blackout window is associated.Dates have to be provided in unix time format.
  [BackupOperations <String[]>]: Refers to backup types to include in the blackout window
  [BetweenDateEnd <Int64?>]: the blackout window is no longer in effect from this point on.
  [BetweenDateStart <Int64?>]: the blackout window comes into effect at this point.
  [CompanyId <Int64?>]: 
  [CompanyName <String>]: 
  [Days <String[]>]: Days of the week when the blackout window will be in effect.
  [DoNotSubmitJob <Boolean?>]: Allows or Denies submitting a job when the blackout window is in effect. If allowed, the job is submitted and resumed once the blackout window ends.
  [NewName <String>]: Refers to the newName given to the blackout Window.
  [Time <IStartEnd[]>]: Refers to the time between which the blackout window will be in effect. It has to be provided in seconds
    [End <Int64?>]: the blackout window is no longer in effect from this point on.
    [Start <Int64?>]: the blackout window comes into effect at this point.
  [Weeks <String[]>]: Refers to the weeks of the month that the blackout window will be in effect.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

TIME <IStartEnd[]>: Refers to the time between which the blackout window will be in effect. It has to be provided in seconds
  [End <Int64?>]: the blackout window is no longer in effect from this point on.
  [Start <Int64?>]: the blackout window comes into effect at this point.
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyv4blackoutwindow
#>
function Invoke-CVModifyV4BlackoutWindow {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Blackout Window to update
    ${BlackoutWindowId},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IV4UpdateBlackoutWindow]
    # company-refers to company to which the blackout window is associated.Dates have to be provided in unix time format.
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Refers to backup types to include in the blackout window
    ${BackupOperations},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # the blackout window is no longer in effect from this point on.
    ${BetweenDateEnd},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # the blackout window comes into effect at this point.
    ${BetweenDateStart},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${CompanyId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${CompanyName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Days of the week when the blackout window will be in effect.
    ${Days},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Allows or Denies submitting a job when the blackout window is in effect.
    # If allowed, the job is submitted and resumed once the blackout window ends.
    ${DoNotSubmitJob},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Refers to the newName given to the blackout Window.
    ${NewName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IStartEnd[]]
    # Refers to the time between which the blackout window will be in effect.
    # It has to be provided in seconds
    # To construct, see NOTES section for TIME properties and create a hash table.
    ${Time},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Refers to the weeks of the month that the blackout window will be in effect.
    ${Weeks},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyV4BlackoutWindow_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyV4BlackoutWindow_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyV4BlackoutWindow_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyV4BlackoutWindow_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify the properties of an existing virtual machine
.Description
Modify the properties of an existing virtual machine
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateVMProperties
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateVMProperties>: UpdateVMProperties
  [AuthKeyRestoreAuthOpType <Boolean?>]: The type of authorize for restore operation
  [AuthKeyRestoreExpirationTime <Int64?>]: The duration(in unix time) for which a user can continue browsing and restoring backup data without being prompted to enter the passkey, again.
  [AuthKeyRestorePassKey <String>]: The existing passkey for restricting backup restores.
  [PlanId <Int64?>]: 
  [PlanName <String>]: 
  [RequirePasskeyForRestoreConfirmPassKey <String>]: Confirm the new passkey for restricting backup restores.
  [RequirePasskeyForRestoreCurrentPassKey <String>]: The current passkey for restricting backup restores.
  [RequirePasskeyForRestoreNewPassKey <String>]: The new passkey for restricting backup restores.
  [RequirePasskeyForRestoreOperationType <String>]: The type of passkey operation
  [SecurityAssociations <IVMSecurityAssoc[]>]: 
    [RoleId <Int64?>]: 
    [RoleName <String>]: 
    [UseGroupCompanyId <Int64?>]: 
    [UseGroupCompanyName <String>]: 
    [UseGroupId <Int64?>]: 
    [UseGroupName <String>]: 
    [UserCompanyId <Int64?>]: 
    [UserCompanyName <String>]: 
    [UserId <Int64?>]: 
    [UserName <String>]: 
  [SecurityOwners <ISecurityOwnersAssoc[]>]: 
    [UserGroupId <Int64?>]: 
    [UserGroupName <String>]: 
    [UserId <Int64?>]: 
    [UserName <String>]: 
  [SecurityPermissions <IPermissionResp[]>]: 
    [CategoryId <Int64?>]: 
    [CategoryName <String>]: 
    [Exclude <Boolean?>]: Flag to specify if this is included permission or excluded permission.
    [PermissionId <Int64?>]: 
    [PermissionName <String>]: 
    [Type <String>]: Returns the type of association.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

SECURITYASSOCIATIONS <IVMSecurityAssoc[]>: .
  [RoleId <Int64?>]: 
  [RoleName <String>]: 
  [UseGroupCompanyId <Int64?>]: 
  [UseGroupCompanyName <String>]: 
  [UseGroupId <Int64?>]: 
  [UseGroupName <String>]: 
  [UserCompanyId <Int64?>]: 
  [UserCompanyName <String>]: 
  [UserId <Int64?>]: 
  [UserName <String>]: 

SECURITYOWNERS <ISecurityOwnersAssoc[]>: .
  [UserGroupId <Int64?>]: 
  [UserGroupName <String>]: 
  [UserId <Int64?>]: 
  [UserName <String>]: 

SECURITYPERMISSIONS <IPermissionResp[]>: .
  [CategoryId <Int64?>]: 
  [CategoryName <String>]: 
  [Exclude <Boolean?>]: Flag to specify if this is included permission or excluded permission.
  [PermissionId <Int64?>]: 
  [PermissionName <String>]: 
  [Type <String>]: Returns the type of association.
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmodifyvirtualmachine
#>
function Invoke-CVModifyVirtualMachine {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='ModifyExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Modify', Mandatory)]
    [Parameter(ParameterSetName='ModifyExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # The vmUUID can be obtained from GET /virtualMachines UUID property
    ${VMUuid},

    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Modify', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ModifyViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateVMProperties]
    # UpdateVMProperties
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # The type of authorize for restore operation
    ${AuthKeyRestoreAuthOpType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The duration(in unix time) for which a user can continue browsing and restoring backup data without being prompted to enter the passkey, again.
    ${AuthKeyRestoreExpirationTime},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The existing passkey for restricting backup restores.
    ${AuthKeyRestorePassKey},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanName},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Confirm the new passkey for restricting backup restores.
    ${RequirePasskeyForRestoreConfirmPassKey},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The current passkey for restricting backup restores.
    ${RequirePasskeyForRestoreCurrentPassKey},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The new passkey for restricting backup restores.
    ${RequirePasskeyForRestoreNewPassKey},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The type of passkey operation
    ${RequirePasskeyForRestoreOperationType},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVMSecurityAssoc[]]
    # .
    # To construct, see NOTES section for SECURITYASSOCIATIONS properties and create a hash table.
    ${SecurityAssociations},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISecurityOwnersAssoc[]]
    # .
    # To construct, see NOTES section for SECURITYOWNERS properties and create a hash table.
    ${SecurityOwners},

    [Parameter(ParameterSetName='ModifyExpanded')]
    [Parameter(ParameterSetName='ModifyViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPermissionResp[]]
    # .
    # To construct, see NOTES section for SECURITYPERMISSIONS properties and create a hash table.
    ${SecurityPermissions},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Modify = 'CommvaultPowershell.private\Invoke-CVModifyVirtualMachine_Modify';
            ModifyExpanded = 'CommvaultPowershell.private\Invoke-CVModifyVirtualMachine_ModifyExpanded';
            ModifyViaIdentity = 'CommvaultPowershell.private\Invoke-CVModifyVirtualMachine_ModifyViaIdentity';
            ModifyViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVModifyVirtualMachine_ModifyViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API for snap multi node unmount operation
.Description
API for snap multi node unmount operation
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ISnapNodeReq
.Outputs
Commvault.Powershell.Models.ISnapReconResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISnapNodeReq>: Request template for multi node unmount and instant clone delete
  [MountVolumeIds <Int64[]>]: Volume Ids of the Snaps to include for multi node unmount or instant clone delete
  [Volume <ISnapVolumes[]>]: Array of volumes to include for the operation
    SmVolumeId <Int64>: smVolumeId of the snap
    [CommCellId <Int64?>]: Commcell Id of the setup

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

VOLUME <ISnapVolumes[]>: Array of volumes to include for the operation
  SmVolumeId <Int64>: smVolumeId of the snap
  [CommCellId <Int64?>]: Commcell Id of the setup
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvmultinodeunmount
#>
function Invoke-CVMultiNodeUnmount {
[OutputType([Commvault.Powershell.Models.ISnapReconResp])]
[CmdletBinding(DefaultParameterSetName='MultiExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Multi', Mandatory)]
    [Parameter(ParameterSetName='MultiExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='MultiViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='MultiViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Multi', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='MultiViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapNodeReq]
    # Request template for multi node unmount and instant clone delete
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='MultiExpanded')]
    [Parameter(ParameterSetName='MultiViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64[]]
    # Volume Ids of the Snaps to include for multi node unmount or instant clone delete
    ${MountVolumeIds},

    [Parameter(ParameterSetName='MultiExpanded')]
    [Parameter(ParameterSetName='MultiViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapVolumes[]]
    # Array of volumes to include for the operation
    # To construct, see NOTES section for VOLUME properties and create a hash table.
    ${Volume},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Multi = 'CommvaultPowershell.private\Invoke-CVMultiNodeUnmount_Multi';
            MultiExpanded = 'CommvaultPowershell.private\Invoke-CVMultiNodeUnmount_MultiExpanded';
            MultiViaIdentity = 'CommvaultPowershell.private\Invoke-CVMultiNodeUnmount_MultiViaIdentity';
            MultiViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVMultiNodeUnmount_MultiViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Pin triggered alerts
.Description
Pin triggered alerts
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvpintriggeredalert
#>
function Invoke-CVPinTriggeredAlert {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Pin', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Pin', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(ParameterSetName='PinViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Pin = 'CommvaultPowershell.private\Invoke-CVPinTriggeredAlert_Pin';
            PinViaIdentity = 'CommvaultPowershell.private\Invoke-CVPinTriggeredAlert_PinViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to create or update synthetic full schedule on plan based on retention settings
.Description
Used to create or update synthetic full schedule on plan based on retention settings
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvplanserver
#>
function Invoke-CVPlanServer {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Plan', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Plan', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to update
    ${PlanId},

    [Parameter(ParameterSetName='PlanViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Plan = 'CommvaultPowershell.private\Invoke-CVPlanServer_Plan';
            PlanViaIdentity = 'CommvaultPowershell.private\Invoke-CVPlanServer_PlanViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to preview application content
.Description
API to preview application content
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IKubernetesApplicationGroupPreviewReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IKubernetesApplicationGroupPreviewResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IKubernetesApplicationGroupPreviewReq>: Application Group Preview Request
  [ContentApplications <IKubernetesContentApplications[]>]: List of applications to be added as content
    Guid <String>: GUID value of the Kubernetes Application to be associated as content
    Type <String>: Type of the Kubernetes application
    [Name <String>]: Name of the application
  [ContentLabelSelectors <IKubernetesContentSelectors[]>]: List of label selectors to be added as content
    SelectorLevel <String>: Selector level of the label selector
    SelectorValue <String>: Value of the label selector in key=value format
  [FilterApplications <IKubernetesContentApplications[]>]: List of applications to be added as content
  [FilterLabelSelectors <IKubernetesContentSelectors[]>]: List of label selectors to be added as content
  [FilterSkipStatelessApps <Boolean?>]: Specify whether to skip backup of stateless applications

CONTENTAPPLICATIONS <IKubernetesContentApplications[]>: List of applications to be added as content
  Guid <String>: GUID value of the Kubernetes Application to be associated as content
  Type <String>: Type of the Kubernetes application
  [Name <String>]: Name of the application

CONTENTLABELSELECTORS <IKubernetesContentSelectors[]>: List of label selectors to be added as content
  SelectorLevel <String>: Selector level of the label selector
  SelectorValue <String>: Value of the label selector in key=value format

FILTERAPPLICATIONS <IKubernetesContentApplications[]>: List of applications to be added as content
  Guid <String>: GUID value of the Kubernetes Application to be associated as content
  Type <String>: Type of the Kubernetes application
  [Name <String>]: Name of the application

FILTERLABELSELECTORS <IKubernetesContentSelectors[]>: List of label selectors to be added as content
  SelectorLevel <String>: Selector level of the label selector
  SelectorValue <String>: Value of the label selector in key=value format
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvpreviewapplicationgroup
#>
function Invoke-CVPreviewApplicationGroup {
[OutputType([Commvault.Powershell.Models.IKubernetesApplicationGroupPreviewResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='PreviewExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # clusterId of the Kubernetes client to do a Preview
    ${ClusterId},

    [Parameter(ParameterSetName='Preview', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IKubernetesApplicationGroupPreviewReq]
    # Application Group Preview Request
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IKubernetesContentApplications[]]
    # List of applications to be added as content
    # To construct, see NOTES section for CONTENTAPPLICATIONS properties and create a hash table.
    ${ContentApplications},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IKubernetesContentSelectors[]]
    # List of label selectors to be added as content
    # To construct, see NOTES section for CONTENTLABELSELECTORS properties and create a hash table.
    ${ContentLabelSelectors},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IKubernetesContentApplications[]]
    # List of applications to be added as content
    # To construct, see NOTES section for FILTERAPPLICATIONS properties and create a hash table.
    ${FilterApplications},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IKubernetesContentSelectors[]]
    # List of label selectors to be added as content
    # To construct, see NOTES section for FILTERLABELSELECTORS properties and create a hash table.
    ${FilterLabelSelectors},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Specify whether to skip backup of stateless applications
    ${FilterSkipStatelessApps},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Preview = 'CommvaultPowershell.private\Invoke-CVPreviewApplicationGroup_Preview';
            PreviewExpanded = 'CommvaultPowershell.private\Invoke-CVPreviewApplicationGroup_PreviewExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get a preview of servers affected with create server group operation
.Description
Get a preview of servers affected with create server group operation
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IAutomaticServerGroupAssociationDetails
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IIdName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IAutomaticServerGroupAssociationDetails>: .
  [ClientScopeType <String>]: 
  [ConfirmRuleChange <Boolean?>]: Confirm that server group rule impacts server of a specific company smart client group only
  [EntityInfoId <Int64?>]: 
  [EntityInfoName <String>]: 
  [ServerGroupRuleGroup <IServerRuleGroup[]>]: List of rule groups
    [Match <String>]: 
    [Rules <IServerRule[]>]: List of rules
      [MatchCondition <String>]: 
      [RuleName <String>]: 
      [RuleSecValue <String>]: Secondary value used for BETWEEN and NOT_BETWEEN matchCondition. For ruleName which have enum values (like OS_TYPE), this is used to store displayName.
      [RuleValue <String>]: Primary value for the rule
  [ServerGroupRuleMatch <String>]: 

SERVERGROUPRULEGROUP <IServerRuleGroup[]>: List of rule groups
  [Match <String>]: 
  [Rules <IServerRule[]>]: List of rules
    [MatchCondition <String>]: 
    [RuleName <String>]: 
    [RuleSecValue <String>]: Secondary value used for BETWEEN and NOT_BETWEEN matchCondition. For ruleName which have enum values (like OS_TYPE), this is used to store displayName.
    [RuleValue <String>]: Primary value for the rule
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvpreviewservergroupcreation
#>
function Invoke-CVPreviewServerGroupCreation {
[OutputType([Commvault.Powershell.Models.IIdName], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='PreviewExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Preview', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAutomaticServerGroupAssociationDetails]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ClientScopeType},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Confirm that server group rule impacts server of a specific company smart client group only
    ${ConfirmRuleChange},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${EntityInfoId},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${EntityInfoName},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IServerRuleGroup[]]
    # List of rule groups
    # To construct, see NOTES section for SERVERGROUPRULEGROUP properties and create a hash table.
    ${ServerGroupRuleGroup},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ServerGroupRuleMatch},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Preview = 'CommvaultPowershell.private\Invoke-CVPreviewServerGroupCreation_Preview';
            PreviewExpanded = 'CommvaultPowershell.private\Invoke-CVPreviewServerGroupCreation_PreviewExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Preview of the vm to be protected in VMGroup
.Description
Preview of the vm to be protected in VMGroup
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IVMGroupPreviewReq
.Outputs
Commvault.Powershell.Models.IGenericRespWithWarning
.Outputs
Commvault.Powershell.Models.IVMGroupPreviewResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IVMGroupPreviewReq>: vmGroupPreviewReq
  [ContentOverwrite <Boolean?>]: True if content in vmgroup has to be overwritten, by default it will append the content
  [ContentRuleGroups <IRuleGroupContent[]>]: 
    [MatchRule <String>]: Enum which specifies the whether to match all rules or any of the rules
    [Rules <IRuleContent[]>]: 
      [Condition <String>]: Operation type for VM rules/filters
      [DisplayName <String>]: The display name of the entity to be added
      [Guid <String>]: GUID of the entity to be added as content
      [Name <String>]: name of the VM to be added as content
      [Type <String>]: 
      [Value <String>]: value for the few type of VM Content like powerstate
  [ContentVirtualMachines <IVirtualMachinecontent[]>]: 
    [ExistingCredentialId <Int64?>]: 
    [ExistingCredentialName <String>]: 
    [GuestCredentialAssocId <Int64?>]: Credential association ID given to link entity with credential id.
    [GuestCredentialsPassword <String>]: 
    [GuestCredentialsUserName <String>]: 
    [Guid <String>]: GUID of the VM to be added as content
    [Name <String>]: name of the VM to be added as content
    [Type <String>]: 
  [DiskFilterOverwrite <Boolean?>]: True if content in vmgroup has to be overwritten, by default it will append the content
  [DiskFilterRules <IVMDiskFilter[]>]: 
    [Condition <String>]: Operation type for VM rules/filters
    [FilterType <String>]: 
    [Name <String>]: The string to be filtered
    [Overwrite <Boolean?>]: True if disk filter in vmgroup has to be overwritten, by default it will append the content
    [VMGuid <String>]: VM Guid of the Virtual Machine whose disk has to be filtered . This is optional. if not given, all disks of name and type from all Vms added in content will be filtered
    [VMName <String>]: VM Name of the Virtual Machine whose disk has to be filtered . This is optional. if not given, all disks of name and type from all Vms added in content will be filtered
    [Value <String>]: The value string to be filtered, in case of disk tag , value of tag to be filtered
  [FilterOverwrite <Boolean?>]: True if content in vmgroup has to be overwritten, by default it will append the content
  [FilterRuleGroups <IRuleGroupContent[]>]: 
  [FilterVirtualMachines <IVirtualMachinecontent[]>]: 

CONTENTRULEGROUPS <IRuleGroupContent[]>: .
  [MatchRule <String>]: Enum which specifies the whether to match all rules or any of the rules
  [Rules <IRuleContent[]>]: 
    [Condition <String>]: Operation type for VM rules/filters
    [DisplayName <String>]: The display name of the entity to be added
    [Guid <String>]: GUID of the entity to be added as content
    [Name <String>]: name of the VM to be added as content
    [Type <String>]: 
    [Value <String>]: value for the few type of VM Content like powerstate

CONTENTVIRTUALMACHINES <IVirtualMachinecontent[]>: .
  [ExistingCredentialId <Int64?>]: 
  [ExistingCredentialName <String>]: 
  [GuestCredentialAssocId <Int64?>]: Credential association ID given to link entity with credential id.
  [GuestCredentialsPassword <String>]: 
  [GuestCredentialsUserName <String>]: 
  [Guid <String>]: GUID of the VM to be added as content
  [Name <String>]: name of the VM to be added as content
  [Type <String>]: 

DISKFILTERRULES <IVMDiskFilter[]>: .
  [Condition <String>]: Operation type for VM rules/filters
  [FilterType <String>]: 
  [Name <String>]: The string to be filtered
  [Overwrite <Boolean?>]: True if disk filter in vmgroup has to be overwritten, by default it will append the content
  [VMGuid <String>]: VM Guid of the Virtual Machine whose disk has to be filtered . This is optional. if not given, all disks of name and type from all Vms added in content will be filtered
  [VMName <String>]: VM Name of the Virtual Machine whose disk has to be filtered . This is optional. if not given, all disks of name and type from all Vms added in content will be filtered
  [Value <String>]: The value string to be filtered, in case of disk tag , value of tag to be filtered

FILTERRULEGROUPS <IRuleGroupContent[]>: .
  [MatchRule <String>]: Enum which specifies the whether to match all rules or any of the rules
  [Rules <IRuleContent[]>]: 
    [Condition <String>]: Operation type for VM rules/filters
    [DisplayName <String>]: The display name of the entity to be added
    [Guid <String>]: GUID of the entity to be added as content
    [Name <String>]: name of the VM to be added as content
    [Type <String>]: 
    [Value <String>]: value for the few type of VM Content like powerstate

FILTERVIRTUALMACHINES <IVirtualMachinecontent[]>: .
  [ExistingCredentialId <Int64?>]: 
  [ExistingCredentialName <String>]: 
  [GuestCredentialAssocId <Int64?>]: Credential association ID given to link entity with credential id.
  [GuestCredentialsPassword <String>]: 
  [GuestCredentialsUserName <String>]: 
  [Guid <String>]: GUID of the VM to be added as content
  [Name <String>]: name of the VM to be added as content
  [Type <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvpreviewvmgroup
#>
function Invoke-CVPreviewVMGroup {
[OutputType([Commvault.Powershell.Models.IVMGroupPreviewResp], [Commvault.Powershell.Models.IGenericRespWithWarning])]
[CmdletBinding(DefaultParameterSetName='PreviewExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Hypervisor Id of VMGroup
    ${HypervisorId},

    [Parameter(ParameterSetName='Preview', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVMGroupPreviewReq]
    # vmGroupPreviewReq
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if content in vmgroup has to be overwritten, by default it will append the content
    ${ContentOverwrite},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRuleGroupContent[]]
    # .
    # To construct, see NOTES section for CONTENTRULEGROUPS properties and create a hash table.
    ${ContentRuleGroups},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVirtualMachinecontent[]]
    # .
    # To construct, see NOTES section for CONTENTVIRTUALMACHINES properties and create a hash table.
    ${ContentVirtualMachines},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if content in vmgroup has to be overwritten, by default it will append the content
    ${DiskFilterOverwrite},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVMDiskFilter[]]
    # .
    # To construct, see NOTES section for DISKFILTERRULES properties and create a hash table.
    ${DiskFilterRules},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if content in vmgroup has to be overwritten, by default it will append the content
    ${FilterOverwrite},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRuleGroupContent[]]
    # .
    # To construct, see NOTES section for FILTERRULEGROUPS properties and create a hash table.
    ${FilterRuleGroups},

    [Parameter(ParameterSetName='PreviewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVirtualMachinecontent[]]
    # .
    # To construct, see NOTES section for FILTERVIRTUALMACHINES properties and create a hash table.
    ${FilterVirtualMachines},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Preview = 'CommvaultPowershell.private\Invoke-CVPreviewVMGroup_Preview';
            PreviewExpanded = 'CommvaultPowershell.private\Invoke-CVPreviewVMGroup_PreviewExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
REconfigures and Renew License for  the hypervisor client
.Description
REconfigures and Renew License for  the hypervisor client
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvreconfigurehypervisor
#>
function Invoke-CVReConfigureHypervisor {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Re', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Re', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Hypervisor client ID to reconfigure
    ${HypervisorId},

    [Parameter(ParameterSetName='ReViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Re = 'CommvaultPowershell.private\Invoke-CVReConfigureHypervisor_Re';
            ReViaIdentity = 'CommvaultPowershell.private\Invoke-CVReConfigureHypervisor_ReViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Selectively uninstall packages from given client
.Description
Selectively uninstall packages from given client
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IRetireClientRequest
.Outputs
Commvault.Powershell.Models.IRetireClientResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IRetireClientRequest>: RetireClientRequest
  [Packages <IIdName[]>]: 
    [Id <Int64?>]: 
    [Name <String>]: 
  [RetireClient <Boolean?>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

PACKAGES <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvretireclientpackage
#>
function Invoke-CVRetireClientPackage {
[OutputType([Commvault.Powershell.Models.IRetireClientResponse])]
[CmdletBinding(DefaultParameterSetName='RetireExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Retire', Mandatory)]
    [Parameter(ParameterSetName='RetireExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ClientId},

    [Parameter(ParameterSetName='RetireViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='RetireViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Retire', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='RetireViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRetireClientRequest]
    # RetireClientRequest
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='RetireExpanded')]
    [Parameter(ParameterSetName='RetireViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for PACKAGES properties and create a hash table.
    ${Packages},

    [Parameter(ParameterSetName='RetireExpanded')]
    [Parameter(ParameterSetName='RetireViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${RetireClient},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Retire = 'CommvaultPowershell.private\Invoke-CVRetireClientPackage_Retire';
            RetireExpanded = 'CommvaultPowershell.private\Invoke-CVRetireClientPackage_RetireExpanded';
            RetireViaIdentity = 'CommvaultPowershell.private\Invoke-CVRetireClientPackage_RetireViaIdentity';
            RetireViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVRetireClientPackage_RetireViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to retire a Kubernetes cluster with clusterId
.Description
API to retire a Kubernetes cluster with clusterId
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvretirekubernetecluster
#>
function Invoke-CVRetireKuberneteCluster {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Retire', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Retire', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # clusterId is the ID of the Kubernetes cluster client
    ${ClusterId},

    [Parameter(ParameterSetName='RetireViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Retire = 'CommvaultPowershell.private\Invoke-CVRetireKuberneteCluster_Retire';
            RetireViaIdentity = 'CommvaultPowershell.private\Invoke-CVRetireKuberneteCluster_RetireViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Retire servers in given server group
.Description
Retire servers in given server group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IRetireServerGroupResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvretireservergroup
#>
function Invoke-CVRetireServerGroup {
[OutputType([Commvault.Powershell.Models.IRetireServerGroupResp])]
[CmdletBinding(DefaultParameterSetName='Retire', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Retire', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the serverGroup in which servers need to be retired
    ${ServerGroupId},

    [Parameter(ParameterSetName='RetireViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Retire = 'CommvaultPowershell.private\Invoke-CVRetireServerGroup_Retire';
            RetireViaIdentity = 'CommvaultPowershell.private\Invoke-CVRetireServerGroup_RetireViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Retire multiple servers
.Description
Retire multiple servers
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IRetireServersRequest
.Outputs
Commvault.Powershell.Models.IRetireServersResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IRetireServersRequest>: RetireServersRequest
  [Servers <IIdName[]>]: 
    [Id <Int64?>]: 
    [Name <String>]: 

SERVERS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvretireserver
#>
function Invoke-CVRetireServer {
[OutputType([Commvault.Powershell.Models.IRetireServersResponse])]
[CmdletBinding(DefaultParameterSetName='RetireExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Retire', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRetireServersRequest]
    # RetireServersRequest
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='RetireExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for SERVERS properties and create a hash table.
    ${Servers},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Retire = 'CommvaultPowershell.private\Invoke-CVRetireServer_Retire';
            RetireExpanded = 'CommvaultPowershell.private\Invoke-CVRetireServer_RetireExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint is used to return the details of Drive Pool.
.Description
This endpoint is used to return the details of Drive Pool.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IDrivePoolDetailsResp
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvreturndrivepooldetail
#>
function Invoke-CVReturnDrivePoolDetail {
[OutputType([Commvault.Powershell.Models.IDrivePoolDetailsResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Return', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Return', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Drive of which the drive details has to be displayed
    ${DriveId},

    [Parameter(ParameterSetName='Return', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Tape of which the drive details has to be displayed
    ${LibraryId},

    [Parameter(ParameterSetName='ReturnViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Return = 'CommvaultPowershell.private\Invoke-CVReturnDrivePoolDetail_Return';
            ReturnViaIdentity = 'CommvaultPowershell.private\Invoke-CVReturnDrivePoolDetail_ReturnViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint is used to return the list of tape storages.
.Description
This endpoint is used to return the list of tape storages.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.ILocationsDetails
.Outputs
Commvault.Powershell.Models.ITapeSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvreturnlist
#>
function Invoke-CVReturnList {
[OutputType([Commvault.Powershell.Models.ITapeSummary], [Commvault.Powershell.Models.ILocationsDetails], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Return', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Return = 'CommvaultPowershell.private\Invoke-CVReturnList_Return';
            Return1 = 'CommvaultPowershell.private\Invoke-CVReturnList_Return1';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
rotates the S3AccessKey for the logged in user
.Description
rotates the S3AccessKey for the logged in user
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResponse
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvrotates3accesskey
#>
function Invoke-CVRotateS3AccessKey {
[OutputType([Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='Rotate', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Rotate = 'CommvaultPowershell.private\Invoke-CVRotateS3AccessKey_Rotate';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Rotate the S3AccessKey for the given User Id
.Description
Rotate the S3AccessKey for the given User Id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvrotateusers3accesskey
#>
function Invoke-CVRotateUserS3AccessKey {
[OutputType([Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='Rotate', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Rotate', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the user
    ${Id},

    [Parameter(ParameterSetName='RotateViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Rotate = 'CommvaultPowershell.private\Invoke-CVRotateUserS3AccessKey_Rotate';
            RotateViaIdentity = 'CommvaultPowershell.private\Invoke-CVRotateUserS3AccessKey_RotateViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Deleting an unmounted or created snapshot from Storage Arrays
.Description
Deleting an unmounted or created snapshot from Storage Arrays
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IDeleteSnapReq
.Outputs
Commvault.Powershell.Models.ISnapReconResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IDeleteSnapReq>: Request template of delete snapshots
  [Volumes <IVolumeSnap[]>]: Volumes of the snaps you want to delete
    [Flags <Int64?>]: Volume flags to be set for snap Operations.
    [SmVolumeId <Int64?>]: smVolumeId of the snaps you want to mount/unmount/delete

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

VOLUMES <IVolumeSnap[]>: Volumes of the snaps you want to delete
  [Flags <Int64?>]: Volume flags to be set for snap Operations.
  [SmVolumeId <Int64?>]: smVolumeId of the snaps you want to mount/unmount/delete
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvsnapdelete
#>
function Invoke-CVSnapDelete {
[OutputType([Commvault.Powershell.Models.ISnapReconResp])]
[CmdletBinding(DefaultParameterSetName='SnapExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Snap', Mandatory)]
    [Parameter(ParameterSetName='SnapExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='SnapViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Snap', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SnapViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDeleteSnapReq]
    # Request template of delete snapshots
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='SnapExpanded')]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVolumeSnap[]]
    # Volumes of the snaps you want to delete
    # To construct, see NOTES section for VOLUMES properties and create a hash table.
    ${Volumes},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Snap = 'CommvaultPowershell.private\Invoke-CVSnapDelete_Snap';
            SnapExpanded = 'CommvaultPowershell.private\Invoke-CVSnapDelete_SnapExpanded';
            SnapViaIdentity = 'CommvaultPowershell.private\Invoke-CVSnapDelete_SnapViaIdentity';
            SnapViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVSnapDelete_SnapViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Force deleting an unmounted or created snapshot from Storage Arrays.
Please be aware, triggering this API will not delete the snapshots from the storage array, so ensure that you delete snapshots on the array before using this operation.
.Description
Force deleting an unmounted or created snapshot from Storage Arrays.
Please be aware, triggering this API will not delete the snapshots from the storage array, so ensure that you delete snapshots on the array before using this operation.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ISnapForceReq
.Outputs
Commvault.Powershell.Models.ISnapReconResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISnapForceReq>: snapForceReq
  [Volumes <ISnapVolumes[]>]: 
    SmVolumeId <Int64>: smVolumeId of the snap
    [CommCellId <Int64?>]: Commcell Id of the setup

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

VOLUMES <ISnapVolumes[]>: .
  SmVolumeId <Int64>: smVolumeId of the snap
  [CommCellId <Int64?>]: Commcell Id of the setup
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvsnapforcedelete
#>
function Invoke-CVSnapForceDelete {
[OutputType([Commvault.Powershell.Models.ISnapReconResp])]
[CmdletBinding(DefaultParameterSetName='SnapExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Snap', Mandatory)]
    [Parameter(ParameterSetName='SnapExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='SnapViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Snap', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SnapViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapForceReq]
    # snapForceReq
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='SnapExpanded')]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapVolumes[]]
    # .
    # To construct, see NOTES section for VOLUMES properties and create a hash table.
    ${Volumes},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Snap = 'CommvaultPowershell.private\Invoke-CVSnapForceDelete_Snap';
            SnapExpanded = 'CommvaultPowershell.private\Invoke-CVSnapForceDelete_SnapExpanded';
            SnapViaIdentity = 'CommvaultPowershell.private\Invoke-CVSnapForceDelete_SnapViaIdentity';
            SnapViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVSnapForceDelete_SnapViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Force unmounting a mounted Snapshot from Storage Array.
Please be aware, triggering this API will not physically unmount the snapshots from the storage array or MA, so ensure that you unmapped the snapshots on the array and cleanup the mount host and LVM before using this operation.
.Description
Force unmounting a mounted Snapshot from Storage Array.
Please be aware, triggering this API will not physically unmount the snapshots from the storage array or MA, so ensure that you unmapped the snapshots on the array and cleanup the mount host and LVM before using this operation.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ISnapForceReq
.Outputs
Commvault.Powershell.Models.ISnapReconResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISnapForceReq>: snapForceReq
  [Volumes <ISnapVolumes[]>]: 
    SmVolumeId <Int64>: smVolumeId of the snap
    [CommCellId <Int64?>]: Commcell Id of the setup

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

VOLUMES <ISnapVolumes[]>: .
  SmVolumeId <Int64>: smVolumeId of the snap
  [CommCellId <Int64?>]: Commcell Id of the setup
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvsnapforceunmount
#>
function Invoke-CVSnapForceUnmount {
[OutputType([Commvault.Powershell.Models.ISnapReconResp])]
[CmdletBinding(DefaultParameterSetName='SnapExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Snap', Mandatory)]
    [Parameter(ParameterSetName='SnapExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='SnapViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Snap', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SnapViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapForceReq]
    # snapForceReq
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='SnapExpanded')]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapVolumes[]]
    # .
    # To construct, see NOTES section for VOLUMES properties and create a hash table.
    ${Volumes},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Snap = 'CommvaultPowershell.private\Invoke-CVSnapForceUnmount_Snap';
            SnapExpanded = 'CommvaultPowershell.private\Invoke-CVSnapForceUnmount_SnapExpanded';
            SnapViaIdentity = 'CommvaultPowershell.private\Invoke-CVSnapForceUnmount_SnapViaIdentity';
            SnapViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVSnapForceUnmount_SnapViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Mounting a snapshot from the Storage Array
.Description
Mounting a snapshot from the Storage Array
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IMountReq
.Outputs
Commvault.Powershell.Models.ISnapReconResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

APPID <IVsaApplicationDetails[]>: .
  [ApptypeId <Int64?>]: apptype id or agent type
  [ClientId <Int64?>]: hypervisor Id of hypervisor where user is mounting snapshot
  [InstanceId <Int64?>]: instance id of the instance to which subclient is associated
  [SubclientId <Int64?>]: subclient id associated to snapshot

BODY <IMountReq>: Request template for Mounting Snapshots. scsiServer refers to the iSCSI server which the user can choose while mounting.
  [AppId <IVsaApplicationDetails[]>]: 
    [ApptypeId <Int64?>]: apptype id or agent type
    [ClientId <Int64?>]: hypervisor Id of hypervisor where user is mounting snapshot
    [InstanceId <Int64?>]: instance id of the instance to which subclient is associated
    [SubclientId <Int64?>]: subclient id associated to snapshot
  [DestinationClientId <Int64?>]: Id of the MA where the Snap is mounted
  [DestinationClientPath <String>]: Path where the snap is mounted
  [ProtectSnap <Int64?>]: Enable or disable VSS protection on Snaps while mounting
  [ScsiServerId <Int64?>]: 
  [ScsiServerName <String>]: 
  [Server <IVsaServerDetails[]>]: 
    [ServerName <String>]: server name
    [ServerType <Int64?>]: type of server
  [UserName <String>]: 
  [Volumes <IVolumeSnap[]>]: Volumes of the snap you want to mount
    [Flags <Int64?>]: Volume flags to be set for snap Operations.
    [SmVolumeId <Int64?>]: smVolumeId of the snaps you want to mount/unmount/delete

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

SERVER <IVsaServerDetails[]>: .
  [ServerName <String>]: server name
  [ServerType <Int64?>]: type of server

VOLUMES <IVolumeSnap[]>: Volumes of the snap you want to mount
  [Flags <Int64?>]: Volume flags to be set for snap Operations.
  [SmVolumeId <Int64?>]: smVolumeId of the snaps you want to mount/unmount/delete
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvsnapmount
#>
function Invoke-CVSnapMount {
[OutputType([Commvault.Powershell.Models.ISnapReconResp])]
[CmdletBinding(DefaultParameterSetName='SnapExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Snap', Mandatory)]
    [Parameter(ParameterSetName='SnapExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='SnapViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Snap', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SnapViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IMountReq]
    # Request template for Mounting Snapshots.
    # scsiServer refers to the iSCSI server which the user can choose while mounting.
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='SnapExpanded')]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVsaApplicationDetails[]]
    # .
    # To construct, see NOTES section for APPID properties and create a hash table.
    ${AppId},

    [Parameter(ParameterSetName='SnapExpanded')]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Id of the MA where the Snap is mounted
    ${DestinationClientId},

    [Parameter(ParameterSetName='SnapExpanded')]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Path where the snap is mounted
    ${DestinationClientPath},

    [Parameter(ParameterSetName='SnapExpanded')]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Enable or disable VSS protection on Snaps while mounting
    ${ProtectSnap},

    [Parameter(ParameterSetName='SnapExpanded')]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${ScsiServerId},

    [Parameter(ParameterSetName='SnapExpanded')]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ScsiServerName},

    [Parameter(ParameterSetName='SnapExpanded')]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVsaServerDetails[]]
    # .
    # To construct, see NOTES section for SERVER properties and create a hash table.
    ${Server},

    [Parameter(ParameterSetName='SnapExpanded')]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${UserName},

    [Parameter(ParameterSetName='SnapExpanded')]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVolumeSnap[]]
    # Volumes of the snap you want to mount
    # To construct, see NOTES section for VOLUMES properties and create a hash table.
    ${Volumes},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Snap = 'CommvaultPowershell.private\Invoke-CVSnapMount_Snap';
            SnapExpanded = 'CommvaultPowershell.private\Invoke-CVSnapMount_SnapExpanded';
            SnapViaIdentity = 'CommvaultPowershell.private\Invoke-CVSnapMount_SnapViaIdentity';
            SnapViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVSnapMount_SnapViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Starts a workflow snap reconcile for array
.Description
Starts a workflow snap reconcile for array
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ISnapReconResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvsnapreconworkflow
#>
function Invoke-CVSnapReconWorkflow {
[OutputType([Commvault.Powershell.Models.ISnapReconResp])]
[CmdletBinding(DefaultParameterSetName='Snap', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Snap', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='SnapViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Snap = 'CommvaultPowershell.private\Invoke-CVSnapReconWorkflow_Snap';
            SnapViaIdentity = 'CommvaultPowershell.private\Invoke-CVSnapReconWorkflow_SnapViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Reverting a created or unmounted snapshot from the storage array
.Description
Reverting a created or unmounted snapshot from the storage array
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ISnapRevertReq
.Outputs
Commvault.Powershell.Models.ISnapReconResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISnapRevertReq>: Request template for revert snapshots
  [Volumes <IVolumeSnap[]>]: 
    [Flags <Int64?>]: Volume flags to be set for snap Operations.
    [SmVolumeId <Int64?>]: smVolumeId of the snaps you want to mount/unmount/delete

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

VOLUMES <IVolumeSnap[]>: .
  [Flags <Int64?>]: Volume flags to be set for snap Operations.
  [SmVolumeId <Int64?>]: smVolumeId of the snaps you want to mount/unmount/delete
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvsnaprevert
#>
function Invoke-CVSnapRevert {
[OutputType([Commvault.Powershell.Models.ISnapReconResp])]
[CmdletBinding(DefaultParameterSetName='SnapExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Snap', Mandatory)]
    [Parameter(ParameterSetName='SnapExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='SnapViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Snap', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SnapViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapRevertReq]
    # Request template for revert snapshots
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='SnapExpanded')]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVolumeSnap[]]
    # .
    # To construct, see NOTES section for VOLUMES properties and create a hash table.
    ${Volumes},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Snap = 'CommvaultPowershell.private\Invoke-CVSnapRevert_Snap';
            SnapExpanded = 'CommvaultPowershell.private\Invoke-CVSnapRevert_SnapExpanded';
            SnapViaIdentity = 'CommvaultPowershell.private\Invoke-CVSnapRevert_SnapViaIdentity';
            SnapViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVSnapRevert_SnapViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Unmounting a mounted Snapshot from Storage Array
.Description
Unmounting a mounted Snapshot from Storage Array
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUnmountSnapReq
.Outputs
Commvault.Powershell.Models.ISnapReconResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUnmountSnapReq>: Request template for unmount request of snapshots
  [Volumes <IVolumeSnap[]>]: Volumes of the snap you want to unmount
    [Flags <Int64?>]: Volume flags to be set for snap Operations.
    [SmVolumeId <Int64?>]: smVolumeId of the snaps you want to mount/unmount/delete

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

VOLUMES <IVolumeSnap[]>: Volumes of the snap you want to unmount
  [Flags <Int64?>]: Volume flags to be set for snap Operations.
  [SmVolumeId <Int64?>]: smVolumeId of the snaps you want to mount/unmount/delete
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvsnapunmount
#>
function Invoke-CVSnapUnmount {
[OutputType([Commvault.Powershell.Models.ISnapReconResp])]
[CmdletBinding(DefaultParameterSetName='SnapExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Snap', Mandatory)]
    [Parameter(ParameterSetName='SnapExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='SnapViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Snap', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SnapViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUnmountSnapReq]
    # Request template for unmount request of snapshots
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='SnapExpanded')]
    [Parameter(ParameterSetName='SnapViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVolumeSnap[]]
    # Volumes of the snap you want to unmount
    # To construct, see NOTES section for VOLUMES properties and create a hash table.
    ${Volumes},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Snap = 'CommvaultPowershell.private\Invoke-CVSnapUnmount_Snap';
            SnapExpanded = 'CommvaultPowershell.private\Invoke-CVSnapUnmount_SnapExpanded';
            SnapViaIdentity = 'CommvaultPowershell.private\Invoke-CVSnapUnmount_SnapViaIdentity';
            SnapViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVSnapUnmount_SnapViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to list snaps for a particular Job Id
.Description
API to list snaps for a particular Job Id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IListSnapshots
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvsnap
#>
function Invoke-CVSnap {
[OutputType([Commvault.Powershell.Models.IListSnapshots])]
[CmdletBinding(DefaultParameterSetName='Snap', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Snap', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${JobId},

    [Parameter(ParameterSetName='SnapViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # .
    ${CommcellId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Snap = 'CommvaultPowershell.private\Invoke-CVSnap_Snap';
            SnapViaIdentity = 'CommvaultPowershell.private\Invoke-CVSnap_SnapViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Unpin triggered alerts
.Description
Unpin triggered alerts
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvunpintriggeredalert
#>
function Invoke-CVUnpinTriggeredAlert {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Unpin', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Unpin', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(ParameterSetName='UnpinViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Unpin = 'CommvaultPowershell.private\Invoke-CVUnpinTriggeredAlert_Unpin';
            UnpinViaIdentity = 'CommvaultPowershell.private\Invoke-CVUnpinTriggeredAlert_UnpinViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Mark a triggered alert as unread
.Description
Mark a triggered alert as unread
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvunreadtriggeredalert
#>
function Invoke-CVUnreadTriggeredAlert {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Unread', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Unread', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(ParameterSetName='UnreadViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Unread = 'CommvaultPowershell.private\Invoke-CVUnreadTriggeredAlert_Unread';
            UnreadViaIdentity = 'CommvaultPowershell.private\Invoke-CVUnreadTriggeredAlert_UnreadViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Deletes the VM.
.Description
Deletes the VM.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvvmactiondelete
#>
function Invoke-CVVMActionDelete {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Post', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Post', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # GUID of the Provisioned VM
    ${VMGuid},

    [Parameter(ParameterSetName='PostViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Post = 'CommvaultPowershell.private\Invoke-CVVMActionDelete_Post';
            PostViaIdentity = 'CommvaultPowershell.private\Invoke-CVVMActionDelete_PostViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Refreshes the VM.
.Description
Refreshes the VM.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvvmactionrefresh
#>
function Invoke-CVVMActionRefresh {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Post', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Post', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # GUID of the Provisioned VM
    ${VMGuid},

    [Parameter(ParameterSetName='PostViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Post = 'CommvaultPowershell.private\Invoke-CVVMActionRefresh_Post';
            PostViaIdentity = 'CommvaultPowershell.private\Invoke-CVVMActionRefresh_PostViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Renew the VM with the provided timestamp.
.Description
Renew the VM with the provided timestamp.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IPaths1C2BvcjV4VMVmguidActionRenewPostRequestbodyContentApplicationJsonSchema
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IPaths1C2BvcjV4VMVmguidActionRenewPostRequestbodyContentApplicationJsonSchema>: .
  [Time <Int64?>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-cvvmactionrenew
#>
function Invoke-CVVMActionRenew {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='PostExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Post', Mandatory)]
    [Parameter(ParameterSetName='PostExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # GUID of the Provisioned VM
    ${VMGuid},

    [Parameter(ParameterSetName='PostViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='PostViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Post', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='PostViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPaths1C2BvcjV4VMVmguidActionRenewPostRequestbodyContentApplicationJsonSchema]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PostExpanded')]
    [Parameter(ParameterSetName='PostViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${Time},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Post = 'CommvaultPowershell.private\Invoke-CVVMActionRenew_Post';
            PostExpanded = 'CommvaultPowershell.private\Invoke-CVVMActionRenew_PostExpanded';
            PostViaIdentity = 'CommvaultPowershell.private\Invoke-CVVMActionRenew_PostViaIdentity';
            PostViaIdentityExpanded = 'CommvaultPowershell.private\Invoke-CVVMActionRenew_PostViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Add your QSDK Authenticated token to your Postman Environment by providing the details in the pre-request script.\n\nYou only need to run this one time because these values are stored in your Postman Environment.
.Description
Add your QSDK Authenticated token to your Postman Environment by providing the details in the pre-request script.\n\nYou only need to run this one time because these values are stored in your Postman Environment.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IEnvironmentSetupRequest
.Outputs
Commvault.Powershell.Models.ILoginResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODYPARAMETER <IEnvironmentSetupRequest>: EnvironmentSetupRequest
  Password <String>: 
  Username <String>: 
  WebServerUrl <String>: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/invoke-setuplogin
#>
function Invoke-SetupLogin {
[OutputType([Commvault.Powershell.Models.ILoginResponse])]
[CmdletBinding(DefaultParameterSetName='PostExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Post', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IEnvironmentSetupRequest]
    # EnvironmentSetupRequest
    # To construct, see NOTES section for BODYPARAMETER properties and create a hash table.
    ${BodyParameter},

    [Parameter(ParameterSetName='PostExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Password},

    [Parameter(ParameterSetName='PostExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Username},

    [Parameter(ParameterSetName='PostExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${WebServerUrl},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Post = 'CommvaultPowershell.private\Invoke-SetupLogin_Post';
            PostExpanded = 'CommvaultPowershell.private\Invoke-SetupLogin_PostExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to manage MediaAgents associated with the Storage Pool
.Description
API to manage MediaAgents associated with the Storage Pool
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/join-cvma
#>
function Join-CVMa {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Associate', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Associate', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Storage Pool
    ${StoragePoolId},

    [Parameter(ParameterSetName='AssociateViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Action to performed on the MediaAgent
    ${Action},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Id of the MediaAgent
    ${MediaAgentId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Associate = 'CommvaultPowershell.private\Join-CVMa_Associate';
            AssociateViaIdentity = 'CommvaultPowershell.private\Join-CVMa_AssociateViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Add a new Access path (mediaAgent) to a specific bucket of a specific cloud storage
.Description
Add a new Access path (mediaAgent) to a specific bucket of a specific cloud storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvaccesspath
#>
function New-CVAccessPath {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of Bucket
    ${BucketId},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of cloud Storage
    ${CloudStorageId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${MediaAgentId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${MediaAgentName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVAccessPath_CreateExpanded';
            CreateViaIdentityExpanded = 'CommvaultPowershell.private\New-CVAccessPath_CreateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create Alert Definitions
.Description
Create Alert Definitions
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IIdName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ALERTTYPEPARAMSLIST <IAlertDefinitionsCriteriaParams[]>: .
  [ParamIndex <Int64?>]: Param order index
  [Type <Int64?>]: Input value type (default 0 = no input required)
  [Unit <Int64?>]: Unit of the criteria(For eg. :Hrs,min)
  [Value <Int64?>]: Value of the criteria (deefault 0 : if no value required)

ASSOCIATIONS <IAlertAssociationIdNameType1[]>: AlertDefinitionsAssociations
  [Id <Int64?>]: id of the associated entity
  [Name <String>]: name of the associated entity
  [ParentEntity1Id <Int64?>]: id of the associated entity
  [ParentEntity1Name <String>]: name of the associated entity
  [ParentEntity1Type <String>]: 
  [ParentEntity2Id <Int64?>]: id of the associated entity
  [ParentEntity2Name <String>]: name of the associated entity
  [ParentEntity2Type <String>]: 
  [ParentEntity3Id <Int64?>]: id of the associated entity
  [ParentEntity3Name <String>]: name of the associated entity
  [ParentEntity3Type <String>]: 
  [ParentEntity4Id <Int64?>]: id of the associated entity
  [ParentEntity4Name <String>]: name of the associated entity
  [ParentEntity4Type <String>]: 
  [Type <String>]: 

RECIPIENTBCC <IAlertTargetIdNameType1[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
  [Type <String>]: 

RECIPIENTCC <IAlertTargetIdNameType1[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
  [Type <String>]: 

RECIPIENTTO <IAlertTargetIdNameType1[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
  [Type <String>]: 

TOKENRULEGROUPS <ITokenRuleGroup[]>: List of rule groups
  [Match <String>]: 
  [Rules <ITokenRule[]>]: List of rules
    [DateRangeFromDate <String>]: From date value in unix timestamp format
    [DateRangeTimeRange <ITimeRange[]>]: Time range selection details
      [FromTime <String>]: From time value in unix timestamp format
      [ToTime <String>]: To time value in unix timestamp format
    [DateRangeToDate <String>]: To date value in unix timestamp format
    [MatchCondition <String>]: 
    [RuleSecValue <String>]: Secondary value used for BETWEEN and NOT_BETWEEN matchCondition.
    [TimeRangeFromTime <String>]: From time value in unix timestamp format
    [TimeRangeToTime <String>]: To time value in unix timestamp format
    [TokenFormat <String>]: 
    [TokenName <String>]: Name of the token.
    [Value <String>]: Value to be compared for the token
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvalertdefinition
#>
function New-CVAlertDefinition {
[OutputType([Commvault.Powershell.Models.IIdName])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Allows adding to, overwriting and deleting existing recipients.
    # default is adding to existing recipients
    ${AlertTargetRecipientsOperationType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # .
    ${AlertTargetSendAlertTo},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Defines the category of the alert
    ${AlertTypeCategory},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Defines the criteria of the alert
    ${AlertTypeCriteria},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAlertDefinitionsCriteriaParams[]]
    # .
    # To construct, see NOTES section for ALERTTYPEPARAMSLIST properties and create a hash table.
    ${AlertTypeParamsList},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAlertAssociationIdNameType1[]]
    # AlertDefinitionsAssociations
    # To construct, see NOTES section for ASSOCIATIONS properties and create a hash table.
    ${Associations},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${LocaleId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${LocaleName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAlertTargetIdNameType1[]]
    # .
    # To construct, see NOTES section for RECIPIENTBCC properties and create a hash table.
    ${RecipientBcc},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAlertTargetIdNameType1[]]
    # .
    # To construct, see NOTES section for RECIPIENTCC properties and create a hash table.
    ${RecipientCc},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAlertTargetIdNameType1[]]
    # .
    # To construct, see NOTES section for RECIPIENTTO properties and create a hash table.
    ${RecipientTo},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # id of the webhook to be associated with the alert definition.
    # Only needed incase of webhook notif selected.
    # To get a list of webhooks, use api GET Webhook
    ${RecipientWebHookId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${SendIndividualNotifications},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to indicate whether its a subscription based alert.
    ${SubscriptionBasedAlert},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # the message template for the console notification
    ${TemplateConsole},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # the message template for the email notification.
    # Contains both email subject as well as body
    ${TemplateEmail},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # the message template for the event viewer notification
    ${TemplateEventViewer},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # the message template for the webhook notification
    ${TemplateWebhook},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${TokenMatch},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ITokenRuleGroup[]]
    # List of rule groups
    # To construct, see NOTES section for TOKENRULEGROUPS properties and create a hash table.
    ${TokenRuleGroups},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVAlertDefinition_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a Backup Destination for a Plan
.Description
Create a Backup Destination for a Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IPlanBackupDestinationResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

DESTINATIONS <ICreateArchivePlanBackupDestination[]>: List of backup destinations to create
  BackupDestinationName <String>: Backup destination details. Enter the name during creation.
  [OverrideRetentionSettings <Boolean?>]: Tells if this copy should use storage pool retention period days or the retention defined for this copy. Set as true to use retention defined on this copy.
  [RegionId <Int64?>]: 
  [RegionName <String>]: 
  [RetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention.
  [SourceCopyId <Int64?>]: 
  [SourceCopyName <String>]: 
  [StoragePoolId <Int64?>]: 
  [StoragePoolName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvarchivebackupdestination
#>
function New-CVArchiveBackupDestination {
[OutputType([Commvault.Powershell.Models.IPlanBackupDestinationResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to modify
    ${PlanId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICreateArchivePlanBackupDestination[]]
    # List of backup destinations to create
    # To construct, see NOTES section for DESTINATIONS properties and create a hash table.
    ${Destinations},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RegionId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RegionName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVArchiveBackupDestination_CreateExpanded';
            CreateViaIdentityExpanded = 'CommvaultPowershell.private\New-CVArchiveBackupDestination_CreateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create Archive Plan
.Description
Create Archive Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IPlanResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BACKUPDESTINATIONS <ICreateArchivePlanBackupDestination[]>: .
  BackupDestinationName <String>: Backup destination details. Enter the name during creation.
  [OverrideRetentionSettings <Boolean?>]: Tells if this copy should use storage pool retention period days or the retention defined for this copy. Set as true to use retention defined on this copy.
  [RegionId <Int64?>]: 
  [RegionName <String>]: 
  [RetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention.
  [SourceCopyId <Int64?>]: 
  [SourceCopyName <String>]: 
  [StoragePoolId <Int64?>]: 
  [StoragePoolName <String>]: 

RPOARCHIVEWINDOW <IDayAndTime[]>: Archive job will run only in the specified archive window
  [DayOfWeek <String[]>]: 
  [EndTime <Int64?>]: Time in seconds since the beginning of the day
  [StartTime <Int64?>]: Time in seconds since the beginning of the day
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvarchiveplan
#>
function New-CVArchivePlan {
[OutputType([Commvault.Powershell.Models.IPlanResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to enable overriding of plan.
    # Plan cannot be overriden by default.
    ${AllowPlanOverride},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Frequency of the schedule based on schedule frequency type eg.
    # for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days.
    # for Monthly 2 is it repeats every 2 months
    ${ArchiveFrequency},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Day on which to run the schedule, applicable for monthly, yearly
    ${ArchiveFrequencyDayOfMonth},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ArchiveFrequencyDayOfWeek},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ArchiveFrequencyMonthOfYear},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # schedule frequency type
    ${ArchiveFrequencyScheduleFrequencyType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # start time of schedule in seconds for daily, weekly, monthly, yearly frequency
    ${ArchiveFrequencyStartTime},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specific week of a month
    ${ArchiveFrequencyWeekOfMonth},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Days of the week for weekly frequency
    ${ArchiveFrequencyWeeklyDays},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # After an archive job, replace the file that meets the archiving rules with a stub or delete the file that meets the archiving rules
    ${ArchivingRuleAfterArchiving},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # To archive files based on the size of the file, specify the minimum file size in KB.
    ${ArchivingRuleFileSize},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # To archive files based on the last accessed or modified date of each file within the folder, specify the number of days.
    # Should be supplied with fileTimestampMethod.
    ${ArchivingRuleFileTimestamp},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ArchivingRuleFileTimestampMethod},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICreateArchivePlanBackupDestination[]]
    # .
    # To construct, see NOTES section for BACKUPDESTINATIONS properties and create a hash table.
    ${BackupDestinations},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionArchivingRules},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionRpo},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionStoragePool},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${ParentPlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ParentPlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDayAndTime[]]
    # Archive job will run only in the specified archive window
    # To construct, see NOTES section for RPOARCHIVEWINDOW properties and create a hash table.
    ${RpoArchiveWindow},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVArchivePlan_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Creating a Storage Array
.Description
Creating a Storage Array
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ACCESSNODES <IArrayAccessNodes[]>: MAs that can access the array
  [DisplayName <String>]: The display name of the corresponding Media Agent
  [Id <Int64?>]: Id of the MediaAgent
  [Name <String>]: Name of the MediaAgent
  [Pruning <Boolean?>]: Enable/Disable pruning of snapshots on the selected Media Agent

SNAPCONFIGURATIONS <IArrayConfigsBasic[]>: Configurations related to a snap engine
  MasterConfigId <Int64>: This is the masterConfigId, which is available for each vendor's configs
  Name <String>: This is the name of the config which is displayed on the Command Center Console
  Type <Int64>: Type of the config value. type can accept 7 values [1,2,8,10,12,13,14], 1: boolean, 2: integer, 8: text, 10: array[string] are common configs, the rest three are special keys, 12 is for password type key for NetApp E-Series and HPE Nimble, 13 is Private Key for GCP, 14 is a config to select type of Disk for GCP
  [Value <String>]: Takes a single value for all types except 10 and for type 14 it holds the id of the selected value from values
  [Values <IIdName[]>]: Values to be entered. for type 10 and 14. For HPE 3PAR StoreServ, pass MA Id in name field to configure that MA as remote snap MA.
    [Id <Int64?>]: 
    [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvarray
#>
function New-CVArray {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IArrayAccessNodes[]]
    # MAs that can access the array
    # To construct, see NOTES section for ACCESSNODES properties and create a hash table.
    ${AccessNodes},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Base 64 encoded Password to access the array
    ${CredentialPassword},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Username to access the array
    ${CredentialUserName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Host Name of the array
    ${GeneralControlHost},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Description of the array
    ${GeneralDescription},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the array
    ${GeneralName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${GeneralSnapVendor},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SavedCredentialId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SavedCredentialName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IArrayConfigsBasic[]]
    # Configurations related to a snap engine
    # To construct, see NOTES section for SNAPCONFIGURATIONS properties and create a hash table.
    ${SnapConfigurations},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVArray_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create Azure Active Directory app
.Description
Create Azure Active Directory app
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IIdName
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvazureadclient
#>
function New-CVAzureAdClient {
[OutputType([Commvault.Powershell.Models.IIdName])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure Application ID
    ${AzureAppApplicationId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure app secret key, needs to be base64 encoded
    ${AzureAppApplicationSecret},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure directory (tenant) ID
    ${AzureAppAzureDirectoryId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Unique Azure AD app name
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${ServerPlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ServerPlanName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVAzureAdClient_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create backup destination(s) for a plan before creating the plan.\nThe primary backup destination can be then associated with the plan to associate all secondary copies also.\n
.Description
Create backup destination(s) for a plan before creating the plan.\nThe primary backup destination can be then associated with the plan to associate all secondary copies also.\n
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.ICreatePlanBackupDestinationResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BACKUPDESTINATIONS <ICreateBackupDestination[]>: List of backup destinations to create
  Name <String>: Name of backup destination
  [BackupStartTime <Int64?>]: Backup start time in seconds. The time is provided in unix time format.
  [BackupsToCopy <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [FirstExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [FirstExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [FirstExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [FullBackupTypesToCopy <String>]: Which type of backup type should be copied for the given backup destination when backup type is not all jobs. Default is LAST while adding new backup destination.
  [IsMirrorCopy <Boolean?>]: Is this a mirror copy? Only considered when isSnapCopy is true.
  [IsSnapCopy <Boolean?>]: Is this a snap copy? If isMirrorCopy is not set, then default is Vault/Replica.
  [Mappings <ISnapshotCopyMapping[]>]: 
    [SourceId <Int64?>]: 
    [SourceName <String>]: 
    [SourceVendorId <Int64?>]: 
    [SourceVendorName <String>]: 
    [TargetId <Int64?>]: 
    [TargetName <String>]: 
    [TargetVendorId <Int64?>]: 
    [TargetVendorName <String>]: 
    [Vendor <String>]: Snapshot vendors available for Snap Copy mappings
  [NetAppCloudTarget <Boolean?>]: Only for snap copy. Enabling this changes SVM Mapping  to NetApp cloud targets only.
  [OptimizeForInstantClone <Boolean?>]: Flag to specify if primary storage is copy data management enabled.
  [OverrideRetentionSettings <Boolean?>]: Tells if this copy should use storage pool retention period days or the retention defined for this copy. Set as true to use retention defined on this copy.
  [RegionId <Int64?>]: 
  [RegionName <String>]: 
  [RetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention. If this and snapRecoveryPoints both are not specified, this takes  precedence.
  [RetentionRuleType <String>]: Which type of retention rule should be used for the given backup destination
  [SecondExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [SecondExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [SecondExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [SnapRecoveryPoints <Int64?>]: Number of snap recovery points for snap copy for retention. Can be specified instead of retention period in Days for snap copy.
  [SourceCopyId <Int64?>]: 
  [SourceCopyName <String>]: 
  [StoragePoolId <Int64?>]: 
  [StoragePoolName <String>]: 
  [StorageType <String>]: StorageType
  [ThirdExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [ThirdExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [ThirdExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [UseExtendedRetentionRules <Boolean?>]: Use extended retention rules
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvbackupdestinationwithoutplaninfo
#>
function New-CVBackupDestinationWithoutPlanInfo {
[OutputType([Commvault.Powershell.Models.ICreatePlanBackupDestinationResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICreateBackupDestination[]]
    # List of backup destinations to create
    # To construct, see NOTES section for BACKUPDESTINATIONS properties and create a hash table.
    ${BackupDestinations},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVBackupDestinationWithoutPlanInfo_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a Backup Destination for a Plan
.Description
Create a Backup Destination for a Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IPlanBackupDestinationResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

DESTINATIONS <ICreatePlanBackupDestination[]>: List of backup destinations to create
  BackupDestinationName <String>: Backup destination details. Enter the name during creation.
  [BackupStartTime <Int64?>]: Backup start time in seconds. The time is provided in unix time format.
  [BackupsToCopy <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [FirstExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [FirstExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [FirstExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [FullBackupTypesToCopy <String>]: Which type of backup type should be copied for the given backup destination when backup type is not all jobs. Default is LAST while adding new backup destination.
  [IsConfiguredForReplication <Boolean?>]: Used if the copy is used for replication group
  [IsMirrorCopy <Boolean?>]: Is this a mirror copy? Only considered when isSnapCopy is true.
  [IsSnapCopy <Boolean?>]: Is this a snap copy? If isMirrorCopy is not set, then default is Vault/Replica.
  [Mappings <ISnapshotCopyMapping[]>]: 
    [SourceId <Int64?>]: 
    [SourceName <String>]: 
    [SourceVendorId <Int64?>]: 
    [SourceVendorName <String>]: 
    [TargetId <Int64?>]: 
    [TargetName <String>]: 
    [TargetVendorId <Int64?>]: 
    [TargetVendorName <String>]: 
    [Vendor <String>]: Snapshot vendors available for Snap Copy mappings
  [NetAppCloudTarget <Boolean?>]: Only for snap copy. Enabling this changes SVM Mapping  to NetApp cloud targets only.
  [OptimizeForInstantClone <Boolean?>]: Flag to specify if primary storage is copy data management enabled.
  [OverrideRetentionSettings <Boolean?>]: Tells if this copy should use storage pool retention period days or the retention defined for this copy. Set as true to use retention defined on this copy.
  [RegionGuid <String>]: 
  [RegionId <Int64?>]: 
  [RegionName <String>]: 
  [RetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention. If this and snapRecoveryPoints both are not specified, this takes  precedence.
  [RetentionRuleType <String>]: Which type of retention rule should be used for the given backup destination
  [SecondExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [SecondExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [SecondExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [SnapRecoveryPoints <Int64?>]: Number of snap recovery points for snap copy for retention. Can be specified instead of retention period in Days for snap copy.
  [SourceCopyId <Int64?>]: 
  [SourceCopyName <String>]: 
  [StoragePoolId <Int64?>]: 
  [StoragePoolName <String>]: 
  [StorageTemplateTags <IIdNameValue[]>]: It is used in Global config template plan creation. Needs in plan creation on global commcell
    [Id <Int64?>]: 
    [Name <String>]: 
    [Value <String>]: 
  [StorageType <String>]: StorageType
  [ThirdExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [ThirdExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [ThirdExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [UseExtendedRetentionRules <Boolean?>]: Use extended retention rules

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvbackupdestination
#>
function New-CVBackupDestination {
[OutputType([Commvault.Powershell.Models.IPlanBackupDestinationResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to modify
    ${PlanId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICreatePlanBackupDestination[]]
    # List of backup destinations to create
    # To construct, see NOTES section for DESTINATIONS properties and create a hash table.
    ${Destinations},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RegionGuid},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RegionId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RegionName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Backup copy RPO in minutes
    ${SnapshotOptionBackupCopyRpoMins},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to enable backup copy
    ${SnapshotOptionEnableBackupCopy},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Retention period in days.
    # -1 can be specified for infinite retention.
    # If this and snapRecoveryPoints both are not specified, this takes precedence.
    ${SnapshotOptionRetentionPeriodDays},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of snap recovery points for default snap copy for retention.
    # Can be specified instead of retention period in Days for default snap copy.
    ${SnapshotOptionSnapRecoveryPoints},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVBackupDestination_CreateExpanded';
            CreateViaIdentityExpanded = 'CommvaultPowershell.private\New-CVBackupDestination_CreateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a new backup location
.Description
Create a new backup location
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IIdName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvbackuplocation
#>
function New-CVBackupLocation {
[OutputType([Commvault.Powershell.Models.IIdName])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the disk storage to update
    ${StoragePoolId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The mount path on the media agent where the data is to be backed up.
    ${BackupLocation},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # username to access the network path
    ${CredentialsName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # password to access the network path
    ${CredentialsPassword},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${MediaAgentId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${MediaAgentName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SavedCredentialsId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SavedCredentialsName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVBackupLocation_CreateExpanded';
            CreateViaIdentityExpanded = 'CommvaultPowershell.private\New-CVBackupLocation_CreateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a Blackout Window
.Description
Create a Blackout Window
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IIdName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ALLDAYS <IDaysAndTimes[]>: Days of the week along with the time on which the black out window will be in effect.
  [Days <String[]>]: Days of the week when the blackout window will be in effect.
  [TimeEnd <Int64?>]: the blackout window is no longer in effect from this point on.
  [TimeStart <Int64?>]: the blackout window comes into effect at this point.
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvblackoutwindow
#>
function New-CVBlackoutWindow {
[OutputType([Commvault.Powershell.Models.IIdName])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the blackout window to be created.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDaysAndTimes[]]
    # Days of the week along with the time on which the black out window will be in effect.
    # To construct, see NOTES section for ALLDAYS properties and create a hash table.
    ${AllDays},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Refers to backup types to include in the blackout window
    ${BackupOperations},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # the blackout window is no longer in effect from this point on.
    ${BetweenDateEnd},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # the blackout window comes into effect at this point.
    ${BetweenDateStart},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${CompanyId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${CompanyName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Allows or Denies submitting a job when the blackout window is in effect.
    # If set to false, the job is submitted and resumed once the blackout window ends.
    ${DoNotSubmitJob},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Refers to the weeks of the month that the blackout window will be in effect.
    ${Weeks},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVBlackoutWindow_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a CDM Plan
.Description
Create a CDM Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IPlanResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BACKUPDESTINATIONS <ICreatePlanBackupDestination[]>: Copy destinations for the plan. Specify where you want to store your data.
  BackupDestinationName <String>: Backup destination details. Enter the name during creation.
  [BackupStartTime <Int64?>]: Backup start time in seconds. The time is provided in unix time format.
  [BackupsToCopy <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [FirstExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [FirstExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [FirstExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [FullBackupTypesToCopy <String>]: Which type of backup type should be copied for the given backup destination when backup type is not all jobs. Default is LAST while adding new backup destination.
  [IsConfiguredForReplication <Boolean?>]: Used if the copy is used for replication group
  [IsMirrorCopy <Boolean?>]: Is this a mirror copy? Only considered when isSnapCopy is true.
  [IsSnapCopy <Boolean?>]: Is this a snap copy? If isMirrorCopy is not set, then default is Vault/Replica.
  [Mappings <ISnapshotCopyMapping[]>]: 
    [SourceId <Int64?>]: 
    [SourceName <String>]: 
    [SourceVendorId <Int64?>]: 
    [SourceVendorName <String>]: 
    [TargetId <Int64?>]: 
    [TargetName <String>]: 
    [TargetVendorId <Int64?>]: 
    [TargetVendorName <String>]: 
    [Vendor <String>]: Snapshot vendors available for Snap Copy mappings
  [NetAppCloudTarget <Boolean?>]: Only for snap copy. Enabling this changes SVM Mapping  to NetApp cloud targets only.
  [OptimizeForInstantClone <Boolean?>]: Flag to specify if primary storage is copy data management enabled.
  [OverrideRetentionSettings <Boolean?>]: Tells if this copy should use storage pool retention period days or the retention defined for this copy. Set as true to use retention defined on this copy.
  [RegionGuid <String>]: 
  [RegionId <Int64?>]: 
  [RegionName <String>]: 
  [RetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention. If this and snapRecoveryPoints both are not specified, this takes  precedence.
  [RetentionRuleType <String>]: Which type of retention rule should be used for the given backup destination
  [SecondExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [SecondExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [SecondExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [SnapRecoveryPoints <Int64?>]: Number of snap recovery points for snap copy for retention. Can be specified instead of retention period in Days for snap copy.
  [SourceCopyId <Int64?>]: 
  [SourceCopyName <String>]: 
  [StoragePoolId <Int64?>]: 
  [StoragePoolName <String>]: 
  [StorageTemplateTags <IIdNameValue[]>]: It is used in Global config template plan creation. Needs in plan creation on global commcell
    [Id <Int64?>]: 
    [Name <String>]: 
    [Value <String>]: 
  [StorageType <String>]: StorageType
  [ThirdExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [ThirdExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [ThirdExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [UseExtendedRetentionRules <Boolean?>]: Use extended retention rules

BACKUPFREQUENCYSCHEDULES <IPlanSchedule[]>: .
  BackupType <String>: Schedule Backup level
  SchedulePatternScheduleFrequencyType <String>: schedule frequency type
  [ForDatabasesOnly <Boolean?>]: Boolean to indicate if schedule is for database agents
  [IsRetentionBasedSyntheticFull <Boolean?>]: Boolean to indicate if synthetic full schedule is based on retention rules
  [PolicyId <Int64?>]: Schedule policy Id to which the schedule belongs
  [ScheduleId <Int64?>]: Id of the schedule if available, required for modifying, deleting schedule
  [ScheduleName <String>]: Name of the schedule, for modify
  [ScheduleOperation <String>]: Operation being performed on schedule
  [ScheduleOptionCommitFrequencyInHours <Int64?>]: Commit frequency in hours for disk cache backups from automatic schedules
  [ScheduleOptionDaysBetweenAutoConvert <Int64?>]: Number of days between auto conversion of backup level applicable for databases on incremental and differential schedules of server plan
  [ScheduleOptionJobRunningTimeInMins <Int64?>]: total job running time in minutes
  [ScheduleOptionLogFilesThreshold <Int64?>]: The min number of archived log files before a backup job should start
  [ScheduleOptionLogsDiskUtilizationPercent <Int64?>]: The min log destination disk threshold percentage
  [ScheduleOptionMinBackupIntervalInMins <Int64?>]: The min number of mins to check for file activity on automatic schedule.
  [ScheduleOptionO365ItemSelectionOption <String>]: item backup option for O365 V2 backup jobs
  [ScheduleOptionUseDiskCacheForLogBackups <Boolean?>]: Used to enable disk caching feature on databases for automatic schedules on server plan
  [SchedulePatternDayOfMonth <Int64?>]: Day on which to run the schedule, applicable for monthly, yearly
  [SchedulePatternDayOfWeek <String>]: 
  [SchedulePatternDaysBetweenSyntheticFulls <Int64?>]: No of days between two synthetic full jobs
  [SchedulePatternEndDate <Int64?>]: Schedule end date in epoch format
  [SchedulePatternExceptions <IScheduleRunException[]>]: Exceptions to when a schedule should not run, either in dates or week of month and days
    [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
    [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
    [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
  [SchedulePatternFrequency <Int64?>]: Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
  [SchedulePatternMaxBackupIntervalInMins <Int64?>]: The number of mins to force a backup on automatic schedule.
  [SchedulePatternMonthOfYear <String>]: 
  [SchedulePatternNoOfTimes <Int64?>]: The number of times you want the schedule to run.
  [SchedulePatternRepeatIntervalInMinutes <Int64?>]: How often in minutes in a day the schedule runs, applicable for daily, weekly, monthly and yearly frequency types.
  [SchedulePatternRepeatUntilTime <Int64?>]: Until what time to repeat the schedule in a day, requires repeatIntervalInMinutes
  [SchedulePatternStartDate <Int64?>]: start date of schedule in epoch format
  [SchedulePatternStartTime <Int64?>]: start time of schedule in seconds
  [SchedulePatternWeekOfMonth <String>]: Specific week of a month
  [SchedulePatternWeeklyDays <String[]>]: Days of the week for weekly frequency
  [TimezoneId <Int64?>]: 
  [TimezoneName <String>]: 
  [VMOperationType <String>]: Type of DR operation (only applicable for Failover groups)

RPOBACKUPWINDOW <IDayAndTime[]>: Backup window for incremental backup
  [DayOfWeek <String[]>]: 
  [EndTime <Int64?>]: Time in seconds since the beginning of the day
  [StartTime <Int64?>]: Time in seconds since the beginning of the day

RPOFULLBACKUPWINDOW <IDayAndTime[]>: Backup window for full backup
  [DayOfWeek <String[]>]: 
  [EndTime <Int64?>]: Time in seconds since the beginning of the day
  [StartTime <Int64?>]: Time in seconds since the beginning of the day
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvcdmplan
#>
function New-CVCdmPlan {
[OutputType([Commvault.Powershell.Models.IPlanResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICreatePlanBackupDestination[]]
    # Copy destinations for the plan.
    # Specify where you want to store your data.
    # To construct, see NOTES section for BACKUPDESTINATIONS properties and create a hash table.
    ${BackupDestinations},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the new plan
    ${PlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Operation type for the list
    ${BackupFrequencyOperationType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanSchedule[]]
    # .
    # To construct, see NOTES section for BACKUPFREQUENCYSCHEDULES properties and create a hash table.
    ${BackupFrequencySchedules},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Commit frequency in hours
    ${DatabaseOptionCommitFrequencyInHours},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Log backup RPO in minutes
    ${DatabaseOptionLogBackupRpoMins},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Use disk cache for log backups
    ${DatabaseOptionUseDiskCacheForLogBackups},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDayAndTime[]]
    # Backup window for incremental backup
    # To construct, see NOTES section for RPOBACKUPWINDOW properties and create a hash table.
    ${RpoBackupWindow},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDayAndTime[]]
    # Backup window for full backup
    # To construct, see NOTES section for RPOFULLBACKUPWINDOW properties and create a hash table.
    ${RpoFullBackupWindow},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Backup copy RPO in minutes
    ${SnapshotOptionBackupCopyRpoMins},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to enable backup copy
    ${SnapshotOptionEnableBackupCopy},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Retention period in days.
    # -1 can be specified for infinite retention.
    # If this and snapRecoveryPoints both are not specified, this takes precedence.
    ${SnapshotOptionRetentionPeriodDays},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of snap recovery points for default snap copy for retention.
    # Can be specified instead of retention period in Days for default snap copy.
    ${SnapshotOptionSnapRecoveryPoints},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVCdmPlan_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Add metadata cache paths to storage
.Description
Add metadata cache paths to storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvcloudstoragemetadatacache
#>
function New-CVCloudStorageMetaDataCache {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of cloud Storage
    ${CloudStorageId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Metadata cache will be stored on this path
    ${Path},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # username to access the network path
    ${CredentialsName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # password to access the network path
    ${CredentialsPassword},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${MediaAgentId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${MediaAgentName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SavedCredentialsId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SavedCredentialsName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVCloudStorageMetaDataCache_CreateExpanded';
            CreateViaIdentityExpanded = 'CommvaultPowershell.private\New-CVCloudStorageMetaDataCache_CreateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a Company
.Description
Create a Company
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IIdName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

PLANS <IIdName[]>: Select data protection plans to use for the company. The plans that are selected are the plans that the tenant administrator can choose from.
  [Id <Int64?>]: 
  [Name <String>]: 

SERVICECOMMCELLS <IIdName[]>: Used to add service commcells to the master commcell. Either id or name can be provided. If both are provided, id will be taken into consideration.
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvcompany
#>
function New-CVCompany {
[OutputType([Commvault.Powershell.Models.IIdName])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The company domain or NetBIOS name
    ${Alias},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # name of the company to be created.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the tenant administrator.
    # If provided, email also needs to be provided.
    ${ContactName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Email address for the tenant administrator.
    # If provided, contactName for the tenant administrator also needs to be provided
    ${Email},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Supported domains for the company
    ${EmailSuffix},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Select data protection plans to use for the company.
    # The plans that are selected are the plans that the tenant administrator can choose from.
    # To construct, see NOTES section for PLANS properties and create a hash table.
    ${Plans},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The primary domain name of the company being created.
    # Can be added only if an external domain is already present.
    ${PrimaryDomain},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # send a welcome email on company creation to the tenant administrator.
    ${SendWelcomeEmail},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Used to add service commcells to the master commcell.
    # Either id or name can be provided.
    # If both are provided, id will be taken into consideration.
    # To construct, see NOTES section for SERVICECOMMCELLS properties and create a hash table.
    ${ServiceCommcells},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVCompany_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to create CVFS S3 bucket and assigns READ-WRITE permission to the requesting user
.Description
Used to create CVFS S3 bucket and assigns READ-WRITE permission to the requesting user
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.ICreateCvfss3BucketResp
.Outputs
Commvault.Powershell.Models.IGenericResponse
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvcvfs3bucket
#>
function New-CVCvfS3Bucket {
[OutputType([Commvault.Powershell.Models.ICreateCvfss3BucketResp], [Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The name of the CVFS S3 bucket to be created
    ${Name},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Plan name to be used to fetch the CVFS S3 cluster
    ${PlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The size of the bucket in GB
    ${BucketSize},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # To enable/suspend the versioning on the CVFS S3 bucket
    ${Versioning},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVCvfS3Bucket_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create Dynamics 365 app
.Description
Create Dynamics 365 app
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IIdName
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvd365client
#>
function New-CVD365Client {
[OutputType([Commvault.Powershell.Models.IIdName])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure Application ID
    ${AzureAppApplicationId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure app secret key, needs to be base64 encoded
    ${AzureAppApplicationSecret},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure directory (tenant) ID
    ${AzureAppAzureDirectoryId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Unique Dynamics365 app name
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # User based refresh token generated with corresponding app credentials.
    # Can be left blank if the azure app is protected API approved.
    ${AzureAppRefreshToken},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${ServerPlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ServerPlanName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVD365Client_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a Data Classification Plan
.Description
Create a Data Classification Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IPlanResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTENTANALYZER <IIdName[]>: Content Analyzer Id`s for Entity Detection
  [Id <Int64?>]: 
  [Name <String>]: 

CONTENTINDEXINGBACKUPCOPY <IDcBackupCopy[]>: .
  [CopyId <Int64?>]: 
  [StoragePoolId <Int64?>]: 

ENTITYDETECTIONCLASSIFIERS <IIdName[]>: Classifier TagId For Extraction
  [Id <Int64?>]: 
  [Name <String>]: 

ENTITYDETECTIONENTITIES <IIdName[]>: Entity TagId for Extraction
  [Id <Int64?>]: 
  [Name <String>]: 

PATTERNEXCEPTIONS <IScheduleRunException[]>: Exceptions to when a schedule should not run, either in dates or week of month and day
  [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
  [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
  [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvdcplan
#>
function New-CVDcPlan {
[OutputType([Commvault.Powershell.Models.IPlanResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Content indexing target app
    ${Application},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Content Analyzer Id`s for Entity Detection
    # To construct, see NOTES section for CONTENTANALYZER properties and create a hash table.
    ${ContentAnalyzer},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDcBackupCopy[]]
    # .
    # To construct, see NOTES section for CONTENTINDEXINGBACKUPCOPY properties and create a hash table.
    ${ContentIndexingBackupCopy},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # OCR Languages Supported By DC Plan
    ${ContentIndexingContentLanguage},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Set Content Indexing Copy Precedence
    ${ContentIndexingCopyPrecedence},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable Exact Seach in Data Classification Plan
    ${ContentIndexingExactSearch},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable OCR in Data Classification Plan
    ${ContentIndexingExtractTextFromImage},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Classifier TagId For Extraction
    # To construct, see NOTES section for ENTITYDETECTIONCLASSIFIERS properties and create a hash table.
    ${EntityDetectionClassifiers},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${EntityDetectionCopyPrecendence},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Entity TagId for Extraction
    # To construct, see NOTES section for ENTITYDETECTIONENTITIES properties and create a hash table.
    ${EntityDetectionEntities},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # .
    ${FileFilterExcludePaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${FileFilterIncludeDocTypes},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${FileFilterMaxDocSize},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${FileFilterMinDocSize},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${IndexServerId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${IndexServerName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of Data Classification Plan
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Day on which to run the schedule, applicable for monthly, yearly
    ${PatternDayOfMonth},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PatternDayOfWeek},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IScheduleRunException[]]
    # Exceptions to when a schedule should not run, either in dates or week of month and day
    # To construct, see NOTES section for PATTERNEXCEPTIONS properties and create a hash table.
    ${PatternExceptions},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Frequency of the schedule based on schedule frequency type eg.
    # for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days.
    # for Monthly 2 is it repeats every 2 months
    ${PatternFrequency},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PatternMonthOfYear},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # schedule frequency type
    ${PatternScheduleFrequencyType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # start date of schedule in epoch format
    ${PatternStartDate},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # start time of schedule in seconds for daily, weekly, monthly, yearly frequency
    ${PatternStartTime},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specific week of a month
    ${PatternWeekOfMonth},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Days of the week for weekly frequency
    ${PatternWeeklyDays},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ScheduleName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Enables\Disables Threat Analysis support for DC Plan
    ${ThreatAnalysis},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVDcPlan_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a new disk storage pool
.Description
Create a new disk storage pool
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IIdName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

DEDUPLICATIONDBSTORAGE <IDedupePath[]>: A list of dedupe locations can be provided for the storage pool being created. This provides an efficient way to save/store data by eliminating duplicate blocks of data during backups.
  [MediaAgentId <Int64?>]: 
  [MediaAgentName <String>]: 
  [Path <String>]: 

STORAGE <IPath[]>: A list of backup locations can be provided for the storage pool being created.
  [BackupLocation <String>]: 
  [CredentialsName <String>]: username to access the network path
  [CredentialsPassword <String>]: password to access the network path
  [MediaAgentId <Int64?>]: 
  [MediaAgentName <String>]: 
  [SavedCredentialsId <Int64?>]: 
  [SavedCredentialsName <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvdiskstorage
#>
function New-CVDiskStorage {
[OutputType([Commvault.Powershell.Models.IIdName])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # enables or disables deduplication
    ${EnableDeduplication},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the Disk Storage to be created.
    ${Name},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPath[]]
    # A list of backup locations can be provided for the storage pool being created.
    # To construct, see NOTES section for STORAGE properties and create a hash table.
    ${Storage},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDedupePath[]]
    # A list of dedupe locations can be provided for the storage pool being created.
    # This provides an efficient way to save/store data by eliminating duplicate blocks of data during backups.
    # To construct, see NOTES section for DEDUPLICATIONDBSTORAGE properties and create a hash table.
    ${DeduplicationDbStorage},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVDiskStorage_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create Office 365 Exchange Online app
.Description
Create Office 365 Exchange Online app
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IIdName
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvexchangeclient
#>
function New-CVExchangeClient {
[OutputType([Commvault.Powershell.Models.IIdName], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure Application ID
    ${AzureAppApplicationId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure app secret key, needs to be base64 encoded
    ${AzureAppApplicationSecret},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure directory (tenant) ID
    ${AzureAppAzureDirectoryId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Unique Exchange app name
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${ServerPlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ServerPlanName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVExchangeClient_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to create failover group DR operation schedule
.Description
API to create failover group DR operation schedule
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IPlanSchedule
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

SCHEDULEPATTERNEXCEPTIONS <IScheduleRunException[]>: Exceptions to when a schedule should not run, either in dates or week of month and days
  [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
  [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
  [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvfailovergroupschedule
#>
function New-CVFailoverGroupSchedule {
[OutputType([Commvault.Powershell.Models.IPlanSchedule], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the failover group
    ${FailoverGroupId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Schedule Backup level
    ${BackupType},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # schedule frequency type
    ${SchedulePatternScheduleFrequencyType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean to indicate if schedule is for database agents
    ${ForDatabasesOnly},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean to indicate if synthetic full schedule is based on retention rules
    ${IsRetentionBasedSyntheticFull},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Schedule policy Id to which the schedule belongs
    ${PolicyId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Id of the schedule if available, required for modifying, deleting schedule
    ${ScheduleId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the schedule, for modify
    ${ScheduleName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Operation being performed on schedule
    ${ScheduleOperation},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Commit frequency in hours for disk cache backups from automatic schedules
    ${ScheduleOptionCommitFrequencyInHours},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of days between auto conversion of backup level applicable for databases on incremental and differential schedules of server plan
    ${ScheduleOptionDaysBetweenAutoConvert},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # total job running time in minutes
    ${ScheduleOptionJobRunningTimeInMins},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The min number of archived log files before a backup job should start
    ${ScheduleOptionLogFilesThreshold},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The min log destination disk threshold percentage
    ${ScheduleOptionLogsDiskUtilizationPercent},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The min number of mins to check for file activity on automatic schedule.
    ${ScheduleOptionMinBackupIntervalInMins},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # item backup option for O365 V2 backup jobs
    ${ScheduleOptionO365ItemSelectionOption},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Used to enable disk caching feature on databases for automatic schedules on server plan
    ${ScheduleOptionUseDiskCacheForLogBackups},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Day on which to run the schedule, applicable for monthly, yearly
    ${SchedulePatternDayOfMonth},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SchedulePatternDayOfWeek},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # No of days between two synthetic full jobs
    ${SchedulePatternDaysBetweenSyntheticFulls},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Schedule end date in epoch format
    ${SchedulePatternEndDate},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IScheduleRunException[]]
    # Exceptions to when a schedule should not run, either in dates or week of month and days
    # To construct, see NOTES section for SCHEDULEPATTERNEXCEPTIONS properties and create a hash table.
    ${SchedulePatternExceptions},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Frequency of the schedule based on schedule frequency type eg.
    # for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days.
    # for Monthly 2 is it repeats every 2 months
    ${SchedulePatternFrequency},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The number of mins to force a backup on automatic schedule.
    ${SchedulePatternMaxBackupIntervalInMins},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SchedulePatternMonthOfYear},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The number of times you want the schedule to run.
    ${SchedulePatternNoOfTimes},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # How often in minutes in a day the schedule runs, applicable for daily, weekly, monthly and yearly frequency types.
    ${SchedulePatternRepeatIntervalInMinutes},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Until what time to repeat the schedule in a day, requires repeatIntervalInMinutes
    ${SchedulePatternRepeatUntilTime},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # start date of schedule in epoch format
    ${SchedulePatternStartDate},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # start time of schedule in seconds
    ${SchedulePatternStartTime},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specific week of a month
    ${SchedulePatternWeekOfMonth},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Days of the week for weekly frequency
    ${SchedulePatternWeeklyDays},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${TimezoneId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${TimezoneName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Type of DR operation (only applicable for Failover groups)
    ${VMOperationType},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVFailoverGroupSchedule_CreateExpanded';
            CreateViaIdentityExpanded = 'CommvaultPowershell.private\New-CVFailoverGroupSchedule_CreateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a Global Server Plan
.Description
Create a Global Server Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IPlanResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

GLOBALCONFIGINFOCOMMCELLS <IGlobalConfigCommcellInfo[]>: List of Service CommCells where the global configuration should be applied
  [Guid <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 

PLAN <ICreateServerPlan>: .
  PlanName <String>: Name of the new plan
  [AdditionalPropertyRpo <Int64?>]: The least RPO in minutes for the plan
  [AdditionalPropertyStatus <String>]: status if plan backups are enabled or disabled
  [AddonDatabase <Boolean?>]: Database options should be shown with this plan
  [AddonFileSystem <Boolean?>]: File system options should be shown with this plan
  [AddonIndexCopy <Boolean?>]: Index copy options should be shown with this plan
  [AddonSnap <Boolean?>]: Snap options should be shown with this plan
  [AddonSnapStatus <String>]: 
  [AllowPlanOverride <Boolean?>]: Flag to enable overriding of plan. Plan cannot be overriden by default.
  [BackupContentBackupSystemState <Boolean?>]: Do you want to back up the system state? Applicable only for Windows
  [BackupContentBackupSystemStateOnlyWithFullBackup <Boolean?>]: Do you want to back up system state only with full backup? Applicable only if the value of backupSystemState is true
  [BackupContentForceUpdateProperties <Boolean?>]: Do you want to sync properties on associated subclients even if properties are overriden at subclient level?
  [BackupContentMacExcludedPaths <String[]>]: Paths to exclude for Mac
  [BackupContentMacFilterToExcludePaths <String[]>]: Paths that are exception to excluded paths for Mac
  [BackupContentMacIncludedPaths <String[]>]: Paths to include for Mac
  [BackupContentUnixExcludedPaths <String[]>]: Paths to exclude for UNIX
  [BackupContentUnixFilterToExcludePaths <String[]>]: Paths that are exception to excluded paths for Unix
  [BackupContentUnixIncludedPaths <String[]>]: Paths to include for UNIX
  [BackupContentUseVssForSystemState <Boolean?>]: Do you want to back up system state with VSS? Applicable only if the value of backupSystemState is true
  [BackupContentWindowsExcludedPaths <String[]>]: Paths to exclude for Windows
  [BackupContentWindowsFilterToExcludePaths <String[]>]: Paths that are exception to excluded paths for Windows
  [BackupContentWindowsIncludedPaths <String[]>]: Paths to include for Windows
  [BackupDestinationIds <Int64[]>]: Primary Backup Destination Ids (which were created before plan creation). This is only considered when backupDestinations array object is not defined.
  [BackupDestinations <ICreatePlanBackupDestination[]>]: Backup destinations for the plan. Specify where you want to store your backup data.
    BackupDestinationName <String>: Backup destination details. Enter the name during creation.
    [BackupStartTime <Int64?>]: Backup start time in seconds. The time is provided in unix time format.
    [BackupsToCopy <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    [FirstExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
    [FirstExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
    [FirstExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    [FullBackupTypesToCopy <String>]: Which type of backup type should be copied for the given backup destination when backup type is not all jobs. Default is LAST while adding new backup destination.
    [IsConfiguredForReplication <Boolean?>]: Used if the copy is used for replication group
    [IsMirrorCopy <Boolean?>]: Is this a mirror copy? Only considered when isSnapCopy is true.
    [IsSnapCopy <Boolean?>]: Is this a snap copy? If isMirrorCopy is not set, then default is Vault/Replica.
    [Mappings <ISnapshotCopyMapping[]>]: 
      [SourceId <Int64?>]: 
      [SourceName <String>]: 
      [SourceVendorId <Int64?>]: 
      [SourceVendorName <String>]: 
      [TargetId <Int64?>]: 
      [TargetName <String>]: 
      [TargetVendorId <Int64?>]: 
      [TargetVendorName <String>]: 
      [Vendor <String>]: Snapshot vendors available for Snap Copy mappings
    [NetAppCloudTarget <Boolean?>]: Only for snap copy. Enabling this changes SVM Mapping  to NetApp cloud targets only.
    [OptimizeForInstantClone <Boolean?>]: Flag to specify if primary storage is copy data management enabled.
    [OverrideRetentionSettings <Boolean?>]: Tells if this copy should use storage pool retention period days or the retention defined for this copy. Set as true to use retention defined on this copy.
    [RegionGuid <String>]: 
    [RegionId <Int64?>]: 
    [RegionName <String>]: 
    [RetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention. If this and snapRecoveryPoints both are not specified, this takes  precedence.
    [RetentionRuleType <String>]: Which type of retention rule should be used for the given backup destination
    [SecondExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
    [SecondExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
    [SecondExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    [SnapRecoveryPoints <Int64?>]: Number of snap recovery points for snap copy for retention. Can be specified instead of retention period in Days for snap copy.
    [SourceCopyId <Int64?>]: 
    [SourceCopyName <String>]: 
    [StoragePoolId <Int64?>]: 
    [StoragePoolName <String>]: 
    [StorageTemplateTags <IIdNameValue[]>]: It is used in Global config template plan creation. Needs in plan creation on global commcell
      [Id <Int64?>]: 
      [Name <String>]: 
      [Value <String>]: 
    [StorageType <String>]: StorageType
    [ThirdExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
    [ThirdExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
    [ThirdExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
    [UseExtendedRetentionRules <Boolean?>]: Use extended retention rules
  [BackupFrequencyOperationType <String>]: Operation type for the list
  [BackupFrequencySchedules <IPlanSchedule[]>]: 
    BackupType <String>: Schedule Backup level
    SchedulePatternScheduleFrequencyType <String>: schedule frequency type
    [ForDatabasesOnly <Boolean?>]: Boolean to indicate if schedule is for database agents
    [IsRetentionBasedSyntheticFull <Boolean?>]: Boolean to indicate if synthetic full schedule is based on retention rules
    [PolicyId <Int64?>]: Schedule policy Id to which the schedule belongs
    [ScheduleId <Int64?>]: Id of the schedule if available, required for modifying, deleting schedule
    [ScheduleName <String>]: Name of the schedule, for modify
    [ScheduleOperation <String>]: Operation being performed on schedule
    [ScheduleOptionCommitFrequencyInHours <Int64?>]: Commit frequency in hours for disk cache backups from automatic schedules
    [ScheduleOptionDaysBetweenAutoConvert <Int64?>]: Number of days between auto conversion of backup level applicable for databases on incremental and differential schedules of server plan
    [ScheduleOptionJobRunningTimeInMins <Int64?>]: total job running time in minutes
    [ScheduleOptionLogFilesThreshold <Int64?>]: The min number of archived log files before a backup job should start
    [ScheduleOptionLogsDiskUtilizationPercent <Int64?>]: The min log destination disk threshold percentage
    [ScheduleOptionMinBackupIntervalInMins <Int64?>]: The min number of mins to check for file activity on automatic schedule.
    [ScheduleOptionO365ItemSelectionOption <String>]: item backup option for O365 V2 backup jobs
    [ScheduleOptionUseDiskCacheForLogBackups <Boolean?>]: Used to enable disk caching feature on databases for automatic schedules on server plan
    [SchedulePatternDayOfMonth <Int64?>]: Day on which to run the schedule, applicable for monthly, yearly
    [SchedulePatternDayOfWeek <String>]: 
    [SchedulePatternDaysBetweenSyntheticFulls <Int64?>]: No of days between two synthetic full jobs
    [SchedulePatternEndDate <Int64?>]: Schedule end date in epoch format
    [SchedulePatternExceptions <IScheduleRunException[]>]: Exceptions to when a schedule should not run, either in dates or week of month and days
      [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
      [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
      [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
    [SchedulePatternFrequency <Int64?>]: Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
    [SchedulePatternMaxBackupIntervalInMins <Int64?>]: The number of mins to force a backup on automatic schedule.
    [SchedulePatternMonthOfYear <String>]: 
    [SchedulePatternNoOfTimes <Int64?>]: The number of times you want the schedule to run.
    [SchedulePatternRepeatIntervalInMinutes <Int64?>]: How often in minutes in a day the schedule runs, applicable for daily, weekly, monthly and yearly frequency types.
    [SchedulePatternRepeatUntilTime <Int64?>]: Until what time to repeat the schedule in a day, requires repeatIntervalInMinutes
    [SchedulePatternStartDate <Int64?>]: start date of schedule in epoch format
    [SchedulePatternStartTime <Int64?>]: start time of schedule in seconds
    [SchedulePatternWeekOfMonth <String>]: Specific week of a month
    [SchedulePatternWeeklyDays <String[]>]: Days of the week for weekly frequency
    [TimezoneId <Int64?>]: 
    [TimezoneName <String>]: 
    [VMOperationType <String>]: Type of DR operation (only applicable for Failover groups)
  [DatabaseOptionCommitFrequencyInHours <Int64?>]: Commit frequency in hours
  [DatabaseOptionLogBackupRpoMins <Int64?>]: Log backup RPO in minutes
  [DatabaseOptionUseDiskCacheForLogBackups <Boolean?>]: Use disk cache for log backups
  [FileSearchEnabled <Boolean?>]: Flag for enabling indexing
  [FileSearchErrors <IPlanFileSearchSetupError[]>]: File search was enabled on plan but failed to process some of the storage pool(s) with these errors
    [ErrorCode <Int64?>]: 
    [ErrorMessage <String>]: Tells about the error occured during file search setup for given storage pool
    [StorageId <Int64?>]: 
    [StorageName <String>]: 
  [FileSearchStatus <String>]: Type of indexing status.
  [FileSearchStatusMessage <String>]: Tells what is happening behind the scene, so that user can knows why indexing is not enabled or if its in progress
  [FilesystemAddon <Boolean?>]: flag to enable backup content association for applicable file system workload.
  [MacNumberOfDataReaderCount <Int64?>]: Number of data readers.
  [MacNumberOfDataReaderUseOptimal <Boolean?>]: Set optimal number of data readers. if it is set to true, count will be ignored.
  [OverrideRestrictionBackupContent <String>]: 
  [OverrideRestrictionRpo <String>]: 
  [OverrideRestrictionStoragePool <String>]: 
  [ParentPlanId <Int64?>]: 
  [ParentPlanName <String>]: 
  [RpoBackupWindow <IDayAndTime[]>]: Backup window for incremental backup
    [DayOfWeek <String[]>]: 
    [EndTime <Int64?>]: Time in seconds since the beginning of the day
    [StartTime <Int64?>]: Time in seconds since the beginning of the day
  [RpoFullBackupWindow <IDayAndTime[]>]: Backup window for full backup
  [SettingEnableAdvancedView <Boolean?>]: Setting to suggest plan has some advanced settings present. Setting is OEM specific and not applicable for all cases.
  [SnapshotOptionBackupCopyRpoMins <Int64?>]: Backup copy RPO in minutes
  [SnapshotOptionEnableBackupCopy <Boolean?>]: Flag to enable backup copy
  [SnapshotOptionRetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention. If this and snapRecoveryPoints both are not specified, this takes precedence.
  [SnapshotOptionSnapRecoveryPoints <Int64?>]: Number of snap recovery points for default snap copy for retention. Can be specified instead of retention period in Days for default snap copy.
  [UnixNumberOfDataReaderCount <Int64?>]: Number of data readers.
  [UnixNumberOfDataReaderUseOptimal <Boolean?>]: Set optimal number of data readers. if it is set to true, count will be ignored.
  [WindowNumberOfDataReaderCount <Int64?>]: Number of data readers.
  [WindowNumberOfDataReaderUseOptimal <Boolean?>]: Set optimal number of data readers. if it is set to true, count will be ignored.
  [WorkloadGroupTypes <String[]>]: 
  [WorkloadSolutions <IIdName[]>]: 
    [Id <Int64?>]: 
    [Name <String>]: 
  [WorkloadTypes <IIdName[]>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvglobalserverplan
#>
function New-CVGlobalServerPlan {
[OutputType([Commvault.Powershell.Models.IPlanResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Action that will be taken on the local entity that has the same name as the global entity that needs to be created
    ${GlobalConfigInfoActionOnLocalEntity},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Decides whether the global configuration should be applied to all the Service commcells, including the newly created ones
    ${GlobalConfigInfoApplyOnAllCommCells},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IGlobalConfigCommcellInfo[]]
    # List of Service CommCells where the global configuration should be applied
    # To construct, see NOTES section for GLOBALCONFIGINFOCOMMCELLS properties and create a hash table.
    ${GlobalConfigInfoCommcells},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${GlobalConfigInfoName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The entity level at which the config has to be applied.
    ${GlobalConfigInfoScope},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # CommCellEntityCache filter query string using for filtering the scope
    ${GlobalConfigInfoScopeFilterQuery},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICreateServerPlan]
    # .
    # To construct, see NOTES section for PLAN properties and create a hash table.
    ${Plan},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVGlobalServerPlan_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a HyperScale Storage
.Description
Create a HyperScale Storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IHyperScaleStorageResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

NODES <IIdName[]>: List of Nodes (MediaAgents) of the HyperScale Storage
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvhyperscalestorage
#>
function New-CVHyperScaleStorage {
[OutputType([Commvault.Powershell.Models.IHyperScaleStorageResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of HyperScale Storage
    ${Name},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # List of Nodes (MediaAgents) of the HyperScale Storage
    # To construct, see NOTES section for NODES properties and create a hash table.
    ${Nodes},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVHyperScaleStorage_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Creating a new inventory
.Description
Creating a new inventory
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IIdName
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvinventory
#>
function New-CVInventory {
[OutputType([Commvault.Powershell.Models.IIdName], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the inventory
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # List of AD servers to be analyzed
    ${IdentityServers},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Id of the index server cloud
    ${IndexServerCloudId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Display name for the index server
    ${IndexServerDisplayName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${IndexServerId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${IndexServerName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Operating system of the index server
    ${IndexServerOS},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVInventory_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a Modifier
.Description
Create a Modifier
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IK8SRestoreModifierApireq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IK8SRestoreModifierApireq>: Request body for K8s Modifier
  [ModifierYaml <String>]: Restore Modifier YAML

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvk8smodifier
#>
function New-CVK8SModifier {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='NewExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='New', Mandatory)]
    [Parameter(ParameterSetName='NewExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the cluster whose modifier has to be created.
    ${ClusterId},

    [Parameter(ParameterSetName='NewViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='NewViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='New', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='NewViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IK8SRestoreModifierApireq]
    # Request body for K8s Modifier
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='NewExpanded')]
    [Parameter(ParameterSetName='NewViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Restore Modifier YAML
    ${ModifierYaml},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            New = 'CommvaultPowershell.private\New-CVK8SModifier_New';
            NewExpanded = 'CommvaultPowershell.private\New-CVK8SModifier_NewExpanded';
            NewViaIdentity = 'CommvaultPowershell.private\New-CVK8SModifier_NewViaIdentity';
            NewViaIdentityExpanded = 'CommvaultPowershell.private\New-CVK8SModifier_NewViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to create new Kubernetes application group
.Description
API to create new Kubernetes application group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IIdName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTENTAPPLICATIONS <IKubernetesContentApplications[]>: List of applications to be added as content
  Guid <String>: GUID value of the Kubernetes Application to be associated as content
  Type <String>: Type of the Kubernetes application
  [Name <String>]: Name of the application

CONTENTLABELSELECTORS <IKubernetesContentSelectors[]>: List of label selectors to be added as content
  SelectorLevel <String>: Selector level of the label selector
  SelectorValue <String>: Value of the label selector in key=value format

FILTERAPPLICATIONS <IKubernetesContentApplications[]>: List of applications to be added as content
  Guid <String>: GUID value of the Kubernetes Application to be associated as content
  Type <String>: Type of the Kubernetes application
  [Name <String>]: Name of the application

FILTERLABELSELECTORS <IKubernetesContentSelectors[]>: List of label selectors to be added as content
  SelectorLevel <String>: Selector level of the label selector
  SelectorValue <String>: Value of the label selector in key=value format
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvkuberneteapplicationgroup
#>
function New-CVKuberneteApplicationGroup {
[OutputType([Commvault.Powershell.Models.IIdName], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${ClusterId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ClusterName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IKubernetesContentApplications[]]
    # List of applications to be added as content
    # To construct, see NOTES section for CONTENTAPPLICATIONS properties and create a hash table.
    ${ContentApplications},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IKubernetesContentSelectors[]]
    # List of label selectors to be added as content
    # To construct, see NOTES section for CONTENTLABELSELECTORS properties and create a hash table.
    ${ContentLabelSelectors},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Specifies whether content has to be overwritten or appended
    ${ContentOverwrite},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IKubernetesContentApplications[]]
    # List of applications to be added as content
    # To construct, see NOTES section for FILTERAPPLICATIONS properties and create a hash table.
    ${FilterApplications},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IKubernetesContentSelectors[]]
    # List of label selectors to be added as content
    # To construct, see NOTES section for FILTERLABELSELECTORS properties and create a hash table.
    ${FilterLabelSelectors},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Specifies whether content has to be overwritten or appended
    ${FilterOverwrite},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Specify whether to skip backup of stateless applications
    ${FilterSkipStatelessApps},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify new name to rename an Application Group
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVKuberneteApplicationGroup_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to create new Kubernetes cluster client
.Description
API to create new Kubernetes cluster client
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.ICreateKubernetesClusterResponse
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ACCESSNODES <IIdNameType[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
  [Type <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvkuberneteclusterop
#>
function New-CVKuberneteClusterOp {
[OutputType([Commvault.Powershell.Models.ICreateKubernetesClusterResponse], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the Kubernetes Cluster
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdNameType[]]
    # .
    # To construct, see NOTES section for ACCESSNODES properties and create a hash table.
    ${AccessNodes},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # API Server Endpoint of the cluster
    ${ApiServer},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Denote if etcd protection is enabled
    ${EtcdProtectionEnabled},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the Service Account to authenticate with the cluster
    ${ServiceAccount},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Secret token to authenticate with the cluster
    ${ServiceToken},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The Service Type of the Kubernetes cluster
    ${ServiceType},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVKuberneteClusterOp_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create Kubernetes cluster
.Description
Create Kubernetes cluster
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.ICreateClusterResp
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ACCESSNODES <IAccessNodeModel[]>: .
  [DisplayName <String>]: Display name of the access node
  [Id <Int64?>]: 
  [Name <String>]: 
  [Type <Int64?>]: Type of access node , Ex: 3 - access Node , 28 - Access Node Groups
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvkubernetescluster
#>
function New-CVKubernetescluster {
[OutputType([Commvault.Powershell.Models.ICreateClusterResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${CredentialsName},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Endpoint url to connect
    ${Endpointurl},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The name of the hypervisor group being created
    ${Name},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanEntityName},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAccessNodeModel[]]
    # .
    # To construct, see NOTES section for ACCESSNODES properties and create a hash table.
    ${AccessNodes},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${CredentialsId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Denote if etcd protection is enabled
    ${EtcdProtectionEnabled},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${K8ServiceType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Username to connect in case authentication mode is Username and password
    ${Password},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${PlanEntityId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # SecretKey to connect in case authentication mode is service account
    ${SecretKey},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Service Name to connect in case authentication mode is service account
    ${ServiceName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # if credential validation has to be skipped.
    ${SkipCredentialValidation},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Username to connect in case authentication mode is Username and password
    ${UserName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVKubernetescluster_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a Backup Destination for a Plan
.Description
Create a Backup Destination for a Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IPlanBackupDestinationResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

DESTINATIONS <ICreatePlanBackupDestination[]>: List of backup destinations to create
  BackupDestinationName <String>: Backup destination details. Enter the name during creation.
  [BackupStartTime <Int64?>]: Backup start time in seconds. The time is provided in unix time format.
  [BackupsToCopy <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [FirstExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [FirstExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [FirstExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [FullBackupTypesToCopy <String>]: Which type of backup type should be copied for the given backup destination when backup type is not all jobs. Default is LAST while adding new backup destination.
  [IsConfiguredForReplication <Boolean?>]: Used if the copy is used for replication group
  [IsMirrorCopy <Boolean?>]: Is this a mirror copy? Only considered when isSnapCopy is true.
  [IsSnapCopy <Boolean?>]: Is this a snap copy? If isMirrorCopy is not set, then default is Vault/Replica.
  [Mappings <ISnapshotCopyMapping[]>]: 
    [SourceId <Int64?>]: 
    [SourceName <String>]: 
    [SourceVendorId <Int64?>]: 
    [SourceVendorName <String>]: 
    [TargetId <Int64?>]: 
    [TargetName <String>]: 
    [TargetVendorId <Int64?>]: 
    [TargetVendorName <String>]: 
    [Vendor <String>]: Snapshot vendors available for Snap Copy mappings
  [NetAppCloudTarget <Boolean?>]: Only for snap copy. Enabling this changes SVM Mapping  to NetApp cloud targets only.
  [OptimizeForInstantClone <Boolean?>]: Flag to specify if primary storage is copy data management enabled.
  [OverrideRetentionSettings <Boolean?>]: Tells if this copy should use storage pool retention period days or the retention defined for this copy. Set as true to use retention defined on this copy.
  [RegionGuid <String>]: 
  [RegionId <Int64?>]: 
  [RegionName <String>]: 
  [RetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention. If this and snapRecoveryPoints both are not specified, this takes  precedence.
  [RetentionRuleType <String>]: Which type of retention rule should be used for the given backup destination
  [SecondExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [SecondExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [SecondExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [SnapRecoveryPoints <Int64?>]: Number of snap recovery points for snap copy for retention. Can be specified instead of retention period in Days for snap copy.
  [SourceCopyId <Int64?>]: 
  [SourceCopyName <String>]: 
  [StoragePoolId <Int64?>]: 
  [StoragePoolName <String>]: 
  [StorageTemplateTags <IIdNameValue[]>]: It is used in Global config template plan creation. Needs in plan creation on global commcell
    [Id <Int64?>]: 
    [Name <String>]: 
    [Value <String>]: 
  [StorageType <String>]: StorageType
  [ThirdExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [ThirdExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [ThirdExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [UseExtendedRetentionRules <Boolean?>]: Use extended retention rules

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvlaptopbackupdestination
#>
function New-CVLaptopBackupDestination {
[OutputType([Commvault.Powershell.Models.IPlanBackupDestinationResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to modify
    ${PlanId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICreatePlanBackupDestination[]]
    # List of backup destinations to create
    # To construct, see NOTES section for DESTINATIONS properties and create a hash table.
    ${Destinations},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RegionGuid},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RegionId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RegionName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Backup copy RPO in minutes
    ${SnapshotOptionBackupCopyRpoMins},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to enable backup copy
    ${SnapshotOptionEnableBackupCopy},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Retention period in days.
    # -1 can be specified for infinite retention.
    # If this and snapRecoveryPoints both are not specified, this takes precedence.
    ${SnapshotOptionRetentionPeriodDays},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of snap recovery points for default snap copy for retention.
    # Can be specified instead of retention period in Days for default snap copy.
    ${SnapshotOptionSnapRecoveryPoints},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVLaptopBackupDestination_CreateExpanded';
            CreateViaIdentityExpanded = 'CommvaultPowershell.private\New-CVLaptopBackupDestination_CreateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create Laptop Plan
.Description
Create Laptop Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IPlanResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ALERTS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 

ALLOWEDFEATURES <ILaptopPlanAllowedFeatures>: Create/modify allowed features of laptop plan
  [Archiving <Boolean?>]: Flag to enable archiving of laptop data
  [ArchivingRuleAfterArchiving <String>]: After an archive job, replace the file that meets the archiving rules with a stub or delete the file that meets the archiving rules
  [ArchivingRuleArchiveReadOnlyFiles <Boolean?>]: To archive files based on the Read-Only attribute, set to TRUE
  [ArchivingRuleFileAccessTimeOlderThan <Int64?>]: To archive files based on the last accessed date of each file within the folder, specify the number of days
  [ArchivingRuleFileCreatedTimeOlderThan <Int64?>]: To archive files based on the time the files were created within the folder, specify the number of days
  [ArchivingRuleFileModifiedTimeOlderThan <Int64?>]: To archive files based on the last modified date of each file within the folder, specify the number of days
  [ArchivingRuleFileSizeGreaterThan <Int64?>]: To archive files based on the size of the file, specify the minimum file size in KB. All files whose size ranges between the minimum and maximum values are archived.
  [ArchivingRuleMaximumFileSize <Int64?>]: To archive files based on the size of the file, specify the maximum file size in KB. All files whose size ranges between the minimum and maximum values are archived.
  [ArchivingRuleStartCleaningIfLessThan <Int64?>]: When free disk space falls below specified amount (in percentage), start cleaning up the disk
  [ArchivingRuleStopCleaningIfupto <Int64?>]: When free disk space more than specified amount (in percentage), stop cleaning up the disk
  [ClientId <Int64?>]: 
  [ClientName <String>]: 
  [Dlp <Boolean?>]: Flag to enable Data loss protection
  [EdgeDrive <Boolean?>]: Flag to enable Edge Drive
  [EdgeDriveSettingAuditDriveOperations <Boolean?>]: Enable auditing which logs the activities based on user interaction like creating, editing, moving, renaming, downloading or deleting files.
  [EdgeDriveSettingCreateNewIndexServer <Boolean?>]: If set to false, uses existing edge index server and requires IndexServer IdName to be passed. If set to true, requires client IdName and indexCachePath to create a new Index Server.
  [EdgeDriveSettingEdgeDriveQuota <Int64?>]: Maximum number of gigabytes that you can store in the Edge Drive. Giving value as -1 means no quota.
  [EdgeDriveSettingIndexCachePath <String>]: 
  [EdgeDriveSettingNotificationsForShares <Boolean?>]: Enables alert notification feature which allows the share user or share owner to subscribe for share notifications when any activities are performed on the Edge Drive or the Collaborative share. The user can receive the notifications on the Web Console or as an email notification.
  [IndexServerId <Int64?>]: 
  [IndexServerName <String>]: 

INVITEUSERSORGROUPS <IPlanUserOrGroups[]>: The users and user groups who should install the end-user Endpoint package on their devices.
  [Id <Int64?>]: This gives Id of user or user group or external user group
  [Name <String>]: This gives name of user or user group or external user group
  [SendInvite <Boolean?>]: If set to true, will send an invite email to the user or group. Default is true.
  [Type <String>]: Tells what kind of user or user group it is
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvlaptopplan
#>
function New-CVLaptopPlan {
[OutputType([Commvault.Powershell.Models.IPlanResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for ALERTS properties and create a hash table.
    ${Alerts},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to enable overriding of plan.
    # Plan cannot be overriden by default.
    ${AllowPlanOverride},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ILaptopPlanAllowedFeatures]
    # Create/modify allowed features of laptop plan
    # To construct, see NOTES section for ALLOWEDFEATURES properties and create a hash table.
    ${AllowedFeatures},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Maximum number of gigabytes that you can store in the File System.
    # Giving value as -1 means infinite file system quota.
    ${BackupContentFileSystemQuota},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for Mac
    ${BackupContentMacExcludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for Mac
    ${BackupContentMacIncludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for UNIX
    ${BackupContentUnixExcludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for UNIX
    ${BackupContentUnixIncludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for Windows
    ${BackupContentWindowsExcludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for Windows
    ${BackupContentWindowsIncludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Custom version rule: Retain daily versions for this many day(s)
    ${FileVersionDailyVersions},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Retain files for this many days.
    # Year(s) or month(s) need to be converted to day(s)
    ${FileVersionDays},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Custom version rule: Retain monthly versions for this many month(s)
    ${FileVersionMonthlyVersions},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Retain this many file versions.
    # This is considered as default if no file retention rule is specified.
    ${FileVersionVersions},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Custom version rule: Retain weekly versions for this many week(s)
    ${FileVersionWeeklyVersions},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanUserOrGroups[]]
    # The users and user groups who should install the end-user Endpoint package on their devices.
    # To construct, see NOTES section for INVITEUSERSORGROUPS properties and create a hash table.
    ${InviteUsersOrGroups},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Maximum kilobits per second to throttle the receiving speed of data.
    # Giving value as -1 means infinite throttle send speed i.e.
    # no limit
    ${NetworkResourceThrottleReceive},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Maximum kilobits per second to throttle the emitting speed of data.
    # Giving value as -1 means infinite throttle send speed i.e.
    # no limit
    ${NetworkResourceThrottleSend},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionBackupContent},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionRetention},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionRpo},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionStoragePool},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${ParentPlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ParentPlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${PrimaryStorageId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PrimaryStorageName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Amount of days after deletion of files to keep the items.
    # Giving value as -1 means to retain files indefinitely.
    ${RetentionDeletedItemRetention},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SecondaryStorageId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SecondaryStorageName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Recovery Point Objective (RPO) is the maximum amount of time that data can be lost during a service disruption.
    # Your RPO determines the frequency of your backup jobs.
    # Your RPO is met through automatic options.
    # The time specified in minutes here is your RPO if none of the automatic options are met.
    # Default is 480 minutes (8 hours).
    ${StorageAndScheduleBackupFrequency},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVLaptopPlan_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a new backup location for local storage.
.Description
Create a new backup location for local storage.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IIdName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvlocalbackuplocation
#>
function New-CVLocalBackupLocation {
[OutputType([Commvault.Powershell.Models.IIdName])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the local storage pool to update
    ${StoragePoolId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The mount path on the media agent where the data is to be backed up.
    ${BackupLocation},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # username to access the network path
    ${CredentialsName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # password to access the network path
    ${CredentialsPassword},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${MediaAgentId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${MediaAgentName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SavedCredentialsId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SavedCredentialsName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVLocalBackupLocation_CreateExpanded';
            CreateViaIdentityExpanded = 'CommvaultPowershell.private\New-CVLocalBackupLocation_CreateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a new Local storage pool
.Description
Create a new Local storage pool
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IIdName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

DEDUPLICATIONDBSTORAGE <IDedupePath[]>: A list of dedupe locations can be provided for the storage pool being created. This provides an efficient way to save/store data by eliminating duplicate blocks of data during backups.
  [MediaAgentId <Int64?>]: 
  [MediaAgentName <String>]: 
  [Path <String>]: 

STORAGE <IPath[]>: A list of backup locations can be provided for the storage pool being created.
  [BackupLocation <String>]: 
  [CredentialsName <String>]: username to access the network path
  [CredentialsPassword <String>]: password to access the network path
  [MediaAgentId <Int64?>]: 
  [MediaAgentName <String>]: 
  [SavedCredentialsId <Int64?>]: 
  [SavedCredentialsName <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvlocalstorage
#>
function New-CVLocalStorage {
[OutputType([Commvault.Powershell.Models.IIdName])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # enables or disables deduplication
    ${EnableDeduplication},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the Local Storage to be created.
    ${Name},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPath[]]
    # A list of backup locations can be provided for the storage pool being created.
    # To construct, see NOTES section for STORAGE properties and create a hash table.
    ${Storage},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDedupePath[]]
    # A list of dedupe locations can be provided for the storage pool being created.
    # This provides an efficient way to save/store data by eliminating duplicate blocks of data during backups.
    # To construct, see NOTES section for DEDUPLICATIONDBSTORAGE properties and create a hash table.
    ${DeduplicationDbStorage},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVLocalStorage_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Add nodes for a specific hyperscale storage
.Description
Add nodes for a specific hyperscale storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

NODES <IIdName[]>: List of Nodes (MediaAgents) one want to add to the specified HyperScale Storage
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvnodeforhyperscalestorage
#>
function New-CVNodeforHyperScaleStorage {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of hyperscale storage
    ${HyperScaleStorageId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # List of Nodes (MediaAgents) one want to add to the specified HyperScale Storage
    # To construct, see NOTES section for NODES properties and create a hash table.
    ${Nodes},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVNodeforHyperScaleStorage_CreateExpanded';
            CreateViaIdentityExpanded = 'CommvaultPowershell.private\New-CVNodeforHyperScaleStorage_CreateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a ObjectStore Plan
.Description
Create a ObjectStore Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IPlanResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BACKUPDESTINATIONS <IObjectStorePlanBackupDestination[]>: Copy destinations for the plan. Specify where you want to store your data.
  BackupDestinationName <String>: Backup destination name
  RetentionPeriodDays <Int64>: Retention period in days. -1 can be specified for infinite retention.
  StorageType <String>: StorageType
  [FirstExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [FirstExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [FirstExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [SecondExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [SecondExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [SecondExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [StoragePoolId <Int64?>]: 
  [StoragePoolName <String>]: 
  [ThirdExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [ThirdExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [ThirdExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [UseExtendedRetentionRules <Boolean?>]: Use extended retention rules

BACKUPFREQUENCYSCHEDULES <IObjectStorePlanSchedule[]>: .
  SchedulePatternScheduleFrequencyType <String>: schedule frequency type
  [PolicyId <Int64?>]: Schedule policy Id to which the schedule belongs
  [ScheduleId <Int64?>]: Id of the schedule if available, required for modifying, deleting schedule
  [ScheduleName <String>]: Name of the schedule, for modify
  [ScheduleOperation <String>]: Operation being performed on schedule
  [SchedulePatternDayOfMonth <Int64?>]: Day on which to run the schedule, applicable for monthly, yearly
  [SchedulePatternDayOfWeek <String>]: 
  [SchedulePatternDaysBetweenSyntheticFulls <Int64?>]: No of days between two synthetic full jobs
  [SchedulePatternEndDate <Int64?>]: Schedule end date in epoch format
  [SchedulePatternExceptions <IScheduleRunException[]>]: Exceptions to when a schedule should not run, either in dates or week of month and days
    [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
    [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
    [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
  [SchedulePatternFrequency <Int64?>]: Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
  [SchedulePatternMaxBackupIntervalInMins <Int64?>]: The number of mins to force a backup on automatic schedule.
  [SchedulePatternMonthOfYear <String>]: 
  [SchedulePatternNoOfTimes <Int64?>]: The number of times you want the schedule to run.
  [SchedulePatternRepeatIntervalInMinutes <Int64?>]: How often in minutes in a day the schedule runs, applicable for daily, weekly, monthly and yearly frequency types.
  [SchedulePatternRepeatUntilTime <Int64?>]: Until what time to repeat the schedule in a day, requires repeatIntervalInMinutes
  [SchedulePatternStartDate <Int64?>]: start date of schedule in epoch format
  [SchedulePatternStartTime <Int64?>]: start time of schedule in seconds
  [SchedulePatternWeekOfMonth <String>]: Specific week of a month
  [SchedulePatternWeeklyDays <String[]>]: Days of the week for weekly frequency
  [TimezoneId <Int64?>]: 
  [TimezoneName <String>]: 

RPOFULLBACKUPWINDOW <IDayAndTime[]>: Backup window for full backup
  [DayOfWeek <String[]>]: 
  [EndTime <Int64?>]: Time in seconds since the beginning of the day
  [StartTime <Int64?>]: Time in seconds since the beginning of the day
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvobjectstoreplan
#>
function New-CVObjectStorePlan {
[OutputType([Commvault.Powershell.Models.IPlanResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IObjectStorePlanBackupDestination[]]
    # Copy destinations for the plan.
    # Specify where you want to store your data.
    # To construct, see NOTES section for BACKUPDESTINATIONS properties and create a hash table.
    ${BackupDestinations},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the new plan
    ${PlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Operation type for the list
    ${BackupFrequencyOperationType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IObjectStorePlanSchedule[]]
    # .
    # To construct, see NOTES section for BACKUPFREQUENCYSCHEDULES properties and create a hash table.
    ${BackupFrequencySchedules},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDayAndTime[]]
    # Backup window for full backup
    # To construct, see NOTES section for RPOFULLBACKUPWINDOW properties and create a hash table.
    ${RpoFullBackupWindow},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVObjectStorePlan_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create Office 365 Onedrive for Business app
.Description
Create Office 365 Onedrive for Business app
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IIdName
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvonedriveclient
#>
function New-CVOnedriveClient {
[OutputType([Commvault.Powershell.Models.IIdName], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure Application ID
    ${AzureAppApplicationId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure app secret key, needs to be base64 encoded
    ${AzureAppApplicationSecret},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure directory (tenant) ID
    ${AzureAppAzureDirectoryId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Unique Onedrive app name
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${ServerPlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ServerPlanName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVOnedriveClient_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Api to create plan rules.
Request body will suggest plan against which rule need to be created and type of entities(workloads type, server groups, regions and all) that need to be referenced for applying that rule against a workload.
.Description
Api to create plan rules.
Request body will suggest plan against which rule need to be created and type of entities(workloads type, server groups, regions and all) that need to be referenced for applying that rule against a workload.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IIdName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

GLOBALCONFIGINFOCOMMCELLS <IGlobalConfigCommcellInfo[]>: List of Service CommCells where the global configuration should be applied
  [Guid <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 

REGIONS <IIdNameGuid[]>: This will include list of regions that should be evaluated against workload region for plan association.
  [Guid <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 

SERVERGROUPS <IIdNameGuid[]>: This will include list of Server groups that should be evaluated against workload server group for plan association.
  [Guid <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 

SOLUTIONS <IIdName[]>: This will include list of solutions that should be evaluated against workload for plan association
  [Id <Int64?>]: 
  [Name <String>]: 

TAGS <IPlanEntityRuleTag[]>: This will include list of tags that should be evaluated against workload for plan association
  [Guid <String>]: GUID for the tag
  [Id <Int64?>]: Id for the tag
  [Name <String>]: Name for the plan rule tag which need to be matched against tag of the workload.
  [Value <String>]: Possible value that need to matched against value of tag associated to workload.

WORKLOADS <IIdName[]>: This will include list of apptypes that should be evaluated against workload apptype for plan association.
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvplanrule
#>
function New-CVPlanRule {
[OutputType([Commvault.Powershell.Models.IIdName], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${CompanyId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${CompanyName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Action that will be taken on the local entity that has the same name as the global entity that needs to be created
    ${GlobalConfigInfoActionOnLocalEntity},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Decides whether the global configuration should be applied to all the Service commcells, including the newly created ones
    ${GlobalConfigInfoApplyOnAllCommCells},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IGlobalConfigCommcellInfo[]]
    # List of Service CommCells where the global configuration should be applied
    # To construct, see NOTES section for GLOBALCONFIGINFOCOMMCELLS properties and create a hash table.
    ${GlobalConfigInfoCommcells},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${GlobalConfigInfoName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The entity level at which the config has to be applied.
    ${GlobalConfigInfoScope},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # CommCellEntityCache filter query string using for filtering the scope
    ${GlobalConfigInfoScopeFilterQuery},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanGuid},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Optional field to suggest priority/rank of the rule.
    # If not present, we will process rule in the same order they are created.
    ${Rank},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdNameGuid[]]
    # This will include list of regions that should be evaluated against workload region for plan association.
    # To construct, see NOTES section for REGIONS properties and create a hash table.
    ${Regions},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdNameGuid[]]
    # This will include list of Server groups that should be evaluated against workload server group for plan association.
    # To construct, see NOTES section for SERVERGROUPS properties and create a hash table.
    ${ServerGroups},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # This will include list of solutions that should be evaluated against workload for plan association
    # To construct, see NOTES section for SOLUTIONS properties and create a hash table.
    ${Solutions},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanEntityRuleTag[]]
    # This will include list of tags that should be evaluated against workload for plan association
    # To construct, see NOTES section for TAGS properties and create a hash table.
    ${Tags},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # This will include list of apptypes that should be evaluated against workload apptype for plan association.
    # To construct, see NOTES section for WORKLOADS properties and create a hash table.
    ${Workloads},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVPlanRule_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create entities in the recovery group
.Description
Create entities in the recovery group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ENTITIES <IRecoveryEntity[]>: .
  [BackupSetId <Int64?>]: 
  [BackupSetName <String>]: 
  [BlockSysrepForRecovery <Boolean?>]: 
  [ClientId <Int64?>]: 
  [ClientName <String>]: 
  [ConnectionDetails <IVMConnectionDetails>]: VMConnectionDetails
    [CsCredsCredentialsName <String>]: username to access the network path
    [CsCredsCredentialsPassword <String>]: password to access the network path
    [CsCredsSavedCredentialsId <Int64?>]: 
    [CsCredsSavedCredentialsName <String>]: 
    [DomainCredsCredentialsName <String>]: username to access the network path
    [DomainCredsCredentialsPassword <String>]: password to access the network path
    [DomainCredsSavedCredentialsId <Int64?>]: 
    [DomainCredsSavedCredentialsName <String>]: 
    [GuestCredsCredentialsName <String>]: username to access the network path
    [GuestCredsCredentialsPassword <String>]: password to access the network path
    [GuestCredsSavedCredentialsId <Int64?>]: 
    [GuestCredsSavedCredentialsName <String>]: 
    [TopologyDetailNetworkGateway <IGatewayConnectionInfo[]>]: 
      [Hostname <String>]: Gateway machine hostname
      [Port <Int64?>]: 
    [TopologyDetailServerGroups <IIdName[]>]: 
      [Id <Int64?>]: 
      [Name <String>]: 
    [VMClientName <String>]: VM client name
    [VMHostName <String>]: VM host name
  [EntityId <Int64?>]: 
  [EntityName <String>]: 
  [ExecutionOrderGroup <Int64?>]: Group ID to group similar entities together
  [ExecutionOrderOrder <Int64?>]: Decides the priority of entites within a group
  [ExecutionOrderPriority <Int64?>]: Decides the priority of group execution
  [Id <Int64?>]: Id of the recovery entity
  [InstanceId <Int64?>]: 
  [InstanceName <String>]: 
  [LastRecoveryJobId <Int64?>]: Last recovery job Id of the entity
  [Name <String>]: Name of the recovery entity
  [OSType <String>]: OS types
  [PostRecoveryActions <IDrOperationScript[]>]: 
    [GuestCredentialsCredentialsName <String>]: username to access the network path
    [GuestCredentialsCredentialsPassword <String>]: password to access the network path
    [GuestCredentialsSavedCredentialsId <Int64?>]: 
    [GuestCredentialsSavedCredentialsName <String>]: 
    [Guid <String>]: Unique script identifier string
    [OSType <String>]: OS types
    [Path <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [Reset <Boolean?>]: On set to true, resets the script to empty
    [ScriptCredentialsCredentialsName <String>]: username to access the network path
    [ScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [ScriptCredentialsSavedCredentialsId <Int64?>]: 
    [ScriptCredentialsSavedCredentialsName <String>]: 
    [Type <String>]: The type of path being used for DR operation script
  [PreRecoveryActions <IDrOperationScript[]>]: 
  [RecoveryConfiguration <IRecoveryConfiguration>]: RecoveryConfiguration
    [AzureCreatePublicIP <Boolean?>]: Create a public IP.
    [AzureDeployVMOnlyDuringfailover <Boolean?>]: Select this option to deploy a VM only when a failover operation is requested
    [AzureDestinationVM <String>]: Destination VM
    [AzureDiskType <String>]: Type of the disk
    [AzureOverrideReplicationOptions <IOverrideReplicationOptionsAzure>]: Replication options for Azure
      [AvailabilityZone <String>]: VM availability zone
      [SecurityGroupId <String>]: Security group id
      [SecurityGroupName <String>]: security group name
      [TestFailoverVirtualNetworkDisplayName <String>]: Display Name of network
      [TestFailoverVirtualNetworkId <String>]: Network unique identifier
      [TestFailoverVirtualNetworkName <String>]: Name of the network
      [TestFailoverVirtualNetworkNetworkAddressDetailsNetworkId <String>]: Azure network ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}.
      [TestFailoverVirtualNetworkNetworkAddressDetailsPrivateIPAddress <String>]: Azure private IP address.
      [TestFailoverVirtualNetworkNetworkAddressDetailsPublicIPAddress <String>]: Azure publice IP address.
      [TestFailoverVirtualNetworkNetworkAddressDetailsPublicIPAddressId <String>]: Azure public IP address ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/publicIPAddresses/{Public IP Address Name}.
      [TestFailoverVirtualNetworkNetworkAddressDetailsSubnetId <String>]: Azure subnet ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}/subnets/{Subnet Name}.
      [TestFailoverVirtualNetworkSubnetId <String>]: subnet id of network
      [VirtualNetworkDisplayName <String>]: Display Name of network
      [VirtualNetworkId <String>]: Network unique identifier
      [VirtualNetworkName <String>]: Name of the network
      [VirtualNetworkNetworkAddressDetailsNetworkId <String>]: Azure network ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}.
      [VirtualNetworkNetworkAddressDetailsPrivateIPAddress <String>]: Azure private IP address.
      [VirtualNetworkNetworkAddressDetailsPublicIPAddress <String>]: Azure publice IP address.
      [VirtualNetworkNetworkAddressDetailsPublicIPAddressId <String>]: Azure public IP address ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/publicIPAddresses/{Public IP Address Name}.
      [VirtualNetworkNetworkAddressDetailsSubnetId <String>]: Azure subnet ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}/subnets/{Subnet Name}.
      [VirtualNetworkSubnetId <String>]: subnet id of network
    [AzureRegion <String>]: region of the VM
    [AzureResourceGroup <String>]: Resource group in which the converted virtual machine should be created.
    [AzureRestoreAsManagedVM <Boolean?>]: Restore the VM as a managed disk for the destination VMs.
    [AzureSourceVM <String>]: Source VM
    [AzureSourceVMGuid <String>]: GUID of the source VM
    [AzureStorageAccount <String>]: Azure Standard or Premium general-purpose storage account.
    [AzureTestFailoverVMSize <String>]: Vm size to be used during the test failover operation
    [AzureUnconditionalOverwrite <Boolean?>]: This will replace the instance at the destination if the instance with the same name already exists.
    [AzureVMSize <String>]: VM size
    [CopyPrecedence <Int64?>]: Copy precedence for the copy used for the restore
    [HardwareConfigurationDataDiskConfiguration <IDiskConfiguration[]>]: 
      [DiskSize <Int64?>]: Disk size in bytes
      [DiskType <String>]: Type of disk controller
      [Name <String>]: Name of the disk
      [ProvisioningType <String>]: Disk provisioning type
    [HardwareConfigurationVolumeConfiguration <IVolumeConfiguration[]>]: 
      [Disks <IDiskConfiguration[]>]: 
      [Enabled <Boolean?>]: Determine if volume is enabled or not
      [Name <String>]: Name of the volume
      [TotalSize <Int64?>]: Size for volume in bytes
    [MediaAgentId <Int64?>]: 
    [MediaAgentName <String>]: 
    [SystemDiskConfigurationDiskSize <Int64?>]: Disk size in bytes
    [SystemDiskConfigurationDiskType <String>]: Type of disk controller
    [SystemDiskConfigurationName <String>]: Name of the disk
    [SystemDiskConfigurationProvisioningType <String>]: Disk provisioning type
  [RecoveryFailureReason <String>]: Reason for last recovery job failure
  [RecoveryGroupId <Int64?>]: 
  [RecoveryGroupName <String>]: 
  [RecoveryPoint <Int64?>]: Timestamp for entity restore in case of disaster, default value is 0 as latest recovery point
  [RecoveryPointDetailEntityRecoveryPoint <Int64?>]: Timestamp for entity restore in case of disaster, default value is 0 as latest recovery point
  [RecoveryPointDetailEntityRecoveryPointCategory <String>]: Type of recovery point category that can be selected. Default is Latest
  [RecoveryPointDetailInheritedFrom <String>]: Describes from where the recovery point is inherited from. If not provided, recovery point will be used as if it is set at recovery group level
  [RecoveryStatus <String>]: Status of recovery entity
  [RecoveryStatusNotReadyCategory <String>]: Recovery status not ready category
  [RecoveryStatusNotReadyReason <String>]: Recovery status not ready reason
  [TargetId <Int64?>]: 
  [TargetName <String>]: 
  [VMGroupId <Int64?>]: 
  [VMGroupName <String>]: 
  [ValidationFailureReason <String>]: Reason for last validation failure
  [ValidationStatus <String>]: Validation status of recovery entity
  [VirtualMachineGuid <String>]: 
  [VirtualMachineName <String>]: 
  [Workload <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvrecoveryentity
#>
function New-CVRecoveryEntity {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Recovery group Id
    ${RecoveryGroupId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRecoveryEntity[]]
    # .
    # To construct, see NOTES section for ENTITIES properties and create a hash table.
    ${Entities},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVRecoveryEntity_CreateExpanded';
            CreateViaIdentityExpanded = 'CommvaultPowershell.private\New-CVRecoveryEntity_CreateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create Recovery group
.Description
Create Recovery group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.ICreateRecoveryGroupResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

POSTRECOVERYACTIONS <IDrOperationScript[]>: .
  [GuestCredentialsCredentialsName <String>]: username to access the network path
  [GuestCredentialsCredentialsPassword <String>]: password to access the network path
  [GuestCredentialsSavedCredentialsId <Int64?>]: 
  [GuestCredentialsSavedCredentialsName <String>]: 
  [Guid <String>]: Unique script identifier string
  [OSType <String>]: OS types
  [Path <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [Reset <Boolean?>]: On set to true, resets the script to empty
  [ScriptCredentialsCredentialsName <String>]: username to access the network path
  [ScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [ScriptCredentialsSavedCredentialsId <Int64?>]: 
  [ScriptCredentialsSavedCredentialsName <String>]: 
  [Type <String>]: The type of path being used for DR operation script
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvrecoverygroup
#>
function New-CVRecoveryGroup {
[OutputType([Commvault.Powershell.Models.ICreateRecoveryGroupResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Recovery Action
    ${Action},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Set to true to continue to the next priority machines on failure
    ${ContinueOnFailure},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The delay between machines in different priorities in minutes
    ${DelayBetweenPriorityMachines},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Id of the recovery group
    ${Id},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the recovery group
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDrOperationScript[]]
    # .
    # To construct, see NOTES section for POSTRECOVERYACTIONS properties and create a hash table.
    ${PostRecoveryActions},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Timestamp for group restore in case of disaster, default value is 0 as latest recovery point
    ${RecoveryPoint},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Timestamp for group restore in case of disaster, default value is 0 as latest recovery point
    ${RecoveryPointDetailRecoveryPoint},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Type of recovery point category that can be selected.
    # Default is Latest
    ${RecoveryPointDetailRecoveryPointCategory},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${TargetId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${TargetName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVRecoveryGroup_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a region
.Description
Create a region
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IIdNameGuid
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

GLOBALCONFIGINFOCOMMCELLS <IGlobalConfigCommcellInfo[]>: List of Service CommCells where the global configuration should be applied
  [Guid <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 

LOCATIONS <ILocationDetails[]>: List of locations which are part of the region
  Country <String>: Name of country
  Latitude <Double>: Latitude for the location
  Longitude <Double>: Longitude for the location
  [City <String>]: Name of city
  [State <String>]: Name of state
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvregion
#>
function New-CVRegion {
[OutputType([Commvault.Powershell.Models.IIdNameGuid], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ILocationDetails[]]
    # List of locations which are part of the region
    # To construct, see NOTES section for LOCATIONS properties and create a hash table.
    ${Locations},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Region name
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Action that will be taken on the local entity that has the same name as the global entity that needs to be created
    ${GlobalConfigInfoActionOnLocalEntity},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Decides whether the global configuration should be applied to all the Service commcells, including the newly created ones
    ${GlobalConfigInfoApplyOnAllCommCells},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IGlobalConfigCommcellInfo[]]
    # List of Service CommCells where the global configuration should be applied
    # To construct, see NOTES section for GLOBALCONFIGINFOCOMMCELLS properties and create a hash table.
    ${GlobalConfigInfoCommcells},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${GlobalConfigInfoName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The entity level at which the config has to be applied.
    ${GlobalConfigInfoScope},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # CommCellEntityCache filter query string using for filtering the scope
    ${GlobalConfigInfoScopeFilterQuery},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Type of the region
    ${Type},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVRegion_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Creating a request for request manager
.Description
Creating a request for request manager
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IIdName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ENTITIES <INameValues[]>: List of personal entities with their values to form the criteria for the request
  [Name <String>]: 
  [Value <String>]: 
  [Values <String[]>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvrequestoperation
#>
function New-CVRequestOperation {
[OutputType([Commvault.Powershell.Models.IIdName], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.INameValues[]]
    # List of personal entities with their values to form the criteria for the request
    # To construct, see NOTES section for ENTITIES properties and create a hash table.
    ${Entities},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the request
    ${Name},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Requestor},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # RMRequestType
    ${Type},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${DeleteFromBackup},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If additional entities are found in a document, include documents that contain those additional entities in search results
    ${EnableDocumentChaining},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # This option redacts sensitive information from the files in the request
    ${EnableRedaction},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVRequestOperation_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a new role
.Description
Create a new role
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICreateRole
.Outputs
Commvault.Powershell.Models.IIdNameGuid
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ICreateRole>: Create a new role.
  Name <String>: Name of the new role
  PermissionList <IPermissions[]>: Used to provide the list of permissions associated with the role.
    [CategoryId <Int64?>]: 
    [CategoryName <String>]: 
    [PermissionId <Int64?>]: 
    [PermissionName <String>]: 
  [Enabled <Boolean?>]: Used to determine if the role is enabled or disabled. If not provided, role will be enabled by default.
  [GlobalConfigInfoActionOnLocalEntity <String>]: Action that will be taken on the local entity that has the same name as the global entity that needs to be created
  [GlobalConfigInfoApplyOnAllCommCells <Boolean?>]: Decides whether the global configuration should be applied to all the Service commcells, including the newly created ones
  [GlobalConfigInfoCommcells <IGlobalConfigCommcellInfo[]>]: List of Service CommCells where the global configuration should be applied
    [Guid <String>]: 
    [Id <Int64?>]: 
    [Name <String>]: 
  [GlobalConfigInfoName <String>]: 
  [GlobalConfigInfoScope <String>]: The entity level at which the config has to be applied.
  [GlobalConfigInfoScopeFilterQuery <String>]: CommCellEntityCache filter query string using for filtering the scope
  [VisibleToAll <Boolean?>]: 

GLOBALCONFIGINFOCOMMCELLS <IGlobalConfigCommcellInfo[]>: List of Service CommCells where the global configuration should be applied
  [Guid <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 

PERMISSIONLIST <IPermissions[]>: Used to provide the list of permissions associated with the role.
  [CategoryId <Int64?>]: 
  [CategoryName <String>]: 
  [PermissionId <Int64?>]: 
  [PermissionName <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvrole
#>
function New-CVRole {
[OutputType([Commvault.Powershell.Models.IIdNameGuid])]
[CmdletBinding(DefaultParameterSetName='New', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='New', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICreateRole]
    # Create a new role.
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='NewExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the new role
    ${Name},

    [Parameter(ParameterSetName='NewExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPermissions[]]
    # Used to provide the list of permissions associated with the role.
    # To construct, see NOTES section for PERMISSIONLIST properties and create a hash table.
    ${PermissionList},

    [Parameter(ParameterSetName='NewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Used to determine if the role is enabled or disabled.
    # If not provided, role will be enabled by default.
    ${Enabled},

    [Parameter(ParameterSetName='NewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Action that will be taken on the local entity that has the same name as the global entity that needs to be created
    ${GlobalConfigInfoActionOnLocalEntity},

    [Parameter(ParameterSetName='NewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Decides whether the global configuration should be applied to all the Service commcells, including the newly created ones
    ${GlobalConfigInfoApplyOnAllCommCells},

    [Parameter(ParameterSetName='NewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IGlobalConfigCommcellInfo[]]
    # List of Service CommCells where the global configuration should be applied
    # To construct, see NOTES section for GLOBALCONFIGINFOCOMMCELLS properties and create a hash table.
    ${GlobalConfigInfoCommcells},

    [Parameter(ParameterSetName='NewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${GlobalConfigInfoName},

    [Parameter(ParameterSetName='NewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The entity level at which the config has to be applied.
    ${GlobalConfigInfoScope},

    [Parameter(ParameterSetName='NewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # CommCellEntityCache filter query string using for filtering the scope
    ${GlobalConfigInfoScopeFilterQuery},

    [Parameter(ParameterSetName='NewExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${VisibleToAll},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            New = 'CommvaultPowershell.private\New-CVRole_New';
            NewExpanded = 'CommvaultPowershell.private\New-CVRole_NewExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create the bucket clone of the given bucket id
.Description
Create the bucket clone of the given bucket id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ICreateCvfss3BucketCloneResponse
.Outputs
Commvault.Powershell.Models.IGenericResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvs3bucketclone
#>
function New-CVS3BucketClone {
[OutputType([Commvault.Powershell.Models.ICreateCvfss3BucketCloneResponse], [Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the bucket
    ${Id},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The copy precedence to use for the clone operation
    ${CopyPrecedence},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Clone reservation time in seconds.
    # The clone will be automatically deleted after the specified duration.
    ${ReservationTime},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Clone objects in the bucket created on or before the specified time in unix format.
    ${ToTime},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Clone objects in the bucket created on or after the specified time in unix format.
    ${FromTime},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVS3BucketClone_CreateExpanded';
            CreateViaIdentityExpanded = 'CommvaultPowershell.private\New-CVS3BucketClone_CreateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Creates SAML app
.Description
Creates SAML app
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ASSOCIATIONCOMPANIES <IIdName[]>: Companies associated with SAML
  [Id <Int64?>]: 
  [Name <String>]: 

ASSOCIATIONDOMAINS <IIdName[]>: Domains associated with SAML
  [Id <Int64?>]: 
  [Name <String>]: 

ASSOCIATIONUSERGROUPS <IIdName[]>: user groups associated with SAML
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvsamlapp
#>
function New-CVSamlApp {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # SAML description
    ${Description},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # IDP certificate public key
    ${IdentityProviderMetaDataCertificateData},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Identity provider entity
    ${IdentityProviderMetaDataEntityId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Identity Provider log-out URL
    ${IdentityProviderMetaDataLogoutUrl},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Identity provider redirect URL
    ${IdentityProviderMetaDataRedirectUrl},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # SAML Protocol version
    ${IdentityProviderMetaDataSamlProtocolVersion},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # SAML name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Companies associated with SAML
    # To construct, see NOTES section for ASSOCIATIONCOMPANIES properties and create a hash table.
    ${AssociationCompanies},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Domains associated with SAML
    # To construct, see NOTES section for ASSOCIATIONDOMAINS properties and create a hash table.
    ${AssociationDomains},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Email suffixes associated with SAML
    ${AssociationEmailSuffixes},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # user groups associated with SAML
    # To construct, see NOTES section for ASSOCIATIONUSERGROUPS properties and create a hash table.
    ${AssociationUserGroups},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # IDP's secondary certificate
    ${IdentityProviderMetaDataSecondaryCertificateData},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # certificate alias name
    ${ServiceProviderMetaDataAliasName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${ServiceProviderMetaDataAutoGenerateSpMetaData},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # certificate alias name.
    ${ServiceProviderMetaDataCertificateData},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # jks file contents as byte array
    ${ServiceProviderMetaDataJksFileContents},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # key store password.
    ${ServiceProviderMetaDataJksPrivateKey},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # jks contents key store password.
    ${ServiceProviderMetaDataKeyStorePassword},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # certificate private key password
    ${ServiceProviderMetaDataPrivateKeyPassword},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # web console URL.
    ${ServiceProviderMetaDataServiceProviderEndpoint},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # web console URL list.
    ${ServiceProviderMetaDataSpAliases},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVSamlApp_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create Server group
.Description
Create Server group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IIdNameGuid
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

GLOBALCONFIGINFOCOMMCELLS <IGlobalConfigCommcellInfo[]>: List of Service CommCells where the global configuration should be applied
  [Guid <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 

MANUALASSOCIATIONASSOCIATEDSERVERS <IIdName[]>: List of associated servers
  [Id <Int64?>]: 
  [Name <String>]: 

RULERULES <IRuleContent[]>: .
  [Condition <String>]: Operation type for VM rules/filters
  [DisplayName <String>]: The display name of the entity to be added
  [Guid <String>]: GUID of the entity to be added as content
  [Name <String>]: name of the VM to be added as content
  [Type <String>]: 
  [Value <String>]: value for the few type of VM Content like powerstate

SERVERGROUPRULEGROUP <IServerRuleGroup[]>: List of rule groups
  [Match <String>]: 
  [Rules <IServerRule[]>]: List of rules
    [MatchCondition <String>]: 
    [RuleName <String>]: 
    [RuleSecValue <String>]: Secondary value used for BETWEEN and NOT_BETWEEN matchCondition. For ruleName which have enum values (like OS_TYPE), this is used to store displayName.
    [RuleValue <String>]: Primary value for the rule

VIRTUALASSOCIATIONCLIENTASSOCIATION <IClientAssociationServerGroupContent[]>: .
  [AssociatedClientId <Int64?>]: 
  [AssociationRule <IVirtualMachinecontent[]>]: 
    [ExistingCredentialId <Int64?>]: 
    [ExistingCredentialName <String>]: 
    [GuestCredentialAssocId <Int64?>]: Credential association ID given to link entity with credential id.
    [GuestCredentialsPassword <String>]: 
    [GuestCredentialsUserName <String>]: 
    [Guid <String>]: GUID of the VM to be added as content
    [Name <String>]: name of the VM to be added as content
    [Type <String>]: 

VIRTUALASSOCIATIONVIRTUALSERVERS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvservergroup
#>
function New-CVServerGroup {
[OutputType([Commvault.Powershell.Models.IIdNameGuid], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Confirm that server group rule impacts server of a specific company smart client group only
    ${AutomaticAssociationConfirmRuleChange},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ClientScopeType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Description},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${EntityInfoId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${EntityInfoName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Action that will be taken on the local entity that has the same name as the global entity that needs to be created
    ${GlobalConfigInfoActionOnLocalEntity},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Decides whether the global configuration should be applied to all the Service commcells, including the newly created ones
    ${GlobalConfigInfoApplyOnAllCommCells},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IGlobalConfigCommcellInfo[]]
    # List of Service CommCells where the global configuration should be applied
    # To construct, see NOTES section for GLOBALCONFIGINFOCOMMCELLS properties and create a hash table.
    ${GlobalConfigInfoCommcells},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${GlobalConfigInfoName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The entity level at which the config has to be applied.
    ${GlobalConfigInfoScope},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # CommCellEntityCache filter query string using for filtering the scope
    ${GlobalConfigInfoScopeFilterQuery},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # List of associated servers
    # To construct, see NOTES section for MANUALASSOCIATIONASSOCIATEDSERVERS properties and create a hash table.
    ${ManualAssociationAssociatedservers},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Enum which specifies the whether to match all rules or any of the rules
    ${RuleMatchRule},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRuleContent[]]
    # .
    # To construct, see NOTES section for RULERULES properties and create a hash table.
    ${RuleRules},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IServerRuleGroup[]]
    # List of rule groups
    # To construct, see NOTES section for SERVERGROUPRULEGROUP properties and create a hash table.
    ${ServerGroupRuleGroup},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ServerGroupRuleMatch},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ServerGroupType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IClientAssociationServerGroupContent[]]
    # .
    # To construct, see NOTES section for VIRTUALASSOCIATIONCLIENTASSOCIATION properties and create a hash table.
    ${VirtualAssociationClientAssociation},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${VirtualAssociationVirtualInstance},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for VIRTUALASSOCIATIONVIRTUALSERVERS properties and create a hash table.
    ${VirtualAssociationVirtualServers},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVServerGroup_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to create backup content on server plan
.Description
API to create backup content on server plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ICreateServerPlanBackupContentResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvserverplanbackupcontent
#>
function New-CVServerPlanBackupContent {
[OutputType([Commvault.Powershell.Models.ICreateServerPlanBackupContentResponse])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to modify
    ${PlanId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Do you want to back up the system state Applicable only for Windows
    ${BackupContentBackupSystemState},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Do you want to back up system state only with full backup Applicable only if the value of backupSystemState is true
    ${BackupContentBackupSystemStateOnlyWithFullBackup},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Do you want to sync properties on associated subclients even if properties are overriden at subclient level
    ${BackupContentForceUpdateProperties},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for Mac
    ${BackupContentMacExcludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths that are exception to excluded paths for Mac
    ${BackupContentMacFilterToExcludePaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for Mac
    ${BackupContentMacIncludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for UNIX
    ${BackupContentUnixExcludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths that are exception to excluded paths for Unix
    ${BackupContentUnixFilterToExcludePaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for UNIX
    ${BackupContentUnixIncludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Do you want to back up system state with VSS Applicable only if the value of backupSystemState is true
    ${BackupContentUseVssForSystemState},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for Windows
    ${BackupContentWindowsExcludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths that are exception to excluded paths for Windows
    ${BackupContentWindowsFilterToExcludePaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for Windows
    ${BackupContentWindowsIncludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of data readers.
    ${MacNumberOfDataReaderCount},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Set optimal number of data readers.
    # if it is set to true, count will be ignored.
    ${MacNumberOfDataReaderUseOptimal},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of data readers.
    ${UnixNumberOfDataReaderCount},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Set optimal number of data readers.
    # if it is set to true, count will be ignored.
    ${UnixNumberOfDataReaderUseOptimal},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of data readers.
    ${WindowNumberOfDataReaderCount},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Set optimal number of data readers.
    # if it is set to true, count will be ignored.
    ${WindowNumberOfDataReaderUseOptimal},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVServerPlanBackupContent_CreateExpanded';
            CreateViaIdentityExpanded = 'CommvaultPowershell.private\New-CVServerPlanBackupContent_CreateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to create RPO schedules on server plan
.Description
API to create RPO schedules on server plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ICreateServerPlanRpoResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BACKUPFREQUENCYSCHEDULES <IPlanSchedule[]>: .
  BackupType <String>: Schedule Backup level
  SchedulePatternScheduleFrequencyType <String>: schedule frequency type
  [ForDatabasesOnly <Boolean?>]: Boolean to indicate if schedule is for database agents
  [IsRetentionBasedSyntheticFull <Boolean?>]: Boolean to indicate if synthetic full schedule is based on retention rules
  [PolicyId <Int64?>]: Schedule policy Id to which the schedule belongs
  [ScheduleId <Int64?>]: Id of the schedule if available, required for modifying, deleting schedule
  [ScheduleName <String>]: Name of the schedule, for modify
  [ScheduleOperation <String>]: Operation being performed on schedule
  [ScheduleOptionCommitFrequencyInHours <Int64?>]: Commit frequency in hours for disk cache backups from automatic schedules
  [ScheduleOptionDaysBetweenAutoConvert <Int64?>]: Number of days between auto conversion of backup level applicable for databases on incremental and differential schedules of server plan
  [ScheduleOptionJobRunningTimeInMins <Int64?>]: total job running time in minutes
  [ScheduleOptionLogFilesThreshold <Int64?>]: The min number of archived log files before a backup job should start
  [ScheduleOptionLogsDiskUtilizationPercent <Int64?>]: The min log destination disk threshold percentage
  [ScheduleOptionMinBackupIntervalInMins <Int64?>]: The min number of mins to check for file activity on automatic schedule.
  [ScheduleOptionO365ItemSelectionOption <String>]: item backup option for O365 V2 backup jobs
  [ScheduleOptionUseDiskCacheForLogBackups <Boolean?>]: Used to enable disk caching feature on databases for automatic schedules on server plan
  [SchedulePatternDayOfMonth <Int64?>]: Day on which to run the schedule, applicable for monthly, yearly
  [SchedulePatternDayOfWeek <String>]: 
  [SchedulePatternDaysBetweenSyntheticFulls <Int64?>]: No of days between two synthetic full jobs
  [SchedulePatternEndDate <Int64?>]: Schedule end date in epoch format
  [SchedulePatternExceptions <IScheduleRunException[]>]: Exceptions to when a schedule should not run, either in dates or week of month and days
    [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
    [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
    [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
  [SchedulePatternFrequency <Int64?>]: Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
  [SchedulePatternMaxBackupIntervalInMins <Int64?>]: The number of mins to force a backup on automatic schedule.
  [SchedulePatternMonthOfYear <String>]: 
  [SchedulePatternNoOfTimes <Int64?>]: The number of times you want the schedule to run.
  [SchedulePatternRepeatIntervalInMinutes <Int64?>]: How often in minutes in a day the schedule runs, applicable for daily, weekly, monthly and yearly frequency types.
  [SchedulePatternRepeatUntilTime <Int64?>]: Until what time to repeat the schedule in a day, requires repeatIntervalInMinutes
  [SchedulePatternStartDate <Int64?>]: start date of schedule in epoch format
  [SchedulePatternStartTime <Int64?>]: start time of schedule in seconds
  [SchedulePatternWeekOfMonth <String>]: Specific week of a month
  [SchedulePatternWeeklyDays <String[]>]: Days of the week for weekly frequency
  [TimezoneId <Int64?>]: 
  [TimezoneName <String>]: 
  [VMOperationType <String>]: Type of DR operation (only applicable for Failover groups)

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

RPOBACKUPWINDOW <IDayAndTime[]>: Backup window for incremental backup
  [DayOfWeek <String[]>]: 
  [EndTime <Int64?>]: Time in seconds since the beginning of the day
  [StartTime <Int64?>]: Time in seconds since the beginning of the day

RPOFULLBACKUPWINDOW <IDayAndTime[]>: Backup window for full backup
  [DayOfWeek <String[]>]: 
  [EndTime <Int64?>]: Time in seconds since the beginning of the day
  [StartTime <Int64?>]: Time in seconds since the beginning of the day
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvserverplanrpo
#>
function New-CVServerPlanRpo {
[OutputType([Commvault.Powershell.Models.ICreateServerPlanRpoResponse])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Server Plan
    ${PlanId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Operation type for the list
    ${BackupFrequencyOperationType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanSchedule[]]
    # .
    # To construct, see NOTES section for BACKUPFREQUENCYSCHEDULES properties and create a hash table.
    ${BackupFrequencySchedules},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Commit frequency in hours
    ${DatabaseOptionCommitFrequencyInHours},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Log backup RPO in minutes
    ${DatabaseOptionLogBackupRpoMins},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Use disk cache for log backups
    ${DatabaseOptionUseDiskCacheForLogBackups},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDayAndTime[]]
    # Backup window for incremental backup
    # To construct, see NOTES section for RPOBACKUPWINDOW properties and create a hash table.
    ${RpoBackupWindow},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDayAndTime[]]
    # Backup window for full backup
    # To construct, see NOTES section for RPOFULLBACKUPWINDOW properties and create a hash table.
    ${RpoFullBackupWindow},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVServerPlanRpo_CreateExpanded';
            CreateViaIdentityExpanded = 'CommvaultPowershell.private\New-CVServerPlanRpo_CreateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a Server Plan
.Description
Create a Server Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IPlanResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BACKUPDESTINATIONS <ICreatePlanBackupDestination[]>: Backup destinations for the plan. Specify where you want to store your backup data.
  BackupDestinationName <String>: Backup destination details. Enter the name during creation.
  [BackupStartTime <Int64?>]: Backup start time in seconds. The time is provided in unix time format.
  [BackupsToCopy <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [FirstExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [FirstExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [FirstExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [FullBackupTypesToCopy <String>]: Which type of backup type should be copied for the given backup destination when backup type is not all jobs. Default is LAST while adding new backup destination.
  [IsConfiguredForReplication <Boolean?>]: Used if the copy is used for replication group
  [IsMirrorCopy <Boolean?>]: Is this a mirror copy? Only considered when isSnapCopy is true.
  [IsSnapCopy <Boolean?>]: Is this a snap copy? If isMirrorCopy is not set, then default is Vault/Replica.
  [Mappings <ISnapshotCopyMapping[]>]: 
    [SourceId <Int64?>]: 
    [SourceName <String>]: 
    [SourceVendorId <Int64?>]: 
    [SourceVendorName <String>]: 
    [TargetId <Int64?>]: 
    [TargetName <String>]: 
    [TargetVendorId <Int64?>]: 
    [TargetVendorName <String>]: 
    [Vendor <String>]: Snapshot vendors available for Snap Copy mappings
  [NetAppCloudTarget <Boolean?>]: Only for snap copy. Enabling this changes SVM Mapping  to NetApp cloud targets only.
  [OptimizeForInstantClone <Boolean?>]: Flag to specify if primary storage is copy data management enabled.
  [OverrideRetentionSettings <Boolean?>]: Tells if this copy should use storage pool retention period days or the retention defined for this copy. Set as true to use retention defined on this copy.
  [RegionGuid <String>]: 
  [RegionId <Int64?>]: 
  [RegionName <String>]: 
  [RetentionPeriodDays <Int64?>]: Retention period in days. -1 can be specified for infinite retention. If this and snapRecoveryPoints both are not specified, this takes  precedence.
  [RetentionRuleType <String>]: Which type of retention rule should be used for the given backup destination
  [SecondExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [SecondExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [SecondExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [SnapRecoveryPoints <Int64?>]: Number of snap recovery points for snap copy for retention. Can be specified instead of retention period in Days for snap copy.
  [SourceCopyId <Int64?>]: 
  [SourceCopyName <String>]: 
  [StoragePoolId <Int64?>]: 
  [StoragePoolName <String>]: 
  [StorageTemplateTags <IIdNameValue[]>]: It is used in Global config template plan creation. Needs in plan creation on global commcell
    [Id <Int64?>]: 
    [Name <String>]: 
    [Value <String>]: 
  [StorageType <String>]: StorageType
  [ThirdExtendedRetentionRuleIsInfiniteRetention <Boolean?>]: If this is set as true, no need to specify retentionPeriodDays.
  [ThirdExtendedRetentionRuleRetentionPeriodDays <Int64?>]: If this is set, no need to specify isInfiniteRetention as false.
  [ThirdExtendedRetentionRuleType <String>]: All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only.
  [UseExtendedRetentionRules <Boolean?>]: Use extended retention rules

BACKUPFREQUENCYSCHEDULES <IPlanSchedule[]>: .
  BackupType <String>: Schedule Backup level
  SchedulePatternScheduleFrequencyType <String>: schedule frequency type
  [ForDatabasesOnly <Boolean?>]: Boolean to indicate if schedule is for database agents
  [IsRetentionBasedSyntheticFull <Boolean?>]: Boolean to indicate if synthetic full schedule is based on retention rules
  [PolicyId <Int64?>]: Schedule policy Id to which the schedule belongs
  [ScheduleId <Int64?>]: Id of the schedule if available, required for modifying, deleting schedule
  [ScheduleName <String>]: Name of the schedule, for modify
  [ScheduleOperation <String>]: Operation being performed on schedule
  [ScheduleOptionCommitFrequencyInHours <Int64?>]: Commit frequency in hours for disk cache backups from automatic schedules
  [ScheduleOptionDaysBetweenAutoConvert <Int64?>]: Number of days between auto conversion of backup level applicable for databases on incremental and differential schedules of server plan
  [ScheduleOptionJobRunningTimeInMins <Int64?>]: total job running time in minutes
  [ScheduleOptionLogFilesThreshold <Int64?>]: The min number of archived log files before a backup job should start
  [ScheduleOptionLogsDiskUtilizationPercent <Int64?>]: The min log destination disk threshold percentage
  [ScheduleOptionMinBackupIntervalInMins <Int64?>]: The min number of mins to check for file activity on automatic schedule.
  [ScheduleOptionO365ItemSelectionOption <String>]: item backup option for O365 V2 backup jobs
  [ScheduleOptionUseDiskCacheForLogBackups <Boolean?>]: Used to enable disk caching feature on databases for automatic schedules on server plan
  [SchedulePatternDayOfMonth <Int64?>]: Day on which to run the schedule, applicable for monthly, yearly
  [SchedulePatternDayOfWeek <String>]: 
  [SchedulePatternDaysBetweenSyntheticFulls <Int64?>]: No of days between two synthetic full jobs
  [SchedulePatternEndDate <Int64?>]: Schedule end date in epoch format
  [SchedulePatternExceptions <IScheduleRunException[]>]: Exceptions to when a schedule should not run, either in dates or week of month and days
    [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
    [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
    [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
  [SchedulePatternFrequency <Int64?>]: Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
  [SchedulePatternMaxBackupIntervalInMins <Int64?>]: The number of mins to force a backup on automatic schedule.
  [SchedulePatternMonthOfYear <String>]: 
  [SchedulePatternNoOfTimes <Int64?>]: The number of times you want the schedule to run.
  [SchedulePatternRepeatIntervalInMinutes <Int64?>]: How often in minutes in a day the schedule runs, applicable for daily, weekly, monthly and yearly frequency types.
  [SchedulePatternRepeatUntilTime <Int64?>]: Until what time to repeat the schedule in a day, requires repeatIntervalInMinutes
  [SchedulePatternStartDate <Int64?>]: start date of schedule in epoch format
  [SchedulePatternStartTime <Int64?>]: start time of schedule in seconds
  [SchedulePatternWeekOfMonth <String>]: Specific week of a month
  [SchedulePatternWeeklyDays <String[]>]: Days of the week for weekly frequency
  [TimezoneId <Int64?>]: 
  [TimezoneName <String>]: 
  [VMOperationType <String>]: Type of DR operation (only applicable for Failover groups)

FILESEARCHERRORS <IPlanFileSearchSetupError[]>: File search was enabled on plan but failed to process some of the storage pool(s) with these errors
  [ErrorCode <Int64?>]: 
  [ErrorMessage <String>]: Tells about the error occured during file search setup for given storage pool
  [StorageId <Int64?>]: 
  [StorageName <String>]: 

RPOBACKUPWINDOW <IDayAndTime[]>: Backup window for incremental backup
  [DayOfWeek <String[]>]: 
  [EndTime <Int64?>]: Time in seconds since the beginning of the day
  [StartTime <Int64?>]: Time in seconds since the beginning of the day

RPOFULLBACKUPWINDOW <IDayAndTime[]>: Backup window for full backup
  [DayOfWeek <String[]>]: 
  [EndTime <Int64?>]: Time in seconds since the beginning of the day
  [StartTime <Int64?>]: Time in seconds since the beginning of the day

WORKLOADSOLUTIONS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 

WORKLOADTYPES <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvserverplan
#>
function New-CVServerPlan {
[OutputType([Commvault.Powershell.Models.IPlanResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the new plan
    ${PlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The least RPO in minutes for the plan
    ${AdditionalPropertyRpo},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # status if plan backups are enabled or disabled
    ${AdditionalPropertyStatus},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Database options should be shown with this plan
    ${AddonDatabase},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # File system options should be shown with this plan
    ${AddonFileSystem},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Index copy options should be shown with this plan
    ${AddonIndexCopy},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Snap options should be shown with this plan
    ${AddonSnap},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${AddonSnapStatus},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to enable overriding of plan.
    # Plan cannot be overriden by default.
    ${AllowPlanOverride},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Do you want to back up the system state Applicable only for Windows
    ${BackupContentBackupSystemState},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Do you want to back up system state only with full backup Applicable only if the value of backupSystemState is true
    ${BackupContentBackupSystemStateOnlyWithFullBackup},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Do you want to sync properties on associated subclients even if properties are overriden at subclient level
    ${BackupContentForceUpdateProperties},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for Mac
    ${BackupContentMacExcludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths that are exception to excluded paths for Mac
    ${BackupContentMacFilterToExcludePaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for Mac
    ${BackupContentMacIncludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for UNIX
    ${BackupContentUnixExcludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths that are exception to excluded paths for Unix
    ${BackupContentUnixFilterToExcludePaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for UNIX
    ${BackupContentUnixIncludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Do you want to back up system state with VSS Applicable only if the value of backupSystemState is true
    ${BackupContentUseVssForSystemState},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to exclude for Windows
    ${BackupContentWindowsExcludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths that are exception to excluded paths for Windows
    ${BackupContentWindowsFilterToExcludePaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Paths to include for Windows
    ${BackupContentWindowsIncludedPaths},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64[]]
    # Primary Backup Destination Ids (which were created before plan creation).
    # This is only considered when backupDestinations array object is not defined.
    ${BackupDestinationIds},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICreatePlanBackupDestination[]]
    # Backup destinations for the plan.
    # Specify where you want to store your backup data.
    # To construct, see NOTES section for BACKUPDESTINATIONS properties and create a hash table.
    ${BackupDestinations},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Operation type for the list
    ${BackupFrequencyOperationType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanSchedule[]]
    # .
    # To construct, see NOTES section for BACKUPFREQUENCYSCHEDULES properties and create a hash table.
    ${BackupFrequencySchedules},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Commit frequency in hours
    ${DatabaseOptionCommitFrequencyInHours},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Log backup RPO in minutes
    ${DatabaseOptionLogBackupRpoMins},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Use disk cache for log backups
    ${DatabaseOptionUseDiskCacheForLogBackups},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag for enabling indexing
    ${FileSearchEnabled},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanFileSearchSetupError[]]
    # File search was enabled on plan but failed to process some of the storage pool(s) with these errors
    # To construct, see NOTES section for FILESEARCHERRORS properties and create a hash table.
    ${FileSearchErrors},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Type of indexing status.
    ${FileSearchStatus},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Tells what is happening behind the scene, so that user can knows why indexing is not enabled or if its in progress
    ${FileSearchStatusMessage},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # flag to enable backup content association for applicable file system workload.
    ${FilesystemAddon},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of data readers.
    ${MacNumberOfDataReaderCount},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Set optimal number of data readers.
    # if it is set to true, count will be ignored.
    ${MacNumberOfDataReaderUseOptimal},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionBackupContent},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionRpo},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OverrideRestrictionStoragePool},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${ParentPlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ParentPlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDayAndTime[]]
    # Backup window for incremental backup
    # To construct, see NOTES section for RPOBACKUPWINDOW properties and create a hash table.
    ${RpoBackupWindow},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDayAndTime[]]
    # Backup window for full backup
    # To construct, see NOTES section for RPOFULLBACKUPWINDOW properties and create a hash table.
    ${RpoFullBackupWindow},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Setting to suggest plan has some advanced settings present.
    # Setting is OEM specific and not applicable for all cases.
    ${SettingEnableAdvancedView},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Backup copy RPO in minutes
    ${SnapshotOptionBackupCopyRpoMins},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to enable backup copy
    ${SnapshotOptionEnableBackupCopy},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Retention period in days.
    # -1 can be specified for infinite retention.
    # If this and snapRecoveryPoints both are not specified, this takes precedence.
    ${SnapshotOptionRetentionPeriodDays},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of snap recovery points for default snap copy for retention.
    # Can be specified instead of retention period in Days for default snap copy.
    ${SnapshotOptionSnapRecoveryPoints},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of data readers.
    ${UnixNumberOfDataReaderCount},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Set optimal number of data readers.
    # if it is set to true, count will be ignored.
    ${UnixNumberOfDataReaderUseOptimal},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Number of data readers.
    ${WindowNumberOfDataReaderCount},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Set optimal number of data readers.
    # if it is set to true, count will be ignored.
    ${WindowNumberOfDataReaderUseOptimal},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # .
    ${WorkloadGroupTypes},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for WORKLOADSOLUTIONS properties and create a hash table.
    ${WorkloadSolutions},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for WORKLOADTYPES properties and create a hash table.
    ${WorkloadTypes},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVServerPlan_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create Office 365 SharePoint Online app
.Description
Create Office 365 SharePoint Online app
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IIdName
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvsharepointclient
#>
function New-CVSharepointClient {
[OutputType([Commvault.Powershell.Models.IIdName], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure Application ID
    ${AzureAppApplicationId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure app secret key, needs to be base64 encoded
    ${AzureAppApplicationSecret},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure directory (tenant) ID
    ${AzureAppAzureDirectoryId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Unique Sharepoint app name
    ${Name},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # SharePoint Online tenant admin site URL
    ${TenantAdminSiteUrl},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${ServerPlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ServerPlanName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVSharepointClient_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create Office 365 Teams app
.Description
Create Office 365 Teams app
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IIdName
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvteamclient
#>
function New-CVTeamClient {
[OutputType([Commvault.Powershell.Models.IIdName], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure Application ID
    ${AzureAppApplicationId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure app secret key, needs to be base64 encoded
    ${AzureAppApplicationSecret},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Azure directory (tenant) ID
    ${AzureAppAzureDirectoryId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Unique Teams app name
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # User based refresh token generated with corresponding app credentials.
    # Can be left blank if the azure app is protected API approved.
    ${AzureAppRefreshToken},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${ServerPlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ServerPlanName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVTeamClient_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a new user-group
.Description
Create a new user-group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IIdNameGuid
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

GLOBALCONFIGINFOCOMMCELLS <IGlobalConfigCommcellInfo[]>: List of Service CommCells where the global configuration should be applied
  [Guid <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 

LOCALUSERGROUPS <IIdName[]>: This option is for AD user groups being created. Local user groups can be added to the active directory user groups.
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvusergroup
#>
function New-CVUserGroup {
[OutputType([Commvault.Powershell.Models.IIdNameGuid])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # To create an active directory usergroup, the domain name should be mentioned along with the usergroup name (domainName\\usergroupName) and localUserGroup value must be given.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Description},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Used to determine if a backup data limit will be set for the user group being created
    ${EnforceFsQuota},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Action that will be taken on the local entity that has the same name as the global entity that needs to be created
    ${GlobalConfigInfoActionOnLocalEntity},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Decides whether the global configuration should be applied to all the Service commcells, including the newly created ones
    ${GlobalConfigInfoApplyOnAllCommCells},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IGlobalConfigCommcellInfo[]]
    # List of Service CommCells where the global configuration should be applied
    # To construct, see NOTES section for GLOBALCONFIGINFOCOMMCELLS properties and create a hash table.
    ${GlobalConfigInfoCommcells},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${GlobalConfigInfoName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The entity level at which the config has to be applied.
    ${GlobalConfigInfoScope},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # CommCellEntityCache filter query string using for filtering the scope
    ${GlobalConfigInfoScopeFilterQuery},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # This option is for AD user groups being created.
    # Local user groups can be added to the active directory user groups.
    # To construct, see NOTES section for LOCALUSERGROUPS properties and create a hash table.
    ${LocalUserGroups},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # if enforceFSQuota is set to true, the quota limit can be set in GBs
    ${QuotaLimitInGb},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVUserGroup_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a User
.Description
Create a User
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IIdNameGuid
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

USERS <ICreateUser[]>: .
  Email <String>: Used to provide an email-id to the new user. This email-id is used for logging in the user. Please note that email ids are compulsory for company and local users and optional for external users.
  [CompanyId <Int64?>]: 
  [CompanyName <String>]: 
  [ExternalProviderId <Int64?>]: Please provide this entity only when creating an AD user. Not needed for local and company users.
  [FullName <String>]: Used to provide a name to the new user.
  [InviteUser <Boolean?>]: User will receive an email to install backup software package on their device if this is set to true.
  [Name <String>]: Used to provide the new user with a username. This username can be used for logging in the user instead of email-id when duplicate email-ids are present. For external user, it is necessary to provide the domain name along with the username (domainName\\username). To create a company user, the company id or name needs to be provided in the company entity.
  [Password <String>]: Used to provide a password to the user being created. This will be accepted when the useSystemGeneratePassword tag is false. The password has to be provided in Base64 format.
  [PlanId <Int64?>]: 
  [PlanName <String>]: 
  [UseSystemGeneratePassword <Boolean?>]: Choose to provide a system generated password to the user instead of providing your own password. An email will be sent to the user to reset the password. If it is set to true, password tag need not be provided. If it is set to false, password needs to be provided in the password tag in Base64 format.
  [UserGroups <IIdName[]>]: Provide a list of userGroups that the user should be a part of. Either id or name or both can be provided.
    [Id <Int64?>]: 
    [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvuser
#>
function New-CVUser {
[OutputType([Commvault.Powershell.Models.IIdNameGuid])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICreateUser[]]
    # .
    # To construct, see NOTES section for USERS properties and create a hash table.
    ${Users},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVUser_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a Blackout Window
.Description
Create a Blackout Window
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IIdName
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

TIME <IStartEnd[]>: Refers to the time between which the blackout window will be in effect. It has to be provided in seconds
  [End <Int64?>]: the blackout window is no longer in effect from this point on.
  [Start <Int64?>]: the blackout window comes into effect at this point.
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvv4blackoutwindow
#>
function New-CVV4BlackoutWindow {
[OutputType([Commvault.Powershell.Models.IIdName])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the blackout window to be created.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Refers to backup types to include in the blackout window
    ${BackupOperations},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # the blackout window is no longer in effect from this point on.
    ${BetweenDateEnd},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # the blackout window comes into effect at this point.
    ${BetweenDateStart},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${CompanyId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${CompanyName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Days of the week when the blackout window will be in effect.
    ${Days},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Allows or Denies submitting a job when the blackout window is in effect.
    # If set to false, the job is submitted and resumed once the blackout window ends.
    ${DoNotSubmitJob},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IStartEnd[]]
    # Refers to the time between which the blackout window will be in effect.
    # It has to be provided in seconds
    # To construct, see NOTES section for TIME properties and create a hash table.
    ${Time},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Refers to the weeks of the month that the blackout window will be in effect.
    ${Weeks},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVV4BlackoutWindow_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a VM Group
.Description
Create a VM Group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.ICreateVMGroupResp
.Outputs
Commvault.Powershell.Models.IGenericResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTENTRULEGROUPS <IRuleGroupContent[]>: .
  [MatchRule <String>]: Enum which specifies the whether to match all rules or any of the rules
  [Rules <IRuleContent[]>]: 
    [Condition <String>]: Operation type for VM rules/filters
    [DisplayName <String>]: The display name of the entity to be added
    [Guid <String>]: GUID of the entity to be added as content
    [Name <String>]: name of the VM to be added as content
    [Type <String>]: 
    [Value <String>]: value for the few type of VM Content like powerstate

CONTENTVIRTUALMACHINES <IVirtualMachinecontent[]>: .
  [ExistingCredentialId <Int64?>]: 
  [ExistingCredentialName <String>]: 
  [GuestCredentialAssocId <Int64?>]: Credential association ID given to link entity with credential id.
  [GuestCredentialsPassword <String>]: 
  [GuestCredentialsUserName <String>]: 
  [Guid <String>]: GUID of the VM to be added as content
  [Name <String>]: name of the VM to be added as content
  [Type <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvvmgroupv5
#>
function New-CVVMGroupV5 {
[OutputType([Commvault.Powershell.Models.ICreateVMGroupResp], [Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # subclient name
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if content in vmgroup has to be overwritten, by default it will append the content
    ${ContentOverwrite},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRuleGroupContent[]]
    # .
    # To construct, see NOTES section for CONTENTRULEGROUPS properties and create a hash table.
    ${ContentRuleGroups},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVirtualMachinecontent[]]
    # .
    # To construct, see NOTES section for CONTENTVIRTUALMACHINES properties and create a hash table.
    ${ContentVirtualMachines},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if Intellisnap has to be enabled
    ${EnableIntellisnap},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${HypervisorId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${HypervisorName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Meditech Listener IP of FQDN name
    ${MeditechListenerIP},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Meditech Listener Port
    ${MeditechListenerPort},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # MBF timeout (in seconds)
    ${MeditechMbFtimeout},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Meditech system name
    ${MeditechSystemName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${StorageId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${StorageName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # username to access the network path
    ${UserAccountName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # password to access the network path
    ${UserAccountPassword},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVVMGroupV5_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a VM Group
.Description
Create a VM Group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.ICreateVMGroupResp
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTENTRULEGROUPS <IRuleGroupContent[]>: .
  [MatchRule <String>]: Enum which specifies the whether to match all rules or any of the rules
  [Rules <IRuleContent[]>]: 
    [Condition <String>]: Operation type for VM rules/filters
    [DisplayName <String>]: The display name of the entity to be added
    [Guid <String>]: GUID of the entity to be added as content
    [Name <String>]: name of the VM to be added as content
    [Type <String>]: 
    [Value <String>]: value for the few type of VM Content like powerstate

CONTENTVIRTUALMACHINES <IVirtualMachinecontent[]>: .
  [ExistingCredentialId <Int64?>]: 
  [ExistingCredentialName <String>]: 
  [GuestCredentialAssocId <Int64?>]: Credential association ID given to link entity with credential id.
  [GuestCredentialsPassword <String>]: 
  [GuestCredentialsUserName <String>]: 
  [Guid <String>]: GUID of the VM to be added as content
  [Name <String>]: name of the VM to be added as content
  [Type <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvvmgroup
#>
function New-CVVMGroup {
[OutputType([Commvault.Powershell.Models.ICreateVMGroupResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # subclient name
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if content in vmgroup has to be overwritten, by default it will append the content
    ${ContentOverwrite},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRuleGroupContent[]]
    # .
    # To construct, see NOTES section for CONTENTRULEGROUPS properties and create a hash table.
    ${ContentRuleGroups},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVirtualMachinecontent[]]
    # .
    # To construct, see NOTES section for CONTENTVIRTUALMACHINES properties and create a hash table.
    ${ContentVirtualMachines},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if Intellisnap has to be enabled
    ${EnableIntellisnap},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${HypervisorId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${HypervisorName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Meditech Listener IP of FQDN name
    ${MeditechListenerIP},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Meditech Listener Port
    ${MeditechListenerPort},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # MBF timeout (in seconds)
    ${MeditechMbFtimeout},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Meditech system name
    ${MeditechSystemName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${StorageId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${StorageName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # username to access the network path
    ${UserAccountName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # password to access the network path
    ${UserAccountPassword},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            CreateExpanded = 'CommvaultPowershell.private\New-CVVMGroup_CreateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Mark a triggered alert as read
.Description
Mark a triggered alert as read
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/read-cvtriggeredalert
#>
function Read-CVTriggeredAlert {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Read', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Read', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(ParameterSetName='ReadViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Read = 'CommvaultPowershell.private\Read-CVTriggeredAlert_Read';
            ReadViaIdentity = 'CommvaultPowershell.private\Read-CVTriggeredAlert_ReadViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Disassociate a MediaAgent (cloud Access Path) from a bucket of a cloud storage
.Description
Disassociate a MediaAgent (cloud Access Path) from a bucket of a cloud storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvaccesspath
#>
function Remove-CVAccessPath {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of access path (can be fetched from GET Bucket Details API)
    ${AccessPathId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of Bucket
    ${BucketId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of cloud Storage
    ${CloudStorageId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVAccessPath_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete an AD/LDAP domain
.Description
Delete an AD/LDAP domain
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvadldap
#>
function Remove-CVAdldap {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the AD/LDAP domain
    ${DomainId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Optionally transfer the ownership to user group
    ${TransferToUserGroupId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Optionally transfer the ownership to user
    ${TransferToUserId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVAdldap_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete an agent from a server\nIt is expected that the agent has been deconfigured before performing delete operation.\nBut internally if the agent is not deconfigured, then we force deconfigure it to proceed with delete operation\nExamples of supported agentIds are:\n33-File System,\n106-Virtual Server
.Description
Used to delete an agent from a server\nIt is expected that the agent has been deconfigured before performing delete operation.\nBut internally if the agent is not deconfigured, then we force deconfigure it to proceed with delete operation\nExamples of supported agentIds are:\n33-File System,\n106-Virtual Server
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvagent
#>
function Remove-CVAgent {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the agent to be modified
    ${AgentId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the server to modify
    ${ServerId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVAgent_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete alert definitions
.Description
Delete alert definitions
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvalertdefinition
#>
function Remove-CVAlertDefinition {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVAlertDefinition_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete Backup Destination for a Plan
.Description
Delete Backup Destination for a Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvarchivebackupdestination
#>
function Remove-CVArchiveBackupDestination {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backupDestination to be deleted
    ${BackupDestinationId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to modify
    ${PlanId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVArchiveBackupDestination_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete existing archive plan
.Description
Delete existing archive plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvarchiveplan
#>
function Remove-CVArchivePlan {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the plan
    ${PlanId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVArchivePlan_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Deleting a Storage Array
.Description
Deleting a Storage Array
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvarray
#>
function Remove-CVArray {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVArray_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete Backup Destination.
If trying to delete primary backup destination which is not associated with any plan, it will delete all secondary copies also.
.Description
Delete Backup Destination.
If trying to delete primary backup destination which is not associated with any plan, it will delete all secondary copies also.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvbackupdestinationwithoutplaninfo
#>
function Remove-CVBackupDestinationWithoutPlanInfo {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backupDestination to be deleted
    ${BackupDestinationId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVBackupDestinationWithoutPlanInfo_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete Backup Destination for a Plan
.Description
Delete Backup Destination for a Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvbackupdestination
#>
function Remove-CVBackupDestination {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backupDestination to be deleted
    ${BackupDestinationId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to modify
    ${PlanId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVBackupDestination_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify the properties of an existing mount path
.Description
Modify the properties of an existing mount path
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvbackuplocation
#>
function Remove-CVBackupLocation {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backup location to delete
    ${BackupLocationId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the disk storage to whose backup location has to be deleted
    ${StoragePoolId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Force deletes a backup location.
    ${ForceDelete},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVBackupLocation_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete a Blackout Window
.Description
Used to delete a Blackout Window
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Int32
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvblackoutwindow
#>
function Remove-CVBlackoutWindow {
[OutputType([Commvault.Powershell.Models.IGenericResp], [System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Blackout Window to delete
    ${BlackoutWindowId},

    [Parameter(Position=0, Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify blackout window rule to be removed by Id.
    ${Id},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='Delete', DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(ParameterSetName='Delete', DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(ParameterSetName='Delete', DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(ParameterSetName='Delete')]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(ParameterSetName='Delete', DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(ParameterSetName='Delete', DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(ParameterSetName='Delete', DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVBlackoutWindow_Delete';
            __AllParameterSets = 'CommvaultPowershell.custom\Remove-CVBlackoutWindow';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete the specified bucket of the cloud storage
.Description
Delete the specified bucket of the cloud storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvbucket
#>
function Remove-CVBucket {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of Bucket
    ${BucketId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of cloud Storage
    ${CloudStorageId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Force deletes the bucket when physical deletion of data not possible.
    # It will do DB cleanup only.
    ${ForceDelete},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVBucket_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API is used to delete multiple laptopowner mappings
.Description
API is used to delete multiple laptopowner mappings
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IDeleteLaptopOwnerMapping
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IDeleteLaptopOwnerMapping>: This model accepts the list of laptop owner mapping to be deleted
  LaptopOwnerMapping <Int64[]>: Accepts list of laptop owner mapping ids to be deleted
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvbulklaptopownermappingactiondelete
#>
function Remove-CVBulkLaptopOwnerMappingActionDelete {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='DeleteExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDeleteLaptopOwnerMapping]
    # This model accepts the list of laptop owner mapping to be deleted
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='DeleteExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64[]]
    # Accepts list of laptop owner mapping ids to be deleted
    ${LaptopOwnerMapping},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVBulkLaptopOwnerMappingActionDelete_Delete';
            DeleteExpanded = 'CommvaultPowershell.private\Remove-CVBulkLaptopOwnerMappingActionDelete_DeleteExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete metadata cache of an existing cloud storage
.Description
Delete metadata cache of an existing cloud storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvcloudstoragemetadatacache
#>
function Remove-CVCloudStorageMetadataCache {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of cloud Storage
    ${CloudStorageId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of metadata cache
    ${MetadataCacheId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVCloudStorageMetadataCache_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete existing cloud storage
.Description
Delete existing cloud storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvcloudstorage
#>
function Remove-CVCloudStorage {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of cloud Storage
    ${CloudStorageId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVCloudStorage_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete a company which has been deactivated
.Description
Used to delete a company which has been deactivated
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvcompany
#>
function Remove-CVCompany {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the company to delete
    ${CompanyId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVCompany_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete Credential whose name has been provided
.Description
Delete Credential whose name has been provided
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvcredential
#>
function Remove-CVCredential {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # .
    ${CredentialName},

    [Parameter(ParameterSetName='Delete1', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # .
    ${CredentialId},

    [Parameter(ParameterSetName='DeleteViaIdentity1', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVCredential_Delete';
            Delete1 = 'CommvaultPowershell.private\Remove-CVCredential_Delete1';
            DeleteViaIdentity1 = 'CommvaultPowershell.private\Remove-CVCredential_DeleteViaIdentity1';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete an existing CVFS S3 Bucket
.Description
Used to delete an existing CVFS S3 Bucket
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResponse
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvcvfs3bucket
#>
function Remove-CVCvfS3Bucket {
[OutputType([Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the bucket
    ${Id},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVCvfS3Bucket_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete an existing data classification plan
.Description
Used to delete an existing data classification plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvdcplan
#>
function Remove-CVDcPlan {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVDcPlan_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to delete a deconfigured Kubernetes cluster with clusterId
.Description
API to delete a deconfigured Kubernetes cluster with clusterId
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvdeconfiguredkubernetecluster
#>
function Remove-CVDeconfiguredKuberneteCluster {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # clusterId is the ID of the Kubernetes cluster client
    ${ClusterId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVDeconfiguredKuberneteCluster_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete a media agent to a disk access path
.Description
Used to delete a media agent to a disk access path
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvdiskaccesspath
#>
function Remove-CVDiskAccessPath {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the mount path whose access path has to be deleted
    ${AccessPathId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the mount path whose access path has to be deleted
    ${BackupLocationId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the disk storage pool whose access path has to be deleted
    ${StoragePoolId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVDiskAccessPath_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete a disk storage pool
.Description
Used to delete a disk storage pool
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvdiskstorage
#>
function Remove-CVDiskStorage {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the disk storage pool to delete
    ${StoragePoolId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVDiskStorage_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete tag from the entity tag list
.Description
Used to delete tag from the entity tag list
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cventitytag
#>
function Remove-CVEntityTag {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the tag to delete
    ${TagId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVEntityTag_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to delete failover group DR operation schedule
.Description
API to delete failover group DR operation schedule
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvfailovergroupschedule
#>
function Remove-CVFailoverGroupSchedule {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the failover group
    ${FailoverGroupId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the DR operation schedule
    ${ScheduleId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVFailoverGroupSchedule_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to delete failover group
.Description
API to delete failover group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvfailovergroup
#>
function Remove-CVFailoverGroup {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the failover group
    ${FailoverGroupId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVFailoverGroup_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint is used to delete network topology.
.Description
This endpoint is used to delete network topology.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvfirewalltopology
#>
function Remove-CVFirewallTopology {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # .
    ${TopologyId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVFirewallTopology_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete existing hyperscale storage
.Description
Delete existing hyperscale storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvhyperscalestorage
#>
function Remove-CVHyperScaleStorage {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of hyperscale storage
    ${HyperScaleStorageId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVHyperScaleStorage_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
delete an existing Hypervisor
.Description
delete an existing Hypervisor
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvhypervisor
#>
function Remove-CVHypervisor {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Hypervisor to delete
    ${HypervisorId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVHypervisor_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API for snap instant clone force delete operation.
Please be aware, triggering this API will not delete the clones from the storage array, so ensure that you delete clones on the array before using this operation.
.Description
API for snap instant clone force delete operation.
Please be aware, triggering this API will not delete the clones from the storage array, so ensure that you delete clones on the array before using this operation.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ISnapNodeReq
.Outputs
Commvault.Powershell.Models.ISnapReconResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISnapNodeReq>: Request template for multi node unmount and instant clone delete
  [MountVolumeIds <Int64[]>]: Volume Ids of the Snaps to include for multi node unmount or instant clone delete
  [Volume <ISnapVolumes[]>]: Array of volumes to include for the operation
    SmVolumeId <Int64>: smVolumeId of the snap
    [CommCellId <Int64?>]: Commcell Id of the setup

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

VOLUME <ISnapVolumes[]>: Array of volumes to include for the operation
  SmVolumeId <Int64>: smVolumeId of the snap
  [CommCellId <Int64?>]: Commcell Id of the setup
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvinstantcloneforce
#>
function Remove-CVInstantCloneForce {
[OutputType([Commvault.Powershell.Models.ISnapReconResp])]
[CmdletBinding(DefaultParameterSetName='DeleteExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Parameter(ParameterSetName='DeleteExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='DeleteViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Delete', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapNodeReq]
    # Request template for multi node unmount and instant clone delete
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='DeleteExpanded')]
    [Parameter(ParameterSetName='DeleteViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64[]]
    # Volume Ids of the Snaps to include for multi node unmount or instant clone delete
    ${MountVolumeIds},

    [Parameter(ParameterSetName='DeleteExpanded')]
    [Parameter(ParameterSetName='DeleteViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapVolumes[]]
    # Array of volumes to include for the operation
    # To construct, see NOTES section for VOLUME properties and create a hash table.
    ${Volume},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVInstantCloneForce_Delete';
            DeleteExpanded = 'CommvaultPowershell.private\Remove-CVInstantCloneForce_DeleteExpanded';
            DeleteViaIdentityExpanded = 'CommvaultPowershell.private\Remove-CVInstantCloneForce_DeleteViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete the inventory asset
.Description
Delete the inventory asset
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvinventoryasset
#>
function Remove-CVInventoryAsset {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # FQDN of the asset
    ${AssetId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${InventoryId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVInventoryAsset_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Deleting an inventory
.Description
Deleting an inventory
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvinventory
#>
function Remove-CVInventory {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${InventoryId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVInventory_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete key management server based on Id
.Description
Delete key management server based on Id
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvkeymanagementserver
#>
function Remove-CVKeyManagementServer {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of Key Management Server
    ${KmsId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVKeyManagementServer_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to delete a Kubernetes application group with applicationGroupId
.Description
API to delete a Kubernetes application group with applicationGroupId
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvkuberneteappgroup
#>
function Remove-CVKuberneteAppGroup {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # applicationGroupId is the ID of the Kubernetes application group
    ${ApplicationGroupId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVKuberneteAppGroup_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete Backup Destination for a Plan
.Description
Delete Backup Destination for a Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvlaptopbackupdestination
#>
function Remove-CVLaptopBackupDestination {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backupDestination to be deleted
    ${BackupDestinationId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to modify
    ${PlanId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVLaptopBackupDestination_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete existing laptop plan
.Description
Delete existing laptop plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvlaptopplan
#>
function Remove-CVLaptopPlan {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the plan
    ${PlanId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVLaptopPlan_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete a media agent to a local storage access path
.Description
Used to delete a media agent to a local storage access path
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvlocalaccesspath
#>
function Remove-CVLocalAccessPath {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the mount path whose access path has to be deleted
    ${AccessPathId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the mount path whose access path has to be deleted
    ${BackupLocationId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the local storage pool whose access path has to be deleted
    ${StoragePoolId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVLocalAccessPath_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete an existing mount path of local storage pool.
.Description
Delete an existing mount path of local storage pool.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvlocalbackuplocation
#>
function Remove-CVLocalBackupLocation {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the backup location to delete
    ${BackupLocationId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the local storage pool to whose backup location has to be deleted.
    ${StoragePoolId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Force deletes a backup location.
    ${ForceDelete},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVLocalBackupLocation_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete a local storage pool
.Description
Used to delete a local storage pool
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvlocalstorage
#>
function Remove-CVLocalStorage {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the local storage pool to delete
    ${StoragePoolId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVLocalStorage_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete a media agent.
.Description
Used to delete a media agent.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvmediaagent
#>
function Remove-CVMediaAgent {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the media agent to delete
    ${MediaAgentId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVMediaAgent_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete multiple triggered alerts
.Description
Delete multiple triggered alerts
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IAlertIds
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IAlertIds>: Array of ids of an entity
  [AlertId <Int64[]>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvmultipletriggeredalert
#>
function Remove-CVMultipleTriggeredalert {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='DeleteExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAlertIds]
    # Array of ids of an entity
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='DeleteExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64[]]
    # .
    ${AlertId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVMultipleTriggeredalert_Delete';
            DeleteExpanded = 'CommvaultPowershell.private\Remove-CVMultipleTriggeredalert_DeleteExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete multiple userGroups
.Description
Delete multiple userGroups
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IDeleteMultipleUserGroups
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IDeleteMultipleUserGroups>: .
  [UserGroups <IDeleteUserGroups[]>]: List of userGroups that have to be deleted. Either name or id can be provided. If name and id are both provided, id will be taken into consideration.
    [NewUserGroupId <Int64?>]: 
    [NewUserGroupName <String>]: 
    [NewUserId <Int64?>]: 
    [NewUserName <String>]: 
    [SkipOwnerTransfer <Boolean?>]: 
    [UserGroupId <Int64?>]: 
    [UserGroupName <String>]: 

USERGROUPS <IDeleteUserGroups[]>: List of userGroups that have to be deleted. Either name or id can be provided. If name and id are both provided, id will be taken into consideration.
  [NewUserGroupId <Int64?>]: 
  [NewUserGroupName <String>]: 
  [NewUserId <Int64?>]: 
  [NewUserName <String>]: 
  [SkipOwnerTransfer <Boolean?>]: 
  [UserGroupId <Int64?>]: 
  [UserGroupName <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvmultipleusergroup
#>
function Remove-CVMultipleUserGroup {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='DeleteExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDeleteMultipleUserGroups]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='DeleteExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDeleteUserGroups[]]
    # List of userGroups that have to be deleted.
    # Either name or id can be provided.
    # If name and id are both provided, id will be taken into consideration.
    # To construct, see NOTES section for USERGROUPS properties and create a hash table.
    ${UserGroups},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVMultipleUserGroup_Delete';
            DeleteExpanded = 'CommvaultPowershell.private\Remove-CVMultipleUserGroup_DeleteExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete multiple users
.Description
Delete multiple users
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IDeleteMultipleUsers
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IDeleteMultipleUsers>: Used to delete multiple users and carry out property transfership of deleted users
  [Users <IDeleteUsers[]>]: 
    [NewUserGroupId <Int64?>]: 
    [NewUserGroupName <String>]: 
    [NewUserId <Int64?>]: 
    [NewUserName <String>]: 
    [SkipOwnerTransfer <Boolean?>]: 
    [UserId <Int64?>]: 
    [UserName <String>]: 

USERS <IDeleteUsers[]>: .
  [NewUserGroupId <Int64?>]: 
  [NewUserGroupName <String>]: 
  [NewUserId <Int64?>]: 
  [NewUserName <String>]: 
  [SkipOwnerTransfer <Boolean?>]: 
  [UserId <Int64?>]: 
  [UserName <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvmultipleuser
#>
function Remove-CVMultipleUser {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='DeleteExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDeleteMultipleUsers]
    # Used to delete multiple users and carry out property transfership of deleted users
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='DeleteExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDeleteUsers[]]
    # .
    # To construct, see NOTES section for USERS properties and create a hash table.
    ${Users},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVMultipleUser_Delete';
            DeleteExpanded = 'CommvaultPowershell.private\Remove-CVMultipleUser_DeleteExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete an existing server plan
.Description
Used to delete an existing server plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvobjectstoreplan
#>
function Remove-CVObjectStorePlan {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the object store plan to delete
    ${PlanId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVObjectStorePlan_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Api to delete selected plan rule
.Description
Api to delete selected plan rule
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvplanrule
#>
function Remove-CVPlanRule {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the rule to update in Plan
    ${RuleId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVPlanRule_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete an existing server plan
.Description
Used to delete an existing server plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvplan
#>
function Remove-CVPlan {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the plan to delete
    ${PlanId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVPlan_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete recovery entities for a group
.Description
Delete recovery entities for a group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IDeleteRecoveryEntityReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IDeleteRecoveryEntityReq>: DeleteRecoveryEntityReq
  [RecoveryEntities <Int64[]>]: 
  [RecoveryGroupId <Int64?>]: 
  [RecoveryGroupName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvrecoveryentity
#>
function Remove-CVRecoveryEntity {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='DeleteExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Recovery group Id
    ${RecoveryGroupId},

    [Parameter(ParameterSetName='DeleteViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Delete', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDeleteRecoveryEntityReq]
    # DeleteRecoveryEntityReq
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='DeleteExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(ParameterSetName='DeleteExpanded')]
    [Parameter(ParameterSetName='DeleteViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64[]]
    # .
    ${RecoveryEntities},

    [Parameter(ParameterSetName='DeleteExpanded')]
    [Parameter(ParameterSetName='DeleteViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RecoveryGroupName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVRecoveryEntity_Delete';
            DeleteExpanded = 'CommvaultPowershell.private\Remove-CVRecoveryEntity_DeleteExpanded';
            DeleteViaIdentityExpanded = 'CommvaultPowershell.private\Remove-CVRecoveryEntity_DeleteViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete a specific recovery point store
.Description
Delete a specific recovery point store
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvrecoverypointstore
#>
function Remove-CVRecoveryPointStore {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # .
    ${RpsId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVRecoveryPointStore_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
To delete an exisitng recovery target
.Description
To delete an exisitng recovery target
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvrecoverytarget
#>
function Remove-CVRecoveryTarget {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # id of recovery target
    ${RecoveryTargetId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVRecoveryTarget_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete the region
.Description
Delete the region
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvregion
#>
function Remove-CVRegion {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${RegionId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVRegion_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Deleting an existing request
.Description
Deleting an existing request
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvrequestmanagerrequest
#>
function Remove-CVRequestManagerRequest {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Unique identifier for the request
    ${RequestId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVRequestManagerRequest_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete a role
.Description
Used to delete a role
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvrole
#>
function Remove-CVRole {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Role Id
    ${RoleId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVRole_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete the clone with the given ID before the expiry time
.Description
Delete the clone with the given ID before the expiry time
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResponse
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvs3bucketclone
#>
function Remove-CVS3BucketClone {
[OutputType([Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the cloned bucket
    ${CloneId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the bucket
    ${Id},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVS3BucketClone_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Api to remove associated DC plan from server group
.Description
Api to remove associated DC plan from server group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvservergroupdcplan
#>
function Remove-CVServerGroupDcPlan {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ServerGroupId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Optional parameter.
    # To be set only in case, if caller want to leave child association as-is and decouple them from server group
    ${RemoveChildAssociations},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVServerGroupDcPlan_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete a serverGroup
.Description
Used to delete a serverGroup
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvservergroup
#>
function Remove-CVServerGroup {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the serverGroup to delete
    ${ServerGroupId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVServerGroup_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API for snap instant clone delete operation
.Description
API for snap instant clone delete operation
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ISnapNodeReq
.Outputs
Commvault.Powershell.Models.ISnapReconResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISnapNodeReq>: Request template for multi node unmount and instant clone delete
  [MountVolumeIds <Int64[]>]: Volume Ids of the Snaps to include for multi node unmount or instant clone delete
  [Volume <ISnapVolumes[]>]: Array of volumes to include for the operation
    SmVolumeId <Int64>: smVolumeId of the snap
    [CommCellId <Int64?>]: Commcell Id of the setup

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

VOLUME <ISnapVolumes[]>: Array of volumes to include for the operation
  SmVolumeId <Int64>: smVolumeId of the snap
  [CommCellId <Int64?>]: Commcell Id of the setup
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvsnapinstantclone
#>
function Remove-CVSnapInstantClone {
[OutputType([Commvault.Powershell.Models.ISnapReconResp])]
[CmdletBinding(DefaultParameterSetName='DeleteExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Parameter(ParameterSetName='DeleteExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ArrayId},

    [Parameter(ParameterSetName='DeleteViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Delete', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapNodeReq]
    # Request template for multi node unmount and instant clone delete
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='DeleteExpanded')]
    [Parameter(ParameterSetName='DeleteViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64[]]
    # Volume Ids of the Snaps to include for multi node unmount or instant clone delete
    ${MountVolumeIds},

    [Parameter(ParameterSetName='DeleteExpanded')]
    [Parameter(ParameterSetName='DeleteViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISnapVolumes[]]
    # Array of volumes to include for the operation
    # To construct, see NOTES section for VOLUME properties and create a hash table.
    ${Volume},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVSnapInstantClone_Delete';
            DeleteExpanded = 'CommvaultPowershell.private\Remove-CVSnapInstantClone_DeleteExpanded';
            DeleteViaIdentityExpanded = 'CommvaultPowershell.private\Remove-CVSnapInstantClone_DeleteViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete software cache for server
.Description
Delete software cache for server
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvsoftwarecacheserver
#>
function Remove-CVSoftwareCacheServer {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Software cache client id
    ${ClientId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVSoftwareCacheServer_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete Storage Region for an Elastic Plan
.Description
Delete Storage Region for an Elastic Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvstorageregion
#>
function Remove-CVStorageRegion {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Parameter(ParameterSetName='Delete1', Mandatory)]
    [Parameter(ParameterSetName='Delete2', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to modify
    ${PlanId},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Parameter(ParameterSetName='Delete1', Mandatory)]
    [Parameter(ParameterSetName='Delete2', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # List of region names/ids to be deleted.
    # If region ids are passed, set isRegionIdList=true
    ${RegionList},

    [Parameter(ParameterSetName='DeleteViaIdentity1', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='DeleteViaIdentity2', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # Is regionList a list of region ids
    ${IsRegionIdList},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVStorageRegion_Delete';
            Delete1 = 'CommvaultPowershell.private\Remove-CVStorageRegion_Delete1';
            Delete2 = 'CommvaultPowershell.private\Remove-CVStorageRegion_Delete2';
            DeleteViaIdentity1 = 'CommvaultPowershell.private\Remove-CVStorageRegion_DeleteViaIdentity1';
            DeleteViaIdentity2 = 'CommvaultPowershell.private\Remove-CVStorageRegion_DeleteViaIdentity2';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete Storage Region for a Global Plan
.Description
Delete Storage Region for a Global Plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvstoragetagregion
#>
function Remove-CVStorageTagRegion {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Plan to modify
    ${PlanId},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Region id to be deleted.
    ${RegionId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVStorageTagRegion_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Delete Triggered Alerts
.Description
Delete Triggered Alerts
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvtriggeredalert
#>
function Remove-CVTriggeredAlert {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVTriggeredAlert_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete a user-group
.Description
Used to delete a user-group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvusergroup
#>
function Remove-CVUserGroup {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the user-group to delete
    ${UserGroupId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # If user group properties needn't be transferred to other user or usergroup
    ${SkipOwnerShipTransfer},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # If user group properties needs to be transferred to other user
    ${TransferToUser},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # If user group properties needs to be transferred to other userGroup
    ${TransfertoUserGroup},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVUserGroup_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete a user
.Description
Used to delete a user
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvuser
#>
function Remove-CVUser {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the user to delete
    ${UserId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Management.Automation.SwitchParameter]
    # If user properties needn't be transferred to other user or usergroup
    ${SkipOwnerShipTransfer},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # If user properties needs to be transferred to other user
    ${TransferToUser},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # If user properties needs to be transferred to other userGroup
    ${TransfertoUserGroup},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVUser_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to delete a virtual machine
.Description
Used to delete a virtual machine
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvvirtualmachine
#>
function Remove-CVVirtualMachine {
[Alias('Remove-CVVM')]
[OutputType([Commvault.Powershell.Models.IGenericResp], [System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # The vmUUID can be obtained from GET /virtualMachines UUID property
    ${VMUuid},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # ClientName of the client in which subclient resides.
    ${ClientName},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Parameter(ParameterSetName='ByObject', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the Entity to be removed.
    # Multiple entities can be added using a comma separated list.
    # Virtual machine Name, datastore name etc.
    ${Entity},

    [Parameter(ParameterSetName='ByName')]
    [Parameter(ParameterSetName='ByObject')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # SubclientName from which content should be removed.
    # If this parameter not passed, assumes default subclient.
    ${SubclientName},

    [Parameter(ParameterSetName='ByName')]
    [Parameter(ParameterSetName='ByObject')]
    [Commvault.Powershell.Category('Body')]
    [CVVSAContentEntityType]
    # EntityType can be VMName (default), Host or Cluster etc.
    ${EntityType},

    [Parameter(ParameterSetName='ByName')]
    [Parameter(ParameterSetName='ByObject')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Piped ClientObject of the client in which subclient resides.
    ${ClientObject},

    [Parameter(ParameterSetName='Delete', DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(ParameterSetName='Delete', DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(ParameterSetName='Delete', DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(ParameterSetName='Delete')]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(ParameterSetName='Delete', DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(ParameterSetName='Delete', DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(ParameterSetName='Delete', DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVVirtualMachine_Delete';
            ByName = 'CommvaultPowershell.custom\Remove-CVVirtualMachine';
            ByObject = 'CommvaultPowershell.custom\Remove-CVVirtualMachine';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
delete an existing vm group
.Description
delete an existing vm group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IVmgroupdeleteResponse
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvvmgroup
#>
function Remove-CVVMGroup {
[OutputType([Commvault.Powershell.Models.IVmgroupdeleteResponse], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the vmgroup to delete
    ${VMGroupId},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Delete = 'CommvaultPowershell.private\Remove-CVVMGroup_Delete';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Repair software for client and clients for the given client group(s).
.Description
Repair software for client and clients for the given client group(s).
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IRepairSoftware
.Outputs
System.Int64
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IRepairSoftware>: Request body for server and server group repair software
  Entities <IIdNameGuidType[]>: List of all the client and client groups on which repair software should be run
    [Guid <String>]: 
    [Id <Int64?>]: 
    [Name <String>]: 
    [Type <String>]: 
  InvokedFrom <String>: invokedFrom
  [NotifyWhenJobCompletes <Boolean?>]: Boolean which determines whether to notify when software is repaired.
  [Password <String>]: Corresponding password of the user
  [RebootIfRequired <Boolean?>]: Boolean which determines whether to reboot if required.
  [Username <String>]: If using system credentials, provide the user name

ENTITIES <IIdNameGuidType[]>: List of all the client and client groups on which repair software should be run
  [Guid <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 
  [Type <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/repair-cvsoftware
#>
function Repair-CVSoftware {
[OutputType([System.Int64])]
[CmdletBinding(DefaultParameterSetName='Repair', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Repair', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRepairSoftware]
    # Request body for server and server group repair software
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='RepairExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdNameGuidType[]]
    # List of all the client and client groups on which repair software should be run
    # To construct, see NOTES section for ENTITIES properties and create a hash table.
    ${Entities},

    [Parameter(ParameterSetName='RepairExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # invokedFrom
    ${InvokedFrom},

    [Parameter(ParameterSetName='RepairExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean which determines whether to notify when software is repaired.
    ${NotifyWhenJobCompletes},

    [Parameter(ParameterSetName='RepairExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Corresponding password of the user
    ${Password},

    [Parameter(ParameterSetName='RepairExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean which determines whether to reboot if required.
    ${RebootIfRequired},

    [Parameter(ParameterSetName='RepairExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # If using system credentials, provide the user name
    ${Username},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Repair = 'CommvaultPowershell.private\Repair-CVSoftware_Repair';
            RepairExpanded = 'CommvaultPowershell.private\Repair-CVSoftware_RepairExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Retrieves the list of Requests
.Description
Retrieves the list of Requests
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IRmRequestSummary
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/request-cvmanagerrequestlist
#>
function Request-CVManagerRequestList {
[OutputType([Commvault.Powershell.Models.IRmRequestSummary], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Request', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Source application of the request
    ${CreatedFrom},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Entity id of the source from which data is gathered for the request
    ${SourceEntityId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Entity type of the source from which data is gathered for the request
    ${SourceEntityType},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Request = 'CommvaultPowershell.private\Request-CVManagerRequestList_Request';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
To restore the virtual machines in vmgroup
.Description
To restore the virtual machines in vmgroup
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IVMGroupRestoreRequest
.Outputs
Commvault.Powershell.Models.ICreateTaskRespforBackup
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

AZUREVMINFOLIST <IAzureVMInfo[]>: List of Azure VMs that are to be restored
  [AvailabilityZone <String>]: Azure availablity zones. Defaults to Auto. Values can be as follows: 'Auto' (Select from the source VM config), 'None' (Will not restore to any zone), '{Zone Number}' (Availablity zone number the restored VM should be in. Ex: 2).
  [CreatePublicIP <Boolean?>]: Boolean to specify if VM should have publice IP. Defaults to false.
  [DiskEncryptionSetId <String>]: Azure Disk Encryption Set ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Compute/diskEncryptionSets/{Disk Encryption Set}.
  [DiskEncryptionSetTypeId <String>]: Azure Disk Encryption Type. Values can be: 'EncryptionAtRestWithCustomerKey' or 'EncryptionAtRestWithPlatformAndCustomerKeys' or 'EncryptionAtRestWithPlatformAndCustomerKeys'. For reference: learn.microsoft.com/en-us/dotnet/api/microsoft.azure.management.compute.models.encryptiontype?view=azure-dotnet&viewFallbackFrom=azure-dotnet
  [DiskType <String>]: Disk type to set after restore. Ex: Standard_LRS.
  [Name <String>]: Azure VM name to be set after restore. Defaults to source VM name.
  [Nics <IAzureDestinationInfoNic[]>]: Azure VM network interface list
    [NetworkId <String>]: Azure network ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}.
    [PrivateIPAddress <String>]: Azure private IP address.
    [PublicIPAddress <String>]: Azure publice IP address.
    [PublicIPAddressId <String>]: Azure public IP address ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/publicIPAddresses/{Public IP Address Name}.
    [SubnetId <String>]: Azure subnet ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}/subnets/{Subnet Name}.
  [Region <String>]: Azure region name. Ex: For azure region (West US 3) the region value will be westus3. For reference: learn.microsoft.com/en-us/rest/api/resources/subscriptions/list-locations
  [ResourceGroup <String>]: Azure Resource Group Name. Defaults to source VM resource group name.
  [RestoreAsManagedVM <Boolean?>]: Boolean to specify if VM need to be restored as managed VM. Defaults to true.
  [SecurityGroupId <String>]: Azure security group to be set for the VM. Defaults to source configuration.
  [SourceVMGuid <String>]: Azure VM ID
  [StorageAccount <String>]: Azure staging storage account. Defaults to source storage account.
  [VMSize <String>]: VM size to be after restore. Defaults to --Auto Select--. Ex: Standard_A1.
  [VMTags <INameValue[]>]: Azure VM tag list
    [Name <String>]: 
    [Value <String>]: 

BODY <IVMGroupRestoreRequest>: VM or VMGroup restore request body
  InPlaceRestore <Boolean>: Flag to set if restore is in-place or out-of-place. Defaults to false.
  [AccessNodeGroupId <Int64?>]: 
  [AccessNodeGroupName <String>]: 
  [AccessNodeId <Int64?>]: 
  [AccessNodeName <String>]: 
  [AzureNamePrefix <String>]: Adds prefix for VM display name
  [AzureNameSuffix <String>]: Adds suffix for VM display name
  [AzureVMInfoList <IAzureVMInfo[]>]: List of Azure VMs that are to be restored
    [AvailabilityZone <String>]: Azure availablity zones. Defaults to Auto. Values can be as follows: 'Auto' (Select from the source VM config), 'None' (Will not restore to any zone), '{Zone Number}' (Availablity zone number the restored VM should be in. Ex: 2).
    [CreatePublicIP <Boolean?>]: Boolean to specify if VM should have publice IP. Defaults to false.
    [DiskEncryptionSetId <String>]: Azure Disk Encryption Set ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Compute/diskEncryptionSets/{Disk Encryption Set}.
    [DiskEncryptionSetTypeId <String>]: Azure Disk Encryption Type. Values can be: 'EncryptionAtRestWithCustomerKey' or 'EncryptionAtRestWithPlatformAndCustomerKeys' or 'EncryptionAtRestWithPlatformAndCustomerKeys'. For reference: learn.microsoft.com/en-us/dotnet/api/microsoft.azure.management.compute.models.encryptiontype?view=azure-dotnet&viewFallbackFrom=azure-dotnet
    [DiskType <String>]: Disk type to set after restore. Ex: Standard_LRS.
    [Name <String>]: Azure VM name to be set after restore. Defaults to source VM name.
    [Nics <IAzureDestinationInfoNic[]>]: Azure VM network interface list
      [NetworkId <String>]: Azure network ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}.
      [PrivateIPAddress <String>]: Azure private IP address.
      [PublicIPAddress <String>]: Azure publice IP address.
      [PublicIPAddressId <String>]: Azure public IP address ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/publicIPAddresses/{Public IP Address Name}.
      [SubnetId <String>]: Azure subnet ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}/subnets/{Subnet Name}.
    [Region <String>]: Azure region name. Ex: For azure region (West US 3) the region value will be westus3. For reference: learn.microsoft.com/en-us/rest/api/resources/subscriptions/list-locations
    [ResourceGroup <String>]: Azure Resource Group Name. Defaults to source VM resource group name.
    [RestoreAsManagedVM <Boolean?>]: Boolean to specify if VM need to be restored as managed VM. Defaults to true.
    [SecurityGroupId <String>]: Azure security group to be set for the VM. Defaults to source configuration.
    [SourceVMGuid <String>]: Azure VM ID
    [StorageAccount <String>]: Azure staging storage account. Defaults to source storage account.
    [VMSize <String>]: VM size to be after restore. Defaults to --Auto Select--. Ex: Standard_A1.
    [VMTags <INameValue[]>]: Azure VM tag list
      [Name <String>]: 
      [Value <String>]: 
  [BackupSource <Int64?>]: Backup source information from where you want to restore. 0 (Automatic), 1 (Snap Copy), 2 (Primary), 3 to N (Aux Copy)
  [DestinationId <Int64?>]: 
  [DestinationName <String>]: 
  [GoogleCloudNamePrefix <String>]: Adds prefix for VM display name
  [GoogleCloudNameSuffix <String>]: Adds suffix for VM display name
  [GoogleCloudVMInfoList <IGoogleCloudVMInfo[]>]: List of Google Cloud VMs that are to be restored
    [CreatePublicIP <Boolean?>]: Flag to create external IP after restore. Defaults to false.
    [CustomMetadata <INameValue[]>]: GCP custom metadata key-value pairs
    [InstanceId <String>]: Instance ID of the google cloud virtual machine to be restored. Ex: 123456789123456789.
    [MachineType <String>]: GCP Machine Family. Ex: c2d-highmem-8. Defaults to --Auto Select--. For Reference: cloud.google.com/compute/docs/machine-resource
    [Name <String>]: The new name of the instance after restore. Defaults to source name after restore.
    [NetworkInterfaces <IGoogleCloudNetworkInterfaceInfo[]>]: Google Cloud VM network interfaces list
      [ExternalIP <String>]: External IP Address. Defaults to null and is not set after restore.
      [InternalIP <String>]: Internal IP address. Defaults to the source internal IP after restore.
      [Name <String>]: Name of the network interface card. Ex: nic0.
      [NetworkId <String>]: Network self-link. Format: googleapis.com/compute/v1/projects/<Project ID>/global/networks/{Network Name}. Defaults to source network self-link.
      [NetworkName <String>]: Network Name. Ex: default. Defaults to source network name.
      [SubnetId <String>]: Subnet self-link. Format: googleapis.com/compute/v1/projects/<Project ID>/regions/<Region>/subnetworks/{Subnet Name}. Defaults to source subnet self-link.
    [NodeAffinities <INameValue[]>]: Node affinity for the virtual machine to provision virtual machine as sole tenanat VM. Defaults to no node affinity. Format: '[{name: compute.googleapis.com/node-group-name, value: {Node Group Name} }, {name: compute.googleapis.com/node-name, value: {Node Name} }]'
    [ProjectId <String>]: GCP Project ID
    [Region <String>]: GCP Region. Ex: asia-east1. Defaults to source instance region after restore. For reference: cloud.google.com/compute/docs/regions-zones#available
    [Zone <String>]: GCP zones. Ex: asia-east1-a. Defaults to source instance zone after restore. For reference: cloud.google.com/compute/docs/regions-zones#available
  [NotifyOnJobCompletion <Boolean?>]: Enable email notificaiton for job status. Defaults to false.
  [OverwriteVM <Boolean?>]: Unconditionally overwrite VM during restore. Defaults to false.
  [PowerOnVMAfterRestore <Boolean?>]: Turn ON virtual machine after restore. Defaults to false.
  [RestoreFlavour <String>]: Type of restore for virtual machine
  [ReuseVMClient <Boolean?>]: Reuse the existing VM client instance of creating new one after restore. Defaults to true for inplace restore and false for out of place restore.
  [TransportMode <String>]: Backup transport modes enum

GOOGLECLOUDVMINFOLIST <IGoogleCloudVMInfo[]>: List of Google Cloud VMs that are to be restored
  [CreatePublicIP <Boolean?>]: Flag to create external IP after restore. Defaults to false.
  [CustomMetadata <INameValue[]>]: GCP custom metadata key-value pairs
    [Name <String>]: 
    [Value <String>]: 
  [InstanceId <String>]: Instance ID of the google cloud virtual machine to be restored. Ex: 123456789123456789.
  [MachineType <String>]: GCP Machine Family. Ex: c2d-highmem-8. Defaults to --Auto Select--. For Reference: cloud.google.com/compute/docs/machine-resource
  [Name <String>]: The new name of the instance after restore. Defaults to source name after restore.
  [NetworkInterfaces <IGoogleCloudNetworkInterfaceInfo[]>]: Google Cloud VM network interfaces list
    [ExternalIP <String>]: External IP Address. Defaults to null and is not set after restore.
    [InternalIP <String>]: Internal IP address. Defaults to the source internal IP after restore.
    [Name <String>]: Name of the network interface card. Ex: nic0.
    [NetworkId <String>]: Network self-link. Format: googleapis.com/compute/v1/projects/<Project ID>/global/networks/{Network Name}. Defaults to source network self-link.
    [NetworkName <String>]: Network Name. Ex: default. Defaults to source network name.
    [SubnetId <String>]: Subnet self-link. Format: googleapis.com/compute/v1/projects/<Project ID>/regions/<Region>/subnetworks/{Subnet Name}. Defaults to source subnet self-link.
  [NodeAffinities <INameValue[]>]: Node affinity for the virtual machine to provision virtual machine as sole tenanat VM. Defaults to no node affinity. Format: '[{name: compute.googleapis.com/node-group-name, value: {Node Group Name} }, {name: compute.googleapis.com/node-name, value: {Node Name} }]'
  [ProjectId <String>]: GCP Project ID
  [Region <String>]: GCP Region. Ex: asia-east1. Defaults to source instance region after restore. For reference: cloud.google.com/compute/docs/regions-zones#available
  [Zone <String>]: GCP zones. Ex: asia-east1-a. Defaults to source instance zone after restore. For reference: cloud.google.com/compute/docs/regions-zones#available

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/restore-cvvmgroup
#>
function Restore-CVVMGroup {
[OutputType([Commvault.Powershell.Models.ICreateTaskRespforBackup], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='RestoreExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Restore', Mandatory)]
    [Parameter(ParameterSetName='RestoreExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the VMgroup to backup
    ${VMGroupId},

    [Parameter(ParameterSetName='RestoreViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Restore window UTC from time.
    # Valid Formats: yyyy-MM-ddTHH:mm:ss or yyyy-MM-ddTHH:mm:sszzz or yyyy-MM-dd
    ${FromTime},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Media agent id
    ${MediaAgentId},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Media agent name
    ${MediaAgentName},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.DateTime]
    # Restore window UTC to time.
    # Valid Formats: yyyy-MM-ddTHH:mm:ss or yyyy-MM-ddTHH:mm:sszzz or yyyy-MM-dd
    ${ToTime},

    [Parameter(ParameterSetName='Restore', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='RestoreViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVMGroupRestoreRequest]
    # VM or VMGroup restore request body
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='RestoreExpanded', Mandatory)]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to set if restore is in-place or out-of-place.
    # Defaults to false.
    ${InPlaceRestore},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${AccessNodeGroupId},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${AccessNodeGroupName},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${AccessNodeId},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${AccessNodeName},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Adds prefix for VM display name
    ${AzureNamePrefix},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Adds suffix for VM display name
    ${AzureNameSuffix},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAzureVMInfo[]]
    # List of Azure VMs that are to be restored
    # To construct, see NOTES section for AZUREVMINFOLIST properties and create a hash table.
    ${AzureVMInfoList},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Backup source information from where you want to restore.
    # 0 (Automatic), 1 (Snap Copy), 2 (Primary), 3 to N (Aux Copy)
    ${BackupSource},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${DestinationId},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${DestinationName},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Adds prefix for VM display name
    ${GoogleCloudNamePrefix},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Adds suffix for VM display name
    ${GoogleCloudNameSuffix},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IGoogleCloudVMInfo[]]
    # List of Google Cloud VMs that are to be restored
    # To construct, see NOTES section for GOOGLECLOUDVMINFOLIST properties and create a hash table.
    ${GoogleCloudVMInfoList},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable email notificaiton for job status.
    # Defaults to false.
    ${NotifyOnJobCompletion},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Unconditionally overwrite VM during restore.
    # Defaults to false.
    ${OverwriteVM},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Turn ON virtual machine after restore.
    # Defaults to false.
    ${PowerOnVMAfterRestore},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Type of restore for virtual machine
    ${RestoreFlavour},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Reuse the existing VM client instance of creating new one after restore.
    # Defaults to true for inplace restore and false for out of place restore.
    ${ReuseVMClient},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Backup transport modes enum
    ${TransportMode},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Restore = 'CommvaultPowershell.private\Restore-CVVMGroup_Restore';
            RestoreExpanded = 'CommvaultPowershell.private\Restore-CVVMGroup_RestoreExpanded';
            RestoreViaIdentity = 'CommvaultPowershell.private\Restore-CVVMGroup_RestoreViaIdentity';
            RestoreViaIdentityExpanded = 'CommvaultPowershell.private\Restore-CVVMGroup_RestoreViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
To restore a virtual machine
.Description
To restore a virtual machine
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IVMGroupRestoreRequest
.Outputs
Commvault.Powershell.Models.ICreateTaskRespforBackup
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

AZUREVMINFOLIST <IAzureVMInfo[]>: List of Azure VMs that are to be restored
  [AvailabilityZone <String>]: Azure availablity zones. Defaults to Auto. Values can be as follows: 'Auto' (Select from the source VM config), 'None' (Will not restore to any zone), '{Zone Number}' (Availablity zone number the restored VM should be in. Ex: 2).
  [CreatePublicIP <Boolean?>]: Boolean to specify if VM should have publice IP. Defaults to false.
  [DiskEncryptionSetId <String>]: Azure Disk Encryption Set ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Compute/diskEncryptionSets/{Disk Encryption Set}.
  [DiskEncryptionSetTypeId <String>]: Azure Disk Encryption Type. Values can be: 'EncryptionAtRestWithCustomerKey' or 'EncryptionAtRestWithPlatformAndCustomerKeys' or 'EncryptionAtRestWithPlatformAndCustomerKeys'. For reference: learn.microsoft.com/en-us/dotnet/api/microsoft.azure.management.compute.models.encryptiontype?view=azure-dotnet&viewFallbackFrom=azure-dotnet
  [DiskType <String>]: Disk type to set after restore. Ex: Standard_LRS.
  [Name <String>]: Azure VM name to be set after restore. Defaults to source VM name.
  [Nics <IAzureDestinationInfoNic[]>]: Azure VM network interface list
    [NetworkId <String>]: Azure network ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}.
    [PrivateIPAddress <String>]: Azure private IP address.
    [PublicIPAddress <String>]: Azure publice IP address.
    [PublicIPAddressId <String>]: Azure public IP address ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/publicIPAddresses/{Public IP Address Name}.
    [SubnetId <String>]: Azure subnet ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}/subnets/{Subnet Name}.
  [Region <String>]: Azure region name. Ex: For azure region (West US 3) the region value will be westus3. For reference: learn.microsoft.com/en-us/rest/api/resources/subscriptions/list-locations
  [ResourceGroup <String>]: Azure Resource Group Name. Defaults to source VM resource group name.
  [RestoreAsManagedVM <Boolean?>]: Boolean to specify if VM need to be restored as managed VM. Defaults to true.
  [SecurityGroupId <String>]: Azure security group to be set for the VM. Defaults to source configuration.
  [SourceVMGuid <String>]: Azure VM ID
  [StorageAccount <String>]: Azure staging storage account. Defaults to source storage account.
  [VMSize <String>]: VM size to be after restore. Defaults to --Auto Select--. Ex: Standard_A1.
  [VMTags <INameValue[]>]: Azure VM tag list
    [Name <String>]: 
    [Value <String>]: 

BODY <IVMGroupRestoreRequest>: VM or VMGroup restore request body
  InPlaceRestore <Boolean>: Flag to set if restore is in-place or out-of-place. Defaults to false.
  [AccessNodeGroupId <Int64?>]: 
  [AccessNodeGroupName <String>]: 
  [AccessNodeId <Int64?>]: 
  [AccessNodeName <String>]: 
  [AzureNamePrefix <String>]: Adds prefix for VM display name
  [AzureNameSuffix <String>]: Adds suffix for VM display name
  [AzureVMInfoList <IAzureVMInfo[]>]: List of Azure VMs that are to be restored
    [AvailabilityZone <String>]: Azure availablity zones. Defaults to Auto. Values can be as follows: 'Auto' (Select from the source VM config), 'None' (Will not restore to any zone), '{Zone Number}' (Availablity zone number the restored VM should be in. Ex: 2).
    [CreatePublicIP <Boolean?>]: Boolean to specify if VM should have publice IP. Defaults to false.
    [DiskEncryptionSetId <String>]: Azure Disk Encryption Set ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Compute/diskEncryptionSets/{Disk Encryption Set}.
    [DiskEncryptionSetTypeId <String>]: Azure Disk Encryption Type. Values can be: 'EncryptionAtRestWithCustomerKey' or 'EncryptionAtRestWithPlatformAndCustomerKeys' or 'EncryptionAtRestWithPlatformAndCustomerKeys'. For reference: learn.microsoft.com/en-us/dotnet/api/microsoft.azure.management.compute.models.encryptiontype?view=azure-dotnet&viewFallbackFrom=azure-dotnet
    [DiskType <String>]: Disk type to set after restore. Ex: Standard_LRS.
    [Name <String>]: Azure VM name to be set after restore. Defaults to source VM name.
    [Nics <IAzureDestinationInfoNic[]>]: Azure VM network interface list
      [NetworkId <String>]: Azure network ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}.
      [PrivateIPAddress <String>]: Azure private IP address.
      [PublicIPAddress <String>]: Azure publice IP address.
      [PublicIPAddressId <String>]: Azure public IP address ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/publicIPAddresses/{Public IP Address Name}.
      [SubnetId <String>]: Azure subnet ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}/subnets/{Subnet Name}.
    [Region <String>]: Azure region name. Ex: For azure region (West US 3) the region value will be westus3. For reference: learn.microsoft.com/en-us/rest/api/resources/subscriptions/list-locations
    [ResourceGroup <String>]: Azure Resource Group Name. Defaults to source VM resource group name.
    [RestoreAsManagedVM <Boolean?>]: Boolean to specify if VM need to be restored as managed VM. Defaults to true.
    [SecurityGroupId <String>]: Azure security group to be set for the VM. Defaults to source configuration.
    [SourceVMGuid <String>]: Azure VM ID
    [StorageAccount <String>]: Azure staging storage account. Defaults to source storage account.
    [VMSize <String>]: VM size to be after restore. Defaults to --Auto Select--. Ex: Standard_A1.
    [VMTags <INameValue[]>]: Azure VM tag list
      [Name <String>]: 
      [Value <String>]: 
  [BackupSource <Int64?>]: Backup source information from where you want to restore. 0 (Automatic), 1 (Snap Copy), 2 (Primary), 3 to N (Aux Copy)
  [DestinationId <Int64?>]: 
  [DestinationName <String>]: 
  [GoogleCloudNamePrefix <String>]: Adds prefix for VM display name
  [GoogleCloudNameSuffix <String>]: Adds suffix for VM display name
  [GoogleCloudVMInfoList <IGoogleCloudVMInfo[]>]: List of Google Cloud VMs that are to be restored
    [CreatePublicIP <Boolean?>]: Flag to create external IP after restore. Defaults to false.
    [CustomMetadata <INameValue[]>]: GCP custom metadata key-value pairs
    [InstanceId <String>]: Instance ID of the google cloud virtual machine to be restored. Ex: 123456789123456789.
    [MachineType <String>]: GCP Machine Family. Ex: c2d-highmem-8. Defaults to --Auto Select--. For Reference: cloud.google.com/compute/docs/machine-resource
    [Name <String>]: The new name of the instance after restore. Defaults to source name after restore.
    [NetworkInterfaces <IGoogleCloudNetworkInterfaceInfo[]>]: Google Cloud VM network interfaces list
      [ExternalIP <String>]: External IP Address. Defaults to null and is not set after restore.
      [InternalIP <String>]: Internal IP address. Defaults to the source internal IP after restore.
      [Name <String>]: Name of the network interface card. Ex: nic0.
      [NetworkId <String>]: Network self-link. Format: googleapis.com/compute/v1/projects/<Project ID>/global/networks/{Network Name}. Defaults to source network self-link.
      [NetworkName <String>]: Network Name. Ex: default. Defaults to source network name.
      [SubnetId <String>]: Subnet self-link. Format: googleapis.com/compute/v1/projects/<Project ID>/regions/<Region>/subnetworks/{Subnet Name}. Defaults to source subnet self-link.
    [NodeAffinities <INameValue[]>]: Node affinity for the virtual machine to provision virtual machine as sole tenanat VM. Defaults to no node affinity. Format: '[{name: compute.googleapis.com/node-group-name, value: {Node Group Name} }, {name: compute.googleapis.com/node-name, value: {Node Name} }]'
    [ProjectId <String>]: GCP Project ID
    [Region <String>]: GCP Region. Ex: asia-east1. Defaults to source instance region after restore. For reference: cloud.google.com/compute/docs/regions-zones#available
    [Zone <String>]: GCP zones. Ex: asia-east1-a. Defaults to source instance zone after restore. For reference: cloud.google.com/compute/docs/regions-zones#available
  [NotifyOnJobCompletion <Boolean?>]: Enable email notificaiton for job status. Defaults to false.
  [OverwriteVM <Boolean?>]: Unconditionally overwrite VM during restore. Defaults to false.
  [PowerOnVMAfterRestore <Boolean?>]: Turn ON virtual machine after restore. Defaults to false.
  [RestoreFlavour <String>]: Type of restore for virtual machine
  [ReuseVMClient <Boolean?>]: Reuse the existing VM client instance of creating new one after restore. Defaults to true for inplace restore and false for out of place restore.
  [TransportMode <String>]: Backup transport modes enum

GOOGLECLOUDVMINFOLIST <IGoogleCloudVMInfo[]>: List of Google Cloud VMs that are to be restored
  [CreatePublicIP <Boolean?>]: Flag to create external IP after restore. Defaults to false.
  [CustomMetadata <INameValue[]>]: GCP custom metadata key-value pairs
    [Name <String>]: 
    [Value <String>]: 
  [InstanceId <String>]: Instance ID of the google cloud virtual machine to be restored. Ex: 123456789123456789.
  [MachineType <String>]: GCP Machine Family. Ex: c2d-highmem-8. Defaults to --Auto Select--. For Reference: cloud.google.com/compute/docs/machine-resource
  [Name <String>]: The new name of the instance after restore. Defaults to source name after restore.
  [NetworkInterfaces <IGoogleCloudNetworkInterfaceInfo[]>]: Google Cloud VM network interfaces list
    [ExternalIP <String>]: External IP Address. Defaults to null and is not set after restore.
    [InternalIP <String>]: Internal IP address. Defaults to the source internal IP after restore.
    [Name <String>]: Name of the network interface card. Ex: nic0.
    [NetworkId <String>]: Network self-link. Format: googleapis.com/compute/v1/projects/<Project ID>/global/networks/{Network Name}. Defaults to source network self-link.
    [NetworkName <String>]: Network Name. Ex: default. Defaults to source network name.
    [SubnetId <String>]: Subnet self-link. Format: googleapis.com/compute/v1/projects/<Project ID>/regions/<Region>/subnetworks/{Subnet Name}. Defaults to source subnet self-link.
  [NodeAffinities <INameValue[]>]: Node affinity for the virtual machine to provision virtual machine as sole tenanat VM. Defaults to no node affinity. Format: '[{name: compute.googleapis.com/node-group-name, value: {Node Group Name} }, {name: compute.googleapis.com/node-name, value: {Node Name} }]'
  [ProjectId <String>]: GCP Project ID
  [Region <String>]: GCP Region. Ex: asia-east1. Defaults to source instance region after restore. For reference: cloud.google.com/compute/docs/regions-zones#available
  [Zone <String>]: GCP zones. Ex: asia-east1-a. Defaults to source instance zone after restore. For reference: cloud.google.com/compute/docs/regions-zones#available

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/restore-cvvm
#>
function Restore-CVVM {
[OutputType([Commvault.Powershell.Models.ICreateTaskRespforBackup], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='RestoreExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Restore', Mandatory)]
    [Parameter(ParameterSetName='RestoreExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # .
    ${VMGuid},

    [Parameter(ParameterSetName='RestoreViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Restore', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='RestoreViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVMGroupRestoreRequest]
    # VM or VMGroup restore request body
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='RestoreExpanded', Mandatory)]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag to set if restore is in-place or out-of-place.
    # Defaults to false.
    ${InPlaceRestore},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${AccessNodeGroupId},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${AccessNodeGroupName},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${AccessNodeId},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${AccessNodeName},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Adds prefix for VM display name
    ${AzureNamePrefix},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Adds suffix for VM display name
    ${AzureNameSuffix},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAzureVMInfo[]]
    # List of Azure VMs that are to be restored
    # To construct, see NOTES section for AZUREVMINFOLIST properties and create a hash table.
    ${AzureVMInfoList},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Backup source information from where you want to restore.
    # 0 (Automatic), 1 (Snap Copy), 2 (Primary), 3 to N (Aux Copy)
    ${BackupSource},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${DestinationId},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${DestinationName},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Adds prefix for VM display name
    ${GoogleCloudNamePrefix},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Adds suffix for VM display name
    ${GoogleCloudNameSuffix},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IGoogleCloudVMInfo[]]
    # List of Google Cloud VMs that are to be restored
    # To construct, see NOTES section for GOOGLECLOUDVMINFOLIST properties and create a hash table.
    ${GoogleCloudVMInfoList},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable email notificaiton for job status.
    # Defaults to false.
    ${NotifyOnJobCompletion},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Unconditionally overwrite VM during restore.
    # Defaults to false.
    ${OverwriteVM},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Turn ON virtual machine after restore.
    # Defaults to false.
    ${PowerOnVMAfterRestore},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Type of restore for virtual machine
    ${RestoreFlavour},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Reuse the existing VM client instance of creating new one after restore.
    # Defaults to true for inplace restore and false for out of place restore.
    ${ReuseVMClient},

    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Backup transport modes enum
    ${TransportMode},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Restore = 'CommvaultPowershell.private\Restore-CVVM_Restore';
            RestoreExpanded = 'CommvaultPowershell.private\Restore-CVVM_RestoreExpanded';
            RestoreViaIdentity = 'CommvaultPowershell.private\Restore-CVVM_RestoreViaIdentity';
            RestoreViaIdentityExpanded = 'CommvaultPowershell.private\Restore-CVVM_RestoreViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
To test Email settings
.Description
To test Email settings
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ISendTestMailReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISendTestMailReq>: .
  SenderEmail <String>: The sender email address used for emails sent from the software.
  SenderName <String>: The sender name used for emails sent from the software.
  SmtpPort <Int64>: The port number that connects to the mail server.
  SmtpServerName <String>: The name of the mail server that sends alerts, scheduled reports, log files, and additional information.
  [EncryptionAlgorithm <String>]: 
  [Password <String>]: If password is specified, username must also be specified. password should be a base 64 encoded string. To use previoulsy saved username and password, leave out username and password in payload.
  [UseAuthentication <Boolean?>]: The option to use authentication on the mail server. This is typically used in external or internet mail server configurations.
  [Username <String>]: If username is specified, password field must also be specified. To use previously saved username and password, leave out username and password in payload.
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/send-cvtestmailreq
#>
function Send-CVTestMailReq {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='SendExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Send', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISendTestMailReq]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='SendExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The sender email address used for emails sent from the software.
    ${SenderEmail},

    [Parameter(ParameterSetName='SendExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The sender name used for emails sent from the software.
    ${SenderName},

    [Parameter(ParameterSetName='SendExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The port number that connects to the mail server.
    ${SmtpPort},

    [Parameter(ParameterSetName='SendExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The name of the mail server that sends alerts, scheduled reports, log files, and additional information.
    ${SmtpServerName},

    [Parameter(ParameterSetName='SendExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${EncryptionAlgorithm},

    [Parameter(ParameterSetName='SendExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # If password is specified, username must also be specified.
    # password should be a base 64 encoded string.
    # To use previoulsy saved username and password, leave out username and password in payload.
    ${Password},

    [Parameter(ParameterSetName='SendExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # The option to use authentication on the mail server.
    # This is typically used in external or internet mail server configurations.
    ${UseAuthentication},

    [Parameter(ParameterSetName='SendExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # If username is specified, password field must also be specified.
    # To use previously saved username and password, leave out username and password in payload.
    ${Username},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Send = 'CommvaultPowershell.private\Send-CVTestMailReq_Send';
            SendExpanded = 'CommvaultPowershell.private\Send-CVTestMailReq_SendExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Updates owner permissions and/or automatic laptop ownership assignment
.Description
Updates owner permissions and/or automatic laptop ownership assignment
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IAccessControl
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IAccessControl>: Owner permissions and laptop ownership details
  [AutomaticLaptopOwnershipAssignmentAssignLaptopOwnerAutomatically <Boolean?>]: Whether the laptop ownership assignment is automatic or not
  [AutomaticLaptopOwnershipAssignmentLaptopOwnerOption <String>]: Options to automatically assign laptop owners
  [AutomaticLaptopOwnershipAssignmentUserGroups <String>]: Comma seperated usergroups to add users from, when the laptopOwnerOption is 'ALL_USERS_OF_USERGROUPS'
  [OwnerPermissions <IIdName[]>]: List of owner permissions
    [Id <Int64?>]: 
    [Name <String>]: 

OWNERPERMISSIONS <IIdName[]>: List of owner permissions
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvaccesscontrol
#>
function Set-CVAccessControl {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='PutExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Put', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAccessControl]
    # Owner permissions and laptop ownership details
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Whether the laptop ownership assignment is automatic or not
    ${AutomaticLaptopOwnershipAssignmentAssignLaptopOwnerAutomatically},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Options to automatically assign laptop owners
    ${AutomaticLaptopOwnershipAssignmentLaptopOwnerOption},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Comma seperated usergroups to add users from, when the laptopOwnerOption is 'ALL_USERS_OF_USERGROUPS'
    ${AutomaticLaptopOwnershipAssignmentUserGroups},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # List of owner permissions
    # To construct, see NOTES section for OWNERPERMISSIONS properties and create a hash table.
    ${OwnerPermissions},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Put = 'CommvaultPowershell.private\Set-CVAccessControl_Put';
            PutExpanded = 'CommvaultPowershell.private\Set-CVAccessControl_PutExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Update an AD/LDAP domain
.Description
Update an AD/LDAP domain
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ATTRIBUTEMAP <ILdapAttribute[]>: List of overridden attribute mappings for the LDAP domain. Valid only if the directoryType is LDAP_SERVER.
  Id <Int64>: ID of the attribute
  Value <String>: Current value of the attribute
  [DefaultValue <String>]: Default value of the attribute
  [IsOverridden <Boolean?>]: Denotes if the value of the attribute is overridden
  [Name <String>]: Name of the attribute

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

LDAPQUERYPARAMETERS <ILdapAttribute[]>: List of overridden query parameters for the LDAP domain. Valid only if the directory type is LDAP_SERVER
  Id <Int64>: ID of the attribute
  Value <String>: Current value of the attribute
  [DefaultValue <String>]: Default value of the attribute
  [IsOverridden <Boolean?>]: Denotes if the value of the attribute is overridden
  [Name <String>]: Name of the attribute

PROXIES <IIdName[]>: List of proxies used to connect to the domain. Available only if accessViaClient is true.
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvadldap
#>
function Set-CVAdldap {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the AD/LDAP domain
    ${DomainId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Directory type of an AD/LDAP domain
    ${DirectoryType},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The fully qualified domain name, for example, my.domain.example.com
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Denotes if the domain is to be accessed via a proxy
    ${AccessViaClient},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ILdapAttribute[]]
    # List of overridden attribute mappings for the LDAP domain.
    # Valid only if the directoryType is LDAP_SERVER.
    # To construct, see NOTES section for ATTRIBUTEMAP properties and create a hash table.
    ${AttributeMap},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Base DN for card users
    ${BaseDnForCardUsers},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Denotes if SSO should be enabled for the domain.
    # Valid only for ACTIVE_DIRECTORY.
    ${EnableSso},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The fully qualified domain name that you use to identify this network resource.
    # Required only if directoryType is LDAP_SERVER
    ${Host1},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ILdapAttribute[]]
    # List of overridden query parameters for the LDAP domain.
    # Valid only if the directory type is LDAP_SERVER
    # To construct, see NOTES section for LDAPQUERYPARAMETERS properties and create a hash table.
    ${LdapQueryParameters},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The fully qualified domain name that you use to identify this network resource.
    # Required only if directoryType is ACTIVE_DIRECTORY, OPEN_LDAP or ORACLE_DIRECTORY
    ${NetbiosName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The fully qualified domain name that you use to identify this network resource.
    # Required only if directoryType is APPLE_DIRECTORY_SERVICE
    ${OsxServerName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Password for the domain user.
    # Should be in Base64 encoded format.
    ${Password},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # List of proxies used to connect to the domain.
    # Available only if accessViaClient is true.
    # To construct, see NOTES section for PROXIES properties and create a hash table.
    ${Proxies},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean to indicate if the app use secure LDAP.
    # Valid only for directory types - ACTIVE_DIRECTORY, ORACLE_DIRECTORY and LDAP_SERVER.
    ${UseSecureLdap},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The username for a user who has at least read permission for the domain
    ${Username},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVAdldap_UpdateExpanded';
            UpdateViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVAdldap_UpdateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Update a company's laptop admins.
.Description
Update a company's laptop admins.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

LAPTOPADMINS <IIdNameType[]>: List of laptop admins (users or user groups)
  [Id <Int64?>]: 
  [Name <String>]: 
  [Type <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvcompanylaptopadmin
#>
function Set-CVCompanyLaptopAdmin {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${CompanyId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdNameType[]]
    # List of laptop admins (users or user groups)
    # To construct, see NOTES section for LAPTOPADMINS properties and create a hash table.
    ${LaptopAdmins},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # UpdateOperationType
    ${OperationType},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVCompanyLaptopAdmin_UpdateExpanded';
            UpdateViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVCompanyLaptopAdmin_UpdateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Assigns company's timezone as the timezone for servers with no packages installed
.Description
Assigns company's timezone as the timezone for servers with no packages installed
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CLIENTS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvcompanytimezone
#>
function Set-CVCompanyTimezone {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the company whose timezone is used to update timezone of servers (with no packages)
    ${CompanyId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for CLIENTS properties and create a hash table.
    ${Clients},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean which determines if all servers(with no package) should be updated with the company timezone.
    ${UpdateAll},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVCompanyTimezone_UpdateExpanded';
            UpdateViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVCompanyTimezone_UpdateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to update CVFS S3 Bucket properties and User Access
.Description
Used to update CVFS S3 Bucket properties and User Access
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvcvfs3bucket
#>
function Set-CVCvfS3Bucket {
[OutputType([Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the bucket
    ${Id},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The size of the bucket in GB
    ${BucketSize},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${UserId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${UserName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Add or remove user's read-write/read-only permission to access the bucket
    ${UserOperation},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # To enable/suspend the versioning on the CVFS S3 bucket
    ${Versioning},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVCvfS3Bucket_UpdateExpanded';
            UpdateViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVCvfS3Bucket_UpdateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Configure SMTP server settings.
.Description
Configure SMTP server settings.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IConfigureSmtpServerReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IConfigureSmtpServerReq>: ConfigureSMTPServerReq
  SenderEmail <String>: The sender email address used for emails sent from the software.
  SenderName <String>: The sender name used for emails sent from the software.
  SmtpPort <Int64>: The port number that connects to the mail server.
  SmtpServerName <String>: The name of the mail server that sends alerts, scheduled reports, log files, and additional information.
  [EncryptionAlgorithm <String>]: 
  [Password <String>]: Password must be in base64 encoded format. Similar to username, if authentication on the mail server is required, this option is required.
  [Username <String>]: This option is used when authentication on the mail server is required
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvemailserver
#>
function Set-CVEmailServer {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Configure', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IConfigureSmtpServerReq]
    # ConfigureSMTPServerReq
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ConfigureExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The sender email address used for emails sent from the software.
    ${SenderEmail},

    [Parameter(ParameterSetName='ConfigureExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The sender name used for emails sent from the software.
    ${SenderName},

    [Parameter(ParameterSetName='ConfigureExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The port number that connects to the mail server.
    ${SmtpPort},

    [Parameter(ParameterSetName='ConfigureExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The name of the mail server that sends alerts, scheduled reports, log files, and additional information.
    ${SmtpServerName},

    [Parameter(ParameterSetName='ConfigureExpanded')]
    [Parameter(ParameterSetName='UpdateExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${EncryptionAlgorithm},

    [Parameter(ParameterSetName='ConfigureExpanded')]
    [Parameter(ParameterSetName='UpdateExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Password must be in base64 encoded format.
    # Similar to username, if authentication on the mail server is required, this option is required.
    ${Password},

    [Parameter(ParameterSetName='ConfigureExpanded')]
    [Parameter(ParameterSetName='UpdateExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # This option is used when authentication on the mail server is required
    ${Username},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # The option to use authentication on the mail server.
    # This is typically used in external or internet mail server configurations.
    ${UseAuthentication},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Configure = 'CommvaultPowershell.private\Set-CVEmailServer_Configure';
            ConfigureExpanded = 'CommvaultPowershell.private\Set-CVEmailServer_ConfigureExpanded';
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVEmailServer_UpdateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint is used to edit network topology.
.Description
This endpoint is used to edit network topology.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IFirewallTopologyCreateReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IFirewallTopologyCreateReq>: FirewallTopologyReq
  [ClientType <String>]: The type of clients associated with the topology.
  [EncryptTraffic <Boolean?>]: Flag determining if we want the data from tunnel to use HTTPS protocol
  [FirewallGroups <IFirewallTopologyGroups[]>]: 
    [AdvancedOptionKeepAliveInterval <Int64?>]: The interval in seconds for sending keep-alive packets, to maintain the session if backup traffic has an extended pause.
    [AdvancedOptionTunnelPort <Int64?>]: The port defined for communications
    [ClientGroupId <Int64?>]: The id of the client group
    [GroupType <String>]: FirewallFwGroupType
    [Mnemonic <String>]: Custom names(mnemonics) given to pre-defined smart client groups
  [TopologyName <String>]: 
  [TopologyType <String>]: The type of topology of client groups (and sometimes network gateway) for this instance.
  [TunnelProtocol <String>]: The protocol for outgoing communication
  [TunnelsPerRoute <Int64?>]: The number of tunnel connections per route
  [UseWildCardProxy <Boolean?>]: Flag determining wether network gateways are used to connect all infrastructure machines

FIREWALLGROUPS <IFirewallTopologyGroups[]>: .
  [AdvancedOptionKeepAliveInterval <Int64?>]: The interval in seconds for sending keep-alive packets, to maintain the session if backup traffic has an extended pause.
  [AdvancedOptionTunnelPort <Int64?>]: The port defined for communications
  [ClientGroupId <Int64?>]: The id of the client group
  [GroupType <String>]: FirewallFwGroupType
  [Mnemonic <String>]: Custom names(mnemonics) given to pre-defined smart client groups

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvfirewalltopology
#>
function Set-CVFirewallTopology {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='PutExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Put', Mandatory)]
    [Parameter(ParameterSetName='PutExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # .
    ${TopologyId},

    [Parameter(ParameterSetName='PutViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='PutViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Put', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='PutViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IFirewallTopologyCreateReq]
    # FirewallTopologyReq
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PutExpanded')]
    [Parameter(ParameterSetName='PutViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The type of clients associated with the topology.
    ${ClientType},

    [Parameter(ParameterSetName='PutExpanded')]
    [Parameter(ParameterSetName='PutViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag determining if we want the data from tunnel to use HTTPS protocol
    ${EncryptTraffic},

    [Parameter(ParameterSetName='PutExpanded')]
    [Parameter(ParameterSetName='PutViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IFirewallTopologyGroups[]]
    # .
    # To construct, see NOTES section for FIREWALLGROUPS properties and create a hash table.
    ${FirewallGroups},

    [Parameter(ParameterSetName='PutExpanded')]
    [Parameter(ParameterSetName='PutViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${TopologyName},

    [Parameter(ParameterSetName='PutExpanded')]
    [Parameter(ParameterSetName='PutViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The type of topology of client groups (and sometimes network gateway) for this instance.
    ${TopologyType},

    [Parameter(ParameterSetName='PutExpanded')]
    [Parameter(ParameterSetName='PutViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The protocol for outgoing communication
    ${TunnelProtocol},

    [Parameter(ParameterSetName='PutExpanded')]
    [Parameter(ParameterSetName='PutViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The number of tunnel connections per route
    ${TunnelsPerRoute},

    [Parameter(ParameterSetName='PutExpanded')]
    [Parameter(ParameterSetName='PutViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Flag determining wether network gateways are used to connect all infrastructure machines
    ${UseWildCardProxy},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Put = 'CommvaultPowershell.private\Set-CVFirewallTopology_Put';
            PutExpanded = 'CommvaultPowershell.private\Set-CVFirewallTopology_PutExpanded';
            PutViaIdentity = 'CommvaultPowershell.private\Set-CVFirewallTopology_PutViaIdentity';
            PutViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVFirewallTopology_PutViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Endpoint to Change the Access Node
.Description
Endpoint to Change the Access Node
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IPathsPghlw2V4HypervisorHypervisoridAccessnodePutRequestbodyContentApplicationJsonSchema
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IPathsPghlw2V4HypervisorHypervisoridAccessnodePutRequestbodyContentApplicationJsonSchema>: .
  [AccessNodeId <Int64?>]: 
  [AccessNodeName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvhypervisoraccessnode
#>
function Set-CVHypervisorAccessNode {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='SetExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Set', Mandatory)]
    [Parameter(ParameterSetName='SetExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Hypervisor ID to update the Access Node
    ${HypervisorId},

    [Parameter(ParameterSetName='SetViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SetViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Set', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPathsPghlw2V4HypervisorHypervisoridAccessnodePutRequestbodyContentApplicationJsonSchema]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='SetExpanded')]
    [Parameter(ParameterSetName='SetViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${AccessNodeId},

    [Parameter(ParameterSetName='SetExpanded')]
    [Parameter(ParameterSetName='SetViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${AccessNodeName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Set = 'CommvaultPowershell.private\Set-CVHypervisorAccessNode_Set';
            SetExpanded = 'CommvaultPowershell.private\Set-CVHypervisorAccessNode_SetExpanded';
            SetViaIdentity = 'CommvaultPowershell.private\Set-CVHypervisorAccessNode_SetViaIdentity';
            SetViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVHypervisorAccessNode_SetViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Endpoint to set FBR
.Description
Endpoint to set FBR
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IPaths1OwzkoeV4HypervisorHypervisoridFbrPutRequestbodyContentApplicationJsonSchema
.Outputs
Commvault.Powershell.Models.ICreateHypervisorResp
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IPaths1OwzkoeV4HypervisorHypervisoridFbrPutRequestbodyContentApplicationJsonSchema>: .
  [FbrmaId <Int64?>]: 
  [FbrmaName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvhypervisorfbr
#>
function Set-CVHypervisorFbr {
[OutputType([Commvault.Powershell.Models.ICreateHypervisorResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='SetExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Set', Mandatory)]
    [Parameter(ParameterSetName='SetExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Linux Media Agent to set as FBR for linux File based restores
    ${HypervisorId},

    [Parameter(ParameterSetName='SetViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SetViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Set', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPaths1OwzkoeV4HypervisorHypervisoridFbrPutRequestbodyContentApplicationJsonSchema]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='SetExpanded')]
    [Parameter(ParameterSetName='SetViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${FbrmaId},

    [Parameter(ParameterSetName='SetExpanded')]
    [Parameter(ParameterSetName='SetViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${FbrmaName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Set = 'CommvaultPowershell.private\Set-CVHypervisorFbr_Set';
            SetExpanded = 'CommvaultPowershell.private\Set-CVHypervisorFbr_SetExpanded';
            SetViaIdentity = 'CommvaultPowershell.private\Set-CVHypervisorFbr_SetViaIdentity';
            SetViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVHypervisorFbr_SetViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Edit a Restore modifier
.Description
Edit a Restore modifier
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IK8SRestoreModifierApireq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IK8SRestoreModifierApireq>: Request body for K8s Modifier
  [ModifierYaml <String>]: Restore Modifier YAML

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvk8srestoremodifier
#>
function Set-CVK8SRestoreModifier {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='SetExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Set', Mandatory)]
    [Parameter(ParameterSetName='SetExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the cluster whose modifier has to be modified.
    ${ClusterId},

    [Parameter(ParameterSetName='Set', Mandatory)]
    [Parameter(ParameterSetName='SetExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # Name of the modifier to be modified.
    ${ModifierName},

    [Parameter(ParameterSetName='SetViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SetViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Set', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IK8SRestoreModifierApireq]
    # Request body for K8s Modifier
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='SetExpanded')]
    [Parameter(ParameterSetName='SetViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Restore Modifier YAML
    ${ModifierYaml},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Set = 'CommvaultPowershell.private\Set-CVK8SRestoreModifier_Set';
            SetExpanded = 'CommvaultPowershell.private\Set-CVK8SRestoreModifier_SetExpanded';
            SetViaIdentity = 'CommvaultPowershell.private\Set-CVK8SRestoreModifier_SetViaIdentity';
            SetViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVK8SRestoreModifier_SetViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to update properties of a Kubernetes application group
.Description
API to update properties of a Kubernetes application group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTENTAPPLICATIONS <IKubernetesContentApplications[]>: List of applications to be added as content
  Guid <String>: GUID value of the Kubernetes Application to be associated as content
  Type <String>: Type of the Kubernetes application
  [Name <String>]: Name of the application

CONTENTLABELSELECTORS <IKubernetesContentSelectors[]>: List of label selectors to be added as content
  SelectorLevel <String>: Selector level of the label selector
  SelectorValue <String>: Value of the label selector in key=value format

FILTERAPPLICATIONS <IKubernetesContentApplications[]>: List of applications to be added as content
  Guid <String>: GUID value of the Kubernetes Application to be associated as content
  Type <String>: Type of the Kubernetes application
  [Name <String>]: Name of the application

FILTERLABELSELECTORS <IKubernetesContentSelectors[]>: List of label selectors to be added as content
  SelectorLevel <String>: Selector level of the label selector
  SelectorValue <String>: Value of the label selector in key=value format

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

TAGS <INameValue[]>: .
  [Name <String>]: 
  [Value <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvkuberneteappgroupop
#>
function Set-CVKuberneteAppGroupOp {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # applicationGroupId is the ID of the Kubernetes application group
    ${ApplicationGroupId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${ActivityControlEnableBackup},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IKubernetesContentApplications[]]
    # List of applications to be added as content
    # To construct, see NOTES section for CONTENTAPPLICATIONS properties and create a hash table.
    ${ContentApplications},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IKubernetesContentSelectors[]]
    # List of label selectors to be added as content
    # To construct, see NOTES section for CONTENTLABELSELECTORS properties and create a hash table.
    ${ContentLabelSelectors},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Specifies whether content has to be overwritten or appended
    ${ContentOverwrite},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IKubernetesContentApplications[]]
    # List of applications to be added as content
    # To construct, see NOTES section for FILTERAPPLICATIONS properties and create a hash table.
    ${FilterApplications},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IKubernetesContentSelectors[]]
    # List of label selectors to be added as content
    # To construct, see NOTES section for FILTERLABELSELECTORS properties and create a hash table.
    ${FilterLabelSelectors},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Specifies whether content has to be overwritten or appended
    ${FilterOverwrite},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Specify whether to skip backup of stateless applications
    ${FilterSkipStatelessApps},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify new name to rename an Application Group
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Define number of parallel data readers
    ${OptionBackupStreams},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Define the backup job start time in epochs
    ${OptionJobStartTime},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Define setting to enable fallback to live volume backup in case of snap failure
    ${OptionOnSnapFailureFallbackToLiveVolume},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Define setting to enable scheduling worker Pods to CV Namespace for CSI-Snapshot enabled backups
    ${OptionScheduleWorkerToConfigNamespace},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.INameValue[]]
    # .
    # To construct, see NOTES section for TAGS properties and create a hash table.
    ${Tags},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${TimezoneId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${TimezoneName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Define limits.cpu to set on the worker Pod
    ${WorkerResourceCpuLimits},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Define requests.cpu to set on the worker Pod
    ${WorkerResourceCpuRequests},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Define limits.memory to set on the worker Pod
    ${WorkerResourceMemoryLimits},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Define requests.memory to set on the worker Pod
    ${WorkerResourceMemoryRequests},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVKuberneteAppGroupOp_UpdateExpanded';
            UpdateViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVKuberneteAppGroupOp_UpdateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to update the properties of a Kubernetes cluster with clusterId
.Description
API to update the properties of a Kubernetes cluster with clusterId
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ACCESSNODES <IIdNameType[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
  [Type <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

TAGS <INameValue[]>: Modify or add tags on the cluster
  [Name <String>]: 
  [Value <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvkuberneteproperty
#>
function Set-CVKuberneteProperty {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # clusterId is the ID of the Kubernetes cluster client
    ${ClusterId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdNameType[]]
    # .
    # To construct, see NOTES section for ACCESSNODES properties and create a hash table.
    ${AccessNodes},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable or disable backup for cluster
    ${ActivityControlEnableBackup},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Enabling backup after a delay.
    # Provide UTC Time in Unix format
    ${ActivityControlEnableBackupAfterADelay},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Enable or disable restore for cluster
    ${ActivityControlEnableRestore},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Enabling restore after a delay.
    # Provide UTC Time in Unix format
    ${ActivityControlEnableRestoreAfterADelay},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # API Server Endpoint of the cluster
    ${ApiServer},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Denote if etcd protection is enabled
    ${EtcdProtectionEnabled},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${EtcdProtectionId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${EtcdProtectionName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${EtcdProtectionPlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${EtcdProtectionPlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify image pull secret to authenticate with the image repository
    ${ImageRegistryPullSecret},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify image registry URL for internal image repository
    ${ImageRegistryUrl},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify wait time for Worker Pod to be deleted
    ${JobStepWaitTimeResourceCleanup},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify wait time for snapshot to be deleted
    ${JobStepWaitTimeSnapshotCleanup},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify wait time for snapshot to be Ready
    ${JobStepWaitTimeSnapshotReady},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Specify wait time for Worker Pod to start
    ${JobStepWaitTimeWorkerPodStartup},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the Kubernetes Cluster
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify the name of the Namespace where Commvault resources will be deployed
    ${OptionConfigNamespace},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RegionId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RegionName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the Service Account to authenticate with the cluster
    ${ServiceAccount},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Secret token to authenticate with the cluster
    ${ServiceToken},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The Service Type of the Kubernetes cluster
    ${ServiceType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.INameValue[]]
    # Modify or add tags on the cluster
    # To construct, see NOTES section for TAGS properties and create a hash table.
    ${Tags},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVKuberneteProperty_UpdateExpanded';
            UpdateViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVKuberneteProperty_UpdateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to assign users specified in device owner mapping as owners of laptops presented in the request body.
.Description
API to assign users specified in device owner mapping as owners of laptops presented in the request body.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IAssignLaptopOwnerMappingReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IAssignLaptopOwnerMappingReq>: Model used for assign laptop owner mapping
  [ApplyAll <Boolean?>]: This indicates if applying assign laptop owners to all device user mappings within a company
  [LaptopOwnerMapping <Int64[]>]: Accepts list of laptop owner mapping ids to be applied
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvlaptopownermappingactionassign
#>
function Set-CVLaptopOwnerMappingActionAssign {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='PutExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.Int64]
    # Id of the company that this operation will be performed for
    ${CompanyId},

    [Parameter(ParameterSetName='Put', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAssignLaptopOwnerMappingReq]
    # Model used for assign laptop owner mapping
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # This indicates if applying assign laptop owners to all device user mappings within a company
    ${ApplyAll},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64[]]
    # Accepts list of laptop owner mapping ids to be applied
    ${LaptopOwnerMapping},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Put = 'CommvaultPowershell.private\Set-CVLaptopOwnerMappingActionAssign_Put';
            PutExpanded = 'CommvaultPowershell.private\Set-CVLaptopOwnerMappingActionAssign_PutExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to update existing laptop owner mapping
.Description
API to update existing laptop owner mapping
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ILaptopOwnerMapping
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ILaptopOwnerMapping>: List of laptop owner info
  [ErrorCode <Int64?>]: 
  [ErrorMessage <String>]: 
  [LaptopOwnerMapping1 <ILaptopOwnerInfo[]>]: 
    Id <Int64>: Unique Id
    [ClientId <Int64?>]: 
    [ClientName <String>]: 
    [CompanyId <Int64?>]: 
    [CompanyName <String>]: 
    [Configured <Boolean?>]: This indicates if the laptop has been installed or not
    [Host <String>]: host name of the laptop
    [LaptopName <String>]: name of the laptop
    [OSType <String>]: OS type of the laptop. Can be LINUX or MAC
    [OwnerEmail <String>]: Email address of the owner
    [OwnerUpn <String>]: UPN of the owner
    [SerialNumber <String>]: This is the serial number

LAPTOPOWNERMAPPING <ILaptopOwnerInfo[]>: .
  Id <Int64>: Unique Id
  [ClientId <Int64?>]: 
  [ClientName <String>]: 
  [CompanyId <Int64?>]: 
  [CompanyName <String>]: 
  [Configured <Boolean?>]: This indicates if the laptop has been installed or not
  [Host <String>]: host name of the laptop
  [LaptopName <String>]: name of the laptop
  [OSType <String>]: OS type of the laptop. Can be LINUX or MAC
  [OwnerEmail <String>]: Email address of the owner
  [OwnerUpn <String>]: UPN of the owner
  [SerialNumber <String>]: This is the serial number
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvlaptopownermapping
#>
function Set-CVLaptopOwnerMapping {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='PutExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Put', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ILaptopOwnerMapping]
    # List of laptop owner info
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${ErrorCode},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ErrorMessage},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ILaptopOwnerInfo[]]
    # .
    # To construct, see NOTES section for LAPTOPOWNERMAPPING properties and create a hash table.
    ${LaptopOwnerMapping},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Put = 'CommvaultPowershell.private\Set-CVLaptopOwnerMapping_Put';
            PutExpanded = 'CommvaultPowershell.private\Set-CVLaptopOwnerMapping_PutExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Refresh a specific node of HyperScale
.Description
Refresh a specific node of HyperScale
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvnode
#>
function Set-CVNode {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Refresh', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Refresh', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of hyperscale storage
    ${HyperScaleStorageId},

    [Parameter(ParameterSetName='Refresh', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of node
    ${NodeId},

    [Parameter(ParameterSetName='RefreshViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Refresh = 'CommvaultPowershell.private\Set-CVNode_Refresh';
            RefreshViaIdentity = 'CommvaultPowershell.private\Set-CVNode_RefreshViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to send request to process plan rules against specific set of entities.
.Description
API to send request to process plan rules against specific set of entities.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IExecutePlanRules
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BACKUPSETS <IIdName[]>: List of backupsets against which plan rules need to be executed and evaluated.
  [Id <Int64?>]: 
  [Name <String>]: 

BODY <IExecutePlanRules>: Message object to hold information of entities against which plan rule need to be analyzed
  [Backupsets <IIdName[]>]: List of backupsets against which plan rules need to be  executed and evaluated.
    [Id <Int64?>]: 
    [Name <String>]: 
  [Clients <IIdName[]>]: List of clients against which plan rules need to be  executed and evaluated.
  [IgnorePreviousPlanAssociation <Boolean?>]: Boolean to indicate if we want to evaluate rule for entities associated to plan. Default is false. Only entities with no plan associated will be evaluated.
  [Instances <IIdName[]>]: List of instances against which plan rules need to be  executed and evaluated.
  [IsPreviewOnly <Boolean?>]: Boolean to indicate if request is to preview list of subclients that will be associated via plan rules
  [Subclients <IIdName[]>]: List of subclients against which plan rules need to be  executed and evaluated.

CLIENTS <IIdName[]>: List of clients against which plan rules need to be executed and evaluated.
  [Id <Int64?>]: 
  [Name <String>]: 

INSTANCES <IIdName[]>: List of instances against which plan rules need to be executed and evaluated.
  [Id <Int64?>]: 
  [Name <String>]: 

SUBCLIENTS <IIdName[]>: List of subclients against which plan rules need to be executed and evaluated.
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvplanruleassociatedentity
#>
function Set-CVPlanRuleAssociatedEntity {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='PutExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Put', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IExecutePlanRules]
    # Message object to hold information of entities against which plan rule need to be analyzed
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # List of backupsets against which plan rules need to be executed and evaluated.
    # To construct, see NOTES section for BACKUPSETS properties and create a hash table.
    ${Backupsets},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # List of clients against which plan rules need to be executed and evaluated.
    # To construct, see NOTES section for CLIENTS properties and create a hash table.
    ${Clients},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean to indicate if we want to evaluate rule for entities associated to plan.
    # Default is false.
    # Only entities with no plan associated will be evaluated.
    ${IgnorePreviousPlanAssociation},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # List of instances against which plan rules need to be executed and evaluated.
    # To construct, see NOTES section for INSTANCES properties and create a hash table.
    ${Instances},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean to indicate if request is to preview list of subclients that will be associated via plan rules
    ${IsPreviewOnly},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # List of subclients against which plan rules need to be executed and evaluated.
    # To construct, see NOTES section for SUBCLIENTS properties and create a hash table.
    ${Subclients},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Put = 'CommvaultPowershell.private\Set-CVPlanRuleAssociatedEntity_Put';
            PutExpanded = 'CommvaultPowershell.private\Set-CVPlanRuleAssociatedEntity_PutExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to associate workloads to selected plan and plan rule
.Description
API to associate workloads to selected plan and plan rule
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IAssociatePlanRuleEntityList
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IAssociatePlanRuleEntityList>: List of entities that are will be associated to provided plan and said rule
  [Entities <IAssociatePlanRuleEntity[]>]: Details of entity that will be associated to plan and rule.
    [PlanId <Int64?>]: 
    [PlanName <String>]: 
    [RuleId <Int64?>]: 
    [RuleName <String>]: 
    [SubclientId <Int64?>]: 
    [SubclientName <String>]: 

ENTITIES <IAssociatePlanRuleEntity[]>: Details of entity that will be associated to plan and rule.
  [PlanId <Int64?>]: 
  [PlanName <String>]: 
  [RuleId <Int64?>]: 
  [RuleName <String>]: 
  [SubclientId <Int64?>]: 
  [SubclientName <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvplanruleentityassociate
#>
function Set-CVPlanRuleEntityAssociate {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='PutExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Put', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAssociatePlanRuleEntityList]
    # List of entities that are will be associated to provided plan and said rule
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IAssociatePlanRuleEntity[]]
    # Details of entity that will be associated to plan and rule.
    # To construct, see NOTES section for ENTITIES properties and create a hash table.
    ${Entities},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Put = 'CommvaultPowershell.private\Set-CVPlanRuleEntityAssociate_Put';
            PutExpanded = 'CommvaultPowershell.private\Set-CVPlanRuleEntityAssociate_PutExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to exclude workloads from plan rule evaluation framework
.Description
API to exclude workloads from plan rule evaluation framework
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IExcludeEntitiesFromPlanRuleEvaluation
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IExcludeEntitiesFromPlanRuleEvaluation>: Entities that need to be excluded from plan rule evaluation
  [Subclients <IIdName[]>]: 
    [Id <Int64?>]: 
    [Name <String>]: 

SUBCLIENTS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvplanruleentityexclude
#>
function Set-CVPlanRuleEntityExclude {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='PutExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Put', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IExcludeEntitiesFromPlanRuleEvaluation]
    # Entities that need to be excluded from plan rule evaluation
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for SUBCLIENTS properties and create a hash table.
    ${Subclients},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Put = 'CommvaultPowershell.private\Set-CVPlanRuleEntityExclude_Put';
            PutExpanded = 'CommvaultPowershell.private\Set-CVPlanRuleEntityExclude_PutExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to include workloads to be applicable for plan rule evaluation.
.Description
API to include workloads to be applicable for plan rule evaluation.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IIncludeEntitiesForPlanRuleEvaluation
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IIncludeEntitiesForPlanRuleEvaluation>: Entities that need to be included for plan rule evaluation
  [Subclients <IIdName[]>]: 
    [Id <Int64?>]: 
    [Name <String>]: 

SUBCLIENTS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvplanruleentityinclude
#>
function Set-CVPlanRuleEntityInclude {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='PutExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Put', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIncludeEntitiesForPlanRuleEvaluation]
    # Entities that need to be included for plan rule evaluation
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for SUBCLIENTS properties and create a hash table.
    ${Subclients},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Put = 'CommvaultPowershell.private\Set-CVPlanRuleEntityInclude_Put';
            PutExpanded = 'CommvaultPowershell.private\Set-CVPlanRuleEntityInclude_PutExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to update rank for multiple rules at a time.
.Description
API to update rank for multiple rules at a time.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

RULES <IPlanEntityRuleRank[]>: Lits of plan entity rule object suggesting their ranks.
  [Rank <Int64?>]: This will suggest rank/priority of the plan rule.
  [RuleId <Int64?>]: 
  [RuleName <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvplanrulerank
#>
function Set-CVPlanRuleRank {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanEntityRuleRank[]]
    # Lits of plan entity rule object suggesting their ranks.
    # To construct, see NOTES section for RULES properties and create a hash table.
    ${Rules},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVPlanRuleRank_UpdateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to set plan rule execution settings
.Description
API to set plan rule execution settings
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IPlanRuleExecutionSettings
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IPlanRuleExecutionSettings>: Message object to hold settings for plan rule execution.
  [EnableAlertNotification <Boolean?>]: Set this to enable/disable notification over email for subclients pending plan associationover 24 hours. By default, notification will be enabled.
  [ExecutionInterval <Int64?>]: Setting to suggest evaluation frequency in case of evaluation mode being Automatic.
  [ExecutionMode <String>]: Plan rule execution mode
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvplanrulesetting
#>
function Set-CVPlanRuleSetting {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='PutExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Put', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanRuleExecutionSettings]
    # Message object to hold settings for plan rule execution.
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Set this to enable/disable notification over email for subclients pending plan associationover 24 hours.
    # By default, notification will be enabled.
    ${EnableAlertNotification},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Setting to suggest evaluation frequency in case of evaluation mode being Automatic.
    ${ExecutionInterval},

    [Parameter(ParameterSetName='PutExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Plan rule execution mode
    ${ExecutionMode},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Put = 'CommvaultPowershell.private\Set-CVPlanRuleSetting_Put';
            PutExpanded = 'CommvaultPowershell.private\Set-CVPlanRuleSetting_PutExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Api to update existing plan rules.
Request body will suggest which rule need to be updated and type of entities(workloads type, server groups, regions and all) that need to be referenced for applying that rule against a workload.
.Description
Api to update existing plan rules.
Request body will suggest which rule need to be updated and type of entities(workloads type, server groups, regions and all) that need to be referenced for applying that rule against a workload.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

REGIONS <IIdNameGuid[]>: This will include list of regions that should be evaluated against workload region for plan association.
  [Guid <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 

SERVERGROUPS <IIdNameGuid[]>: This will include list of Server groups that should be evaluated against workload server group for plan association.
  [Guid <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 

SOLUTIONS <IIdName[]>: This will include list of solutions that should be evaluated against workload for plan association.
  [Id <Int64?>]: 
  [Name <String>]: 

TAGS <IPlanEntityRuleTag[]>: This will include list of tags that should be evaluated against workload for plan association
  [Guid <String>]: GUID for the tag
  [Id <Int64?>]: Id for the tag
  [Name <String>]: Name for the plan rule tag which need to be matched against tag of the workload.
  [Value <String>]: Possible value that need to matched against value of tag associated to workload.

WORKLOADS <IIdName[]>: This will include list of apptypes that should be evaluated against workload apptype for plan association.
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvplanrule
#>
function Set-CVPlanRule {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanGuid},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # [Optional] - This field will suggest rank/priority of rule.
    ${Rank},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdNameGuid[]]
    # This will include list of regions that should be evaluated against workload region for plan association.
    # To construct, see NOTES section for REGIONS properties and create a hash table.
    ${Regions},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RuleGuid},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RuleId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RuleName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdNameGuid[]]
    # This will include list of Server groups that should be evaluated against workload server group for plan association.
    # To construct, see NOTES section for SERVERGROUPS properties and create a hash table.
    ${ServerGroups},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # This will include list of solutions that should be evaluated against workload for plan association.
    # To construct, see NOTES section for SOLUTIONS properties and create a hash table.
    ${Solutions},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanEntityRuleTag[]]
    # This will include list of tags that should be evaluated against workload for plan association
    # To construct, see NOTES section for TAGS properties and create a hash table.
    ${Tags},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # This will include list of apptypes that should be evaluated against workload apptype for plan association.
    # To construct, see NOTES section for WORKLOADS properties and create a hash table.
    ${Workloads},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVPlanRule_UpdateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Updating the entity in the recovery group
.Description
Updating the entity in the recovery group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IRecoveryEntity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IRecoveryEntity>: The payload for the creation of recovery entity
  [BackupSetId <Int64?>]: 
  [BackupSetName <String>]: 
  [BlockSysrepForRecovery <Boolean?>]: 
  [ClientId <Int64?>]: 
  [ClientName <String>]: 
  [ConnectionDetails <IVMConnectionDetails>]: VMConnectionDetails
    [CsCredsCredentialsName <String>]: username to access the network path
    [CsCredsCredentialsPassword <String>]: password to access the network path
    [CsCredsSavedCredentialsId <Int64?>]: 
    [CsCredsSavedCredentialsName <String>]: 
    [DomainCredsCredentialsName <String>]: username to access the network path
    [DomainCredsCredentialsPassword <String>]: password to access the network path
    [DomainCredsSavedCredentialsId <Int64?>]: 
    [DomainCredsSavedCredentialsName <String>]: 
    [GuestCredsCredentialsName <String>]: username to access the network path
    [GuestCredsCredentialsPassword <String>]: password to access the network path
    [GuestCredsSavedCredentialsId <Int64?>]: 
    [GuestCredsSavedCredentialsName <String>]: 
    [TopologyDetailNetworkGateway <IGatewayConnectionInfo[]>]: 
      [Hostname <String>]: Gateway machine hostname
      [Port <Int64?>]: 
    [TopologyDetailServerGroups <IIdName[]>]: 
      [Id <Int64?>]: 
      [Name <String>]: 
    [VMClientName <String>]: VM client name
    [VMHostName <String>]: VM host name
  [EntityId <Int64?>]: 
  [EntityName <String>]: 
  [ExecutionOrderGroup <Int64?>]: Group ID to group similar entities together
  [ExecutionOrderOrder <Int64?>]: Decides the priority of entites within a group
  [ExecutionOrderPriority <Int64?>]: Decides the priority of group execution
  [Id <Int64?>]: Id of the recovery entity
  [InstanceId <Int64?>]: 
  [InstanceName <String>]: 
  [LastRecoveryJobId <Int64?>]: Last recovery job Id of the entity
  [Name <String>]: Name of the recovery entity
  [OSType <String>]: OS types
  [PostRecoveryActions <IDrOperationScript[]>]: 
    [GuestCredentialsCredentialsName <String>]: username to access the network path
    [GuestCredentialsCredentialsPassword <String>]: password to access the network path
    [GuestCredentialsSavedCredentialsId <Int64?>]: 
    [GuestCredentialsSavedCredentialsName <String>]: 
    [Guid <String>]: Unique script identifier string
    [OSType <String>]: OS types
    [Path <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [Reset <Boolean?>]: On set to true, resets the script to empty
    [ScriptCredentialsCredentialsName <String>]: username to access the network path
    [ScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [ScriptCredentialsSavedCredentialsId <Int64?>]: 
    [ScriptCredentialsSavedCredentialsName <String>]: 
    [Type <String>]: The type of path being used for DR operation script
  [PreRecoveryActions <IDrOperationScript[]>]: 
  [RecoveryConfiguration <IRecoveryConfiguration>]: RecoveryConfiguration
    [AzureCreatePublicIP <Boolean?>]: Create a public IP.
    [AzureDeployVMOnlyDuringfailover <Boolean?>]: Select this option to deploy a VM only when a failover operation is requested
    [AzureDestinationVM <String>]: Destination VM
    [AzureDiskType <String>]: Type of the disk
    [AzureOverrideReplicationOptions <IOverrideReplicationOptionsAzure>]: Replication options for Azure
      [AvailabilityZone <String>]: VM availability zone
      [SecurityGroupId <String>]: Security group id
      [SecurityGroupName <String>]: security group name
      [TestFailoverVirtualNetworkDisplayName <String>]: Display Name of network
      [TestFailoverVirtualNetworkId <String>]: Network unique identifier
      [TestFailoverVirtualNetworkName <String>]: Name of the network
      [TestFailoverVirtualNetworkNetworkAddressDetailsNetworkId <String>]: Azure network ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}.
      [TestFailoverVirtualNetworkNetworkAddressDetailsPrivateIPAddress <String>]: Azure private IP address.
      [TestFailoverVirtualNetworkNetworkAddressDetailsPublicIPAddress <String>]: Azure publice IP address.
      [TestFailoverVirtualNetworkNetworkAddressDetailsPublicIPAddressId <String>]: Azure public IP address ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/publicIPAddresses/{Public IP Address Name}.
      [TestFailoverVirtualNetworkNetworkAddressDetailsSubnetId <String>]: Azure subnet ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}/subnets/{Subnet Name}.
      [TestFailoverVirtualNetworkSubnetId <String>]: subnet id of network
      [VirtualNetworkDisplayName <String>]: Display Name of network
      [VirtualNetworkId <String>]: Network unique identifier
      [VirtualNetworkName <String>]: Name of the network
      [VirtualNetworkNetworkAddressDetailsNetworkId <String>]: Azure network ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}.
      [VirtualNetworkNetworkAddressDetailsPrivateIPAddress <String>]: Azure private IP address.
      [VirtualNetworkNetworkAddressDetailsPublicIPAddress <String>]: Azure publice IP address.
      [VirtualNetworkNetworkAddressDetailsPublicIPAddressId <String>]: Azure public IP address ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/publicIPAddresses/{Public IP Address Name}.
      [VirtualNetworkNetworkAddressDetailsSubnetId <String>]: Azure subnet ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}/subnets/{Subnet Name}.
      [VirtualNetworkSubnetId <String>]: subnet id of network
    [AzureRegion <String>]: region of the VM
    [AzureResourceGroup <String>]: Resource group in which the converted virtual machine should be created.
    [AzureRestoreAsManagedVM <Boolean?>]: Restore the VM as a managed disk for the destination VMs.
    [AzureSourceVM <String>]: Source VM
    [AzureSourceVMGuid <String>]: GUID of the source VM
    [AzureStorageAccount <String>]: Azure Standard or Premium general-purpose storage account.
    [AzureTestFailoverVMSize <String>]: Vm size to be used during the test failover operation
    [AzureUnconditionalOverwrite <Boolean?>]: This will replace the instance at the destination if the instance with the same name already exists.
    [AzureVMSize <String>]: VM size
    [CopyPrecedence <Int64?>]: Copy precedence for the copy used for the restore
    [HardwareConfigurationDataDiskConfiguration <IDiskConfiguration[]>]: 
      [DiskSize <Int64?>]: Disk size in bytes
      [DiskType <String>]: Type of disk controller
      [Name <String>]: Name of the disk
      [ProvisioningType <String>]: Disk provisioning type
    [HardwareConfigurationVolumeConfiguration <IVolumeConfiguration[]>]: 
      [Disks <IDiskConfiguration[]>]: 
      [Enabled <Boolean?>]: Determine if volume is enabled or not
      [Name <String>]: Name of the volume
      [TotalSize <Int64?>]: Size for volume in bytes
    [MediaAgentId <Int64?>]: 
    [MediaAgentName <String>]: 
    [SystemDiskConfigurationDiskSize <Int64?>]: Disk size in bytes
    [SystemDiskConfigurationDiskType <String>]: Type of disk controller
    [SystemDiskConfigurationName <String>]: Name of the disk
    [SystemDiskConfigurationProvisioningType <String>]: Disk provisioning type
  [RecoveryFailureReason <String>]: Reason for last recovery job failure
  [RecoveryGroupId <Int64?>]: 
  [RecoveryGroupName <String>]: 
  [RecoveryPoint <Int64?>]: Timestamp for entity restore in case of disaster, default value is 0 as latest recovery point
  [RecoveryPointDetailEntityRecoveryPoint <Int64?>]: Timestamp for entity restore in case of disaster, default value is 0 as latest recovery point
  [RecoveryPointDetailEntityRecoveryPointCategory <String>]: Type of recovery point category that can be selected. Default is Latest
  [RecoveryPointDetailInheritedFrom <String>]: Describes from where the recovery point is inherited from. If not provided, recovery point will be used as if it is set at recovery group level
  [RecoveryStatus <String>]: Status of recovery entity
  [RecoveryStatusNotReadyCategory <String>]: Recovery status not ready category
  [RecoveryStatusNotReadyReason <String>]: Recovery status not ready reason
  [TargetId <Int64?>]: 
  [TargetName <String>]: 
  [VMGroupId <Int64?>]: 
  [VMGroupName <String>]: 
  [ValidationFailureReason <String>]: Reason for last validation failure
  [ValidationStatus <String>]: Validation status of recovery entity
  [VirtualMachineGuid <String>]: 
  [VirtualMachineName <String>]: 
  [Workload <String>]: 

CONNECTIONDETAILS <IVMConnectionDetails>: VMConnectionDetails
  [CsCredsCredentialsName <String>]: username to access the network path
  [CsCredsCredentialsPassword <String>]: password to access the network path
  [CsCredsSavedCredentialsId <Int64?>]: 
  [CsCredsSavedCredentialsName <String>]: 
  [DomainCredsCredentialsName <String>]: username to access the network path
  [DomainCredsCredentialsPassword <String>]: password to access the network path
  [DomainCredsSavedCredentialsId <Int64?>]: 
  [DomainCredsSavedCredentialsName <String>]: 
  [GuestCredsCredentialsName <String>]: username to access the network path
  [GuestCredsCredentialsPassword <String>]: password to access the network path
  [GuestCredsSavedCredentialsId <Int64?>]: 
  [GuestCredsSavedCredentialsName <String>]: 
  [TopologyDetailNetworkGateway <IGatewayConnectionInfo[]>]: 
    [Hostname <String>]: Gateway machine hostname
    [Port <Int64?>]: 
  [TopologyDetailServerGroups <IIdName[]>]: 
    [Id <Int64?>]: 
    [Name <String>]: 
  [VMClientName <String>]: VM client name
  [VMHostName <String>]: VM host name

ENTITIES <IRecoveryEntity[]>: .
  [BackupSetId <Int64?>]: 
  [BackupSetName <String>]: 
  [BlockSysrepForRecovery <Boolean?>]: 
  [ClientId <Int64?>]: 
  [ClientName <String>]: 
  [ConnectionDetails <IVMConnectionDetails>]: VMConnectionDetails
    [CsCredsCredentialsName <String>]: username to access the network path
    [CsCredsCredentialsPassword <String>]: password to access the network path
    [CsCredsSavedCredentialsId <Int64?>]: 
    [CsCredsSavedCredentialsName <String>]: 
    [DomainCredsCredentialsName <String>]: username to access the network path
    [DomainCredsCredentialsPassword <String>]: password to access the network path
    [DomainCredsSavedCredentialsId <Int64?>]: 
    [DomainCredsSavedCredentialsName <String>]: 
    [GuestCredsCredentialsName <String>]: username to access the network path
    [GuestCredsCredentialsPassword <String>]: password to access the network path
    [GuestCredsSavedCredentialsId <Int64?>]: 
    [GuestCredsSavedCredentialsName <String>]: 
    [TopologyDetailNetworkGateway <IGatewayConnectionInfo[]>]: 
      [Hostname <String>]: Gateway machine hostname
      [Port <Int64?>]: 
    [TopologyDetailServerGroups <IIdName[]>]: 
      [Id <Int64?>]: 
      [Name <String>]: 
    [VMClientName <String>]: VM client name
    [VMHostName <String>]: VM host name
  [EntityId <Int64?>]: 
  [EntityName <String>]: 
  [ExecutionOrderGroup <Int64?>]: Group ID to group similar entities together
  [ExecutionOrderOrder <Int64?>]: Decides the priority of entites within a group
  [ExecutionOrderPriority <Int64?>]: Decides the priority of group execution
  [Id <Int64?>]: Id of the recovery entity
  [InstanceId <Int64?>]: 
  [InstanceName <String>]: 
  [LastRecoveryJobId <Int64?>]: Last recovery job Id of the entity
  [Name <String>]: Name of the recovery entity
  [OSType <String>]: OS types
  [PostRecoveryActions <IDrOperationScript[]>]: 
    [GuestCredentialsCredentialsName <String>]: username to access the network path
    [GuestCredentialsCredentialsPassword <String>]: password to access the network path
    [GuestCredentialsSavedCredentialsId <Int64?>]: 
    [GuestCredentialsSavedCredentialsName <String>]: 
    [Guid <String>]: Unique script identifier string
    [OSType <String>]: OS types
    [Path <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
    [Reset <Boolean?>]: On set to true, resets the script to empty
    [ScriptCredentialsCredentialsName <String>]: username to access the network path
    [ScriptCredentialsCredentialsPassword <String>]: password to access the network path
    [ScriptCredentialsSavedCredentialsId <Int64?>]: 
    [ScriptCredentialsSavedCredentialsName <String>]: 
    [Type <String>]: The type of path being used for DR operation script
  [PreRecoveryActions <IDrOperationScript[]>]: 
  [RecoveryConfiguration <IRecoveryConfiguration>]: RecoveryConfiguration
    [AzureCreatePublicIP <Boolean?>]: Create a public IP.
    [AzureDeployVMOnlyDuringfailover <Boolean?>]: Select this option to deploy a VM only when a failover operation is requested
    [AzureDestinationVM <String>]: Destination VM
    [AzureDiskType <String>]: Type of the disk
    [AzureOverrideReplicationOptions <IOverrideReplicationOptionsAzure>]: Replication options for Azure
      [AvailabilityZone <String>]: VM availability zone
      [SecurityGroupId <String>]: Security group id
      [SecurityGroupName <String>]: security group name
      [TestFailoverVirtualNetworkDisplayName <String>]: Display Name of network
      [TestFailoverVirtualNetworkId <String>]: Network unique identifier
      [TestFailoverVirtualNetworkName <String>]: Name of the network
      [TestFailoverVirtualNetworkNetworkAddressDetailsNetworkId <String>]: Azure network ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}.
      [TestFailoverVirtualNetworkNetworkAddressDetailsPrivateIPAddress <String>]: Azure private IP address.
      [TestFailoverVirtualNetworkNetworkAddressDetailsPublicIPAddress <String>]: Azure publice IP address.
      [TestFailoverVirtualNetworkNetworkAddressDetailsPublicIPAddressId <String>]: Azure public IP address ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/publicIPAddresses/{Public IP Address Name}.
      [TestFailoverVirtualNetworkNetworkAddressDetailsSubnetId <String>]: Azure subnet ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}/subnets/{Subnet Name}.
      [TestFailoverVirtualNetworkSubnetId <String>]: subnet id of network
      [VirtualNetworkDisplayName <String>]: Display Name of network
      [VirtualNetworkId <String>]: Network unique identifier
      [VirtualNetworkName <String>]: Name of the network
      [VirtualNetworkNetworkAddressDetailsNetworkId <String>]: Azure network ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}.
      [VirtualNetworkNetworkAddressDetailsPrivateIPAddress <String>]: Azure private IP address.
      [VirtualNetworkNetworkAddressDetailsPublicIPAddress <String>]: Azure publice IP address.
      [VirtualNetworkNetworkAddressDetailsPublicIPAddressId <String>]: Azure public IP address ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/publicIPAddresses/{Public IP Address Name}.
      [VirtualNetworkNetworkAddressDetailsSubnetId <String>]: Azure subnet ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}/subnets/{Subnet Name}.
      [VirtualNetworkSubnetId <String>]: subnet id of network
    [AzureRegion <String>]: region of the VM
    [AzureResourceGroup <String>]: Resource group in which the converted virtual machine should be created.
    [AzureRestoreAsManagedVM <Boolean?>]: Restore the VM as a managed disk for the destination VMs.
    [AzureSourceVM <String>]: Source VM
    [AzureSourceVMGuid <String>]: GUID of the source VM
    [AzureStorageAccount <String>]: Azure Standard or Premium general-purpose storage account.
    [AzureTestFailoverVMSize <String>]: Vm size to be used during the test failover operation
    [AzureUnconditionalOverwrite <Boolean?>]: This will replace the instance at the destination if the instance with the same name already exists.
    [AzureVMSize <String>]: VM size
    [CopyPrecedence <Int64?>]: Copy precedence for the copy used for the restore
    [HardwareConfigurationDataDiskConfiguration <IDiskConfiguration[]>]: 
      [DiskSize <Int64?>]: Disk size in bytes
      [DiskType <String>]: Type of disk controller
      [Name <String>]: Name of the disk
      [ProvisioningType <String>]: Disk provisioning type
    [HardwareConfigurationVolumeConfiguration <IVolumeConfiguration[]>]: 
      [Disks <IDiskConfiguration[]>]: 
      [Enabled <Boolean?>]: Determine if volume is enabled or not
      [Name <String>]: Name of the volume
      [TotalSize <Int64?>]: Size for volume in bytes
    [MediaAgentId <Int64?>]: 
    [MediaAgentName <String>]: 
    [SystemDiskConfigurationDiskSize <Int64?>]: Disk size in bytes
    [SystemDiskConfigurationDiskType <String>]: Type of disk controller
    [SystemDiskConfigurationName <String>]: Name of the disk
    [SystemDiskConfigurationProvisioningType <String>]: Disk provisioning type
  [RecoveryFailureReason <String>]: Reason for last recovery job failure
  [RecoveryGroupId <Int64?>]: 
  [RecoveryGroupName <String>]: 
  [RecoveryPoint <Int64?>]: Timestamp for entity restore in case of disaster, default value is 0 as latest recovery point
  [RecoveryPointDetailEntityRecoveryPoint <Int64?>]: Timestamp for entity restore in case of disaster, default value is 0 as latest recovery point
  [RecoveryPointDetailEntityRecoveryPointCategory <String>]: Type of recovery point category that can be selected. Default is Latest
  [RecoveryPointDetailInheritedFrom <String>]: Describes from where the recovery point is inherited from. If not provided, recovery point will be used as if it is set at recovery group level
  [RecoveryStatus <String>]: Status of recovery entity
  [RecoveryStatusNotReadyCategory <String>]: Recovery status not ready category
  [RecoveryStatusNotReadyReason <String>]: Recovery status not ready reason
  [TargetId <Int64?>]: 
  [TargetName <String>]: 
  [VMGroupId <Int64?>]: 
  [VMGroupName <String>]: 
  [ValidationFailureReason <String>]: Reason for last validation failure
  [ValidationStatus <String>]: Validation status of recovery entity
  [VirtualMachineGuid <String>]: 
  [VirtualMachineName <String>]: 
  [Workload <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

POSTRECOVERYACTIONS <IDrOperationScript[]>: .
  [GuestCredentialsCredentialsName <String>]: username to access the network path
  [GuestCredentialsCredentialsPassword <String>]: password to access the network path
  [GuestCredentialsSavedCredentialsId <Int64?>]: 
  [GuestCredentialsSavedCredentialsName <String>]: 
  [Guid <String>]: Unique script identifier string
  [OSType <String>]: OS types
  [Path <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [Reset <Boolean?>]: On set to true, resets the script to empty
  [ScriptCredentialsCredentialsName <String>]: username to access the network path
  [ScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [ScriptCredentialsSavedCredentialsId <Int64?>]: 
  [ScriptCredentialsSavedCredentialsName <String>]: 
  [Type <String>]: The type of path being used for DR operation script

PRERECOVERYACTIONS <IDrOperationScript[]>: .
  [GuestCredentialsCredentialsName <String>]: username to access the network path
  [GuestCredentialsCredentialsPassword <String>]: password to access the network path
  [GuestCredentialsSavedCredentialsId <Int64?>]: 
  [GuestCredentialsSavedCredentialsName <String>]: 
  [Guid <String>]: Unique script identifier string
  [OSType <String>]: OS types
  [Path <String>]: The path of the script to be executed. Can be local path on VM or UNC path accessible by access node
  [Reset <Boolean?>]: On set to true, resets the script to empty
  [ScriptCredentialsCredentialsName <String>]: username to access the network path
  [ScriptCredentialsCredentialsPassword <String>]: password to access the network path
  [ScriptCredentialsSavedCredentialsId <Int64?>]: 
  [ScriptCredentialsSavedCredentialsName <String>]: 
  [Type <String>]: The type of path being used for DR operation script

RECOVERYCONFIGURATION <IRecoveryConfiguration>: RecoveryConfiguration
  [AzureCreatePublicIP <Boolean?>]: Create a public IP.
  [AzureDeployVMOnlyDuringfailover <Boolean?>]: Select this option to deploy a VM only when a failover operation is requested
  [AzureDestinationVM <String>]: Destination VM
  [AzureDiskType <String>]: Type of the disk
  [AzureOverrideReplicationOptions <IOverrideReplicationOptionsAzure>]: Replication options for Azure
    [AvailabilityZone <String>]: VM availability zone
    [SecurityGroupId <String>]: Security group id
    [SecurityGroupName <String>]: security group name
    [TestFailoverVirtualNetworkDisplayName <String>]: Display Name of network
    [TestFailoverVirtualNetworkId <String>]: Network unique identifier
    [TestFailoverVirtualNetworkName <String>]: Name of the network
    [TestFailoverVirtualNetworkNetworkAddressDetailsNetworkId <String>]: Azure network ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}.
    [TestFailoverVirtualNetworkNetworkAddressDetailsPrivateIPAddress <String>]: Azure private IP address.
    [TestFailoverVirtualNetworkNetworkAddressDetailsPublicIPAddress <String>]: Azure publice IP address.
    [TestFailoverVirtualNetworkNetworkAddressDetailsPublicIPAddressId <String>]: Azure public IP address ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/publicIPAddresses/{Public IP Address Name}.
    [TestFailoverVirtualNetworkNetworkAddressDetailsSubnetId <String>]: Azure subnet ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}/subnets/{Subnet Name}.
    [TestFailoverVirtualNetworkSubnetId <String>]: subnet id of network
    [VirtualNetworkDisplayName <String>]: Display Name of network
    [VirtualNetworkId <String>]: Network unique identifier
    [VirtualNetworkName <String>]: Name of the network
    [VirtualNetworkNetworkAddressDetailsNetworkId <String>]: Azure network ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}.
    [VirtualNetworkNetworkAddressDetailsPrivateIPAddress <String>]: Azure private IP address.
    [VirtualNetworkNetworkAddressDetailsPublicIPAddress <String>]: Azure publice IP address.
    [VirtualNetworkNetworkAddressDetailsPublicIPAddressId <String>]: Azure public IP address ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/publicIPAddresses/{Public IP Address Name}.
    [VirtualNetworkNetworkAddressDetailsSubnetId <String>]: Azure subnet ID. Format: /subscriptions/{Subscription ID}/resourceGroups/{Resource Group Name}/providers/Microsoft.Network/virtualNetworks/{Network Name}/subnets/{Subnet Name}.
    [VirtualNetworkSubnetId <String>]: subnet id of network
  [AzureRegion <String>]: region of the VM
  [AzureResourceGroup <String>]: Resource group in which the converted virtual machine should be created.
  [AzureRestoreAsManagedVM <Boolean?>]: Restore the VM as a managed disk for the destination VMs.
  [AzureSourceVM <String>]: Source VM
  [AzureSourceVMGuid <String>]: GUID of the source VM
  [AzureStorageAccount <String>]: Azure Standard or Premium general-purpose storage account.
  [AzureTestFailoverVMSize <String>]: Vm size to be used during the test failover operation
  [AzureUnconditionalOverwrite <Boolean?>]: This will replace the instance at the destination if the instance with the same name already exists.
  [AzureVMSize <String>]: VM size
  [CopyPrecedence <Int64?>]: Copy precedence for the copy used for the restore
  [HardwareConfigurationDataDiskConfiguration <IDiskConfiguration[]>]: 
    [DiskSize <Int64?>]: Disk size in bytes
    [DiskType <String>]: Type of disk controller
    [Name <String>]: Name of the disk
    [ProvisioningType <String>]: Disk provisioning type
  [HardwareConfigurationVolumeConfiguration <IVolumeConfiguration[]>]: 
    [Disks <IDiskConfiguration[]>]: 
    [Enabled <Boolean?>]: Determine if volume is enabled or not
    [Name <String>]: Name of the volume
    [TotalSize <Int64?>]: Size for volume in bytes
  [MediaAgentId <Int64?>]: 
  [MediaAgentName <String>]: 
  [SystemDiskConfigurationDiskSize <Int64?>]: Disk size in bytes
  [SystemDiskConfigurationDiskType <String>]: Type of disk controller
  [SystemDiskConfigurationName <String>]: Name of the disk
  [SystemDiskConfigurationProvisioningType <String>]: Disk provisioning type
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvrecoveryentity
#>
function Set-CVRecoveryEntity {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Update1', Mandatory)]
    [Parameter(ParameterSetName='UpdateExpanded1', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Recovery entity Id
    ${EntityId},

    [Parameter(ParameterSetName='Update1', Mandatory)]
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateExpanded1', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Recovery group Id
    ${RecoveryGroupId},

    [Parameter(ParameterSetName='UpdateViaIdentity1', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Update1', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='UpdateViaIdentity1', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRecoveryEntity]
    # The payload for the creation of recovery entity
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRecoveryEntity[]]
    # .
    # To construct, see NOTES section for ENTITIES properties and create a hash table.
    ${Entities},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${BackupSetId},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${BackupSetName},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${BlockSysrepForRecovery},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${ClientId},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ClientName},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVMConnectionDetails]
    # VMConnectionDetails
    # To construct, see NOTES section for CONNECTIONDETAILS properties and create a hash table.
    ${ConnectionDetails},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${EntityName},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Group ID to group similar entities together
    ${ExecutionOrderGroup},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Decides the priority of entites within a group
    ${ExecutionOrderOrder},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Decides the priority of group execution
    ${ExecutionOrderPriority},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Id of the recovery entity
    ${Id},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${IdNameId},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${InstanceId},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${InstanceName},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Last recovery job Id of the entity
    ${LastRecoveryJobId},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the recovery entity
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # OS types
    ${OSType},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDrOperationScript[]]
    # .
    # To construct, see NOTES section for POSTRECOVERYACTIONS properties and create a hash table.
    ${PostRecoveryActions},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IDrOperationScript[]]
    # .
    # To construct, see NOTES section for PRERECOVERYACTIONS properties and create a hash table.
    ${PreRecoveryActions},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRecoveryConfiguration]
    # RecoveryConfiguration
    # To construct, see NOTES section for RECOVERYCONFIGURATION properties and create a hash table.
    ${RecoveryConfiguration},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Reason for last recovery job failure
    ${RecoveryFailureReason},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RecoveryGroupId1},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RecoveryGroupName},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Timestamp for entity restore in case of disaster, default value is 0 as latest recovery point
    ${RecoveryPoint},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Timestamp for entity restore in case of disaster, default value is 0 as latest recovery point
    ${RecoveryPointDetailEntityRecoveryPoint},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Type of recovery point category that can be selected.
    # Default is Latest
    ${RecoveryPointDetailEntityRecoveryPointCategory},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Describes from where the recovery point is inherited from.
    # If not provided, recovery point will be used as if it is set at recovery group level
    ${RecoveryPointDetailInheritedFrom},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Status of recovery entity
    ${RecoveryStatus},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Recovery status not ready category
    ${RecoveryStatusNotReadyCategory},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Recovery status not ready reason
    ${RecoveryStatusNotReadyReason},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${TargetId},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${TargetName},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${VMGroupId},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${VMGroupName},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Reason for last validation failure
    ${ValidationFailureReason},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Validation status of recovery entity
    ${ValidationStatus},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${VirtualMachineGuid},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${VirtualMachineName},

    [Parameter(ParameterSetName='UpdateExpanded1')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded1')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Workload},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Update1 = 'CommvaultPowershell.private\Set-CVRecoveryEntity_Update1';
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVRecoveryEntity_UpdateExpanded';
            UpdateExpanded1 = 'CommvaultPowershell.private\Set-CVRecoveryEntity_UpdateExpanded1';
            UpdateViaIdentity1 = 'CommvaultPowershell.private\Set-CVRecoveryEntity_UpdateViaIdentity1';
            UpdateViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVRecoveryEntity_UpdateViaIdentityExpanded';
            UpdateViaIdentityExpanded1 = 'CommvaultPowershell.private\Set-CVRecoveryEntity_UpdateViaIdentityExpanded1';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Api to set region for an entity.
.Description
Api to set region for an entity.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IEntityRegionInfo
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IEntityRegionInfo>: .
  [EntityRegionType <String>]: 
  [RegionId <Int64?>]: 
  [RegionName <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

LOCATIONS <ILocationDetailsWithZone[]>: .
  Country <String>: Name of country for the location
  Latitude <Double>: Latitude for the location
  Longitude <Double>: Longitude for the location
  [City <String>]: Name of city for the location
  [Continent <String>]: Name of continent for the location
  [State <String>]: Name of state for the location
  [ZoneId <Int64?>]: 
  [ZoneName <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvregion
#>
function Set-CVRegion {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Set', Mandatory)]
    [Parameter(ParameterSetName='SetExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Unique id for the entity
    ${EntityId},

    [Parameter(ParameterSetName='Set', Mandatory)]
    [Parameter(ParameterSetName='SetExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # Type of the entity
    ${EntityType},

    [Parameter(ParameterSetName='SetExpanded')]
    [Parameter(ParameterSetName='SetViaIdentityExpanded')]
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${RegionId},

    [Parameter(ParameterSetName='SetViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SetViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Set', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='SetViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IEntityRegionInfo]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='SetExpanded')]
    [Parameter(ParameterSetName='SetViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${EntityRegionType},

    [Parameter(ParameterSetName='SetExpanded')]
    [Parameter(ParameterSetName='SetViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RegionName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ILocationDetailsWithZone[]]
    # .
    # To construct, see NOTES section for LOCATIONS properties and create a hash table.
    ${Locations},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Type of operation to be performed for locations
    ${LocationsOperationType},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # New name for the region
    ${NewName},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Set = 'CommvaultPowershell.private\Set-CVRegion_Set';
            SetExpanded = 'CommvaultPowershell.private\Set-CVRegion_SetExpanded';
            SetViaIdentity = 'CommvaultPowershell.private\Set-CVRegion_SetViaIdentity';
            SetViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVRegion_SetViaIdentityExpanded';
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVRegion_UpdateExpanded';
            UpdateViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVRegion_UpdateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Configure a created request
.Description
Configure a created request
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IRmConfigureRequest
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

APPROVERS <IIdNameDisplayName[]>: List of approvers for the request
  [DisplayName <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 

BODY <IRmConfigureRequest>: RMConfigureRequest
  ProjectIds <Int64[]>: List of project ids
  Reviewers <IIdNameDisplayName[]>: List of reviewers for the request
  [Approvers <IIdNameDisplayName[]>]: List of approvers for the request
    [DisplayName <String>]: 
    [Id <Int64?>]: 
    [Name <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

REVIEWERS <IIdNameDisplayName[]>: List of reviewers for the request
  [DisplayName <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvrequest
#>
function Set-CVRequest {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Configure', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Configure', Mandatory)]
    [Parameter(ParameterSetName='ConfigureExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${RequestId},

    [Parameter(ParameterSetName='ConfigureViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ConfigureViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Configure', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ConfigureViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRmConfigureRequest]
    # RMConfigureRequest
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ConfigureExpanded', Mandatory)]
    [Parameter(ParameterSetName='ConfigureViaIdentityExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64[]]
    # List of project ids
    ${ProjectIds},

    [Parameter(ParameterSetName='ConfigureExpanded', Mandatory)]
    [Parameter(ParameterSetName='ConfigureViaIdentityExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdNameDisplayName[]]
    # List of reviewers for the request
    # To construct, see NOTES section for REVIEWERS properties and create a hash table.
    ${Reviewers},

    [Parameter(ParameterSetName='ConfigureExpanded')]
    [Parameter(ParameterSetName='ConfigureViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdNameDisplayName[]]
    # List of approvers for the request
    # To construct, see NOTES section for APPROVERS properties and create a hash table.
    ${Approvers},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Configure = 'CommvaultPowershell.private\Set-CVRequest_Configure';
            ConfigureExpanded = 'CommvaultPowershell.private\Set-CVRequest_ConfigureExpanded';
            ConfigureViaIdentity = 'CommvaultPowershell.private\Set-CVRequest_ConfigureViaIdentity';
            ConfigureViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVRequest_ConfigureViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Update the bucket clone properties
.Description
Update the bucket clone properties
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvs3bucketcloneexpiry
#>
function Set-CVS3BucketCloneExpiry {
[OutputType([Commvault.Powershell.Models.IGenericResponse])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the cloned bucket
    ${CloneId},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # ID of the bucket
    ${Id},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Bucket clone expiry time in UNIX format
    ${ExpiryTime},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVS3BucketCloneExpiry_UpdateExpanded';
            UpdateViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVS3BucketCloneExpiry_UpdateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Updates details of existing SAML app
.Description
Updates details of existing SAML app
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ASSOCIATIONCOMPANIES <IIdName[]>: Companies associated with SAML
  [Id <Int64?>]: 
  [Name <String>]: 

ASSOCIATIONDOMAINS <IIdName[]>: Domains associated with SAML
  [Id <Int64?>]: 
  [Name <String>]: 

ASSOCIATIONUSERGROUPS <IIdName[]>: user groups associated with SAML
  [Id <Int64?>]: 
  [Name <String>]: 

ATTRIBUTEMAPPINGS <ISamlAttributes[]>: attribute mapping details
  [CustomAttribute <String>]: SAML custom attribute types
  [SamlAttribute <String>]: SAML attribute

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

USERGROUPS <ICompanyWithUserGroupAssocDetails[]>: By default, auto-created users will be associated to the Tenant Users group of the company. Add mapping to override this behaviour for a company.
  [CompanyInfoId <Int64?>]: 
  [CompanyInfoName <String>]: 
  [UserGroupInfoId <Int64?>]: 
  [UserGroupInfoName <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvsamlapp
#>
function Set-CVSamlApp {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # .
    ${Name},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Companies associated with SAML
    # To construct, see NOTES section for ASSOCIATIONCOMPANIES properties and create a hash table.
    ${AssociationCompanies},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # Domains associated with SAML
    # To construct, see NOTES section for ASSOCIATIONDOMAINS properties and create a hash table.
    ${AssociationDomains},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Email suffixes associated with SAML
    ${AssociationEmailSuffixes},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # user groups associated with SAML
    # To construct, see NOTES section for ASSOCIATIONUSERGROUPS properties and create a hash table.
    ${AssociationUserGroups},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISamlAttributes[]]
    # attribute mapping details
    # To construct, see NOTES section for ATTRIBUTEMAPPINGS properties and create a hash table.
    ${AttributeMappings},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # This auto-creates non-existing user if the user detail match with the identity rule.
    ${AutoCreateUser},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # SAML description
    ${Description},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean to indicate whether SAML is enabled.
    ${Enabled},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # IDP certificate public key
    ${IdentityProviderMetaDataCertificateData},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Identity provider entity
    ${IdentityProviderMetaDataEntityId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Identity Provider log-out URL
    ${IdentityProviderMetaDataLogoutUrl},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Identity provider redirect URL
    ${IdentityProviderMetaDataRedirectUrl},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # SAML Protocol version
    ${IdentityProviderMetaDataSamlProtocolVersion},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # IDP's secondary certificate
    ${IdentityProviderMetaDataSecondaryCertificateData},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # nameID in SAML assertion subject is used to perform login.
    ${NameIdAttribute},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # certificate alias name
    ${ServiceProviderMetaDataAliasName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # .
    ${ServiceProviderMetaDataAutoGenerateSpMetaData},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # certificate alias name.
    ${ServiceProviderMetaDataCertificateData},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # jks file contents as byte array
    ${ServiceProviderMetaDataJksFileContents},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # key store password.
    ${ServiceProviderMetaDataJksPrivateKey},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # jks contents key store password.
    ${ServiceProviderMetaDataKeyStorePassword},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # certificate private key password
    ${ServiceProviderMetaDataPrivateKeyPassword},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # web console URL.
    ${ServiceProviderMetaDataServiceProviderEndpoint},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # web console URL list.
    ${ServiceProviderMetaDataSpAliases},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ICompanyWithUserGroupAssocDetails[]]
    # By default, auto-created users will be associated to the Tenant Users group of the company.
    # Add mapping to override this behaviour for a company.
    # To construct, see NOTES section for USERGROUPS properties and create a hash table.
    ${UserGroups},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVSamlApp_UpdateExpanded';
            UpdateViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVSamlApp_UpdateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Used to update server associations for a server group
.Description
Used to update server associations for a server group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

MANUALASSOCIATIONASSOCIATEDSERVERS <IIdName[]>: List of associated servers
  [Id <Int64?>]: 
  [Name <String>]: 

RULERULES <IRuleContent[]>: .
  [Condition <String>]: Operation type for VM rules/filters
  [DisplayName <String>]: The display name of the entity to be added
  [Guid <String>]: GUID of the entity to be added as content
  [Name <String>]: name of the VM to be added as content
  [Type <String>]: 
  [Value <String>]: value for the few type of VM Content like powerstate

SERVERGROUPRULEGROUP <IServerRuleGroup[]>: List of rule groups
  [Match <String>]: 
  [Rules <IServerRule[]>]: List of rules
    [MatchCondition <String>]: 
    [RuleName <String>]: 
    [RuleSecValue <String>]: Secondary value used for BETWEEN and NOT_BETWEEN matchCondition. For ruleName which have enum values (like OS_TYPE), this is used to store displayName.
    [RuleValue <String>]: Primary value for the rule

VIRTUALASSOCIATIONCLIENTASSOCIATION <IClientAssociationServerGroupContent[]>: .
  [AssociatedClientId <Int64?>]: 
  [AssociationRule <IVirtualMachinecontent[]>]: 
    [ExistingCredentialId <Int64?>]: 
    [ExistingCredentialName <String>]: 
    [GuestCredentialAssocId <Int64?>]: Credential association ID given to link entity with credential id.
    [GuestCredentialsPassword <String>]: 
    [GuestCredentialsUserName <String>]: 
    [Guid <String>]: GUID of the VM to be added as content
    [Name <String>]: name of the VM to be added as content
    [Type <String>]: 

VIRTUALASSOCIATIONVIRTUALSERVERS <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvservergroupassociation
#>
function Set-CVServerGroupAssociation {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the serverGroupId whose details have to be fetched
    ${ServerGroupId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Confirm that server group rule impacts server of a specific company smart client group only
    ${AutomaticAssociationConfirmRuleChange},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ClientScopeType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Description},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${EntityInfoId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${EntityInfoName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${Id},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # List of associated servers
    # To construct, see NOTES section for MANUALASSOCIATIONASSOCIATEDSERVERS properties and create a hash table.
    ${ManualAssociationAssociatedservers},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Enum which specifies the whether to match all rules or any of the rules
    ${RuleMatchRule},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRuleContent[]]
    # .
    # To construct, see NOTES section for RULERULES properties and create a hash table.
    ${RuleRules},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ServerGroupName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IServerRuleGroup[]]
    # List of rule groups
    # To construct, see NOTES section for SERVERGROUPRULEGROUP properties and create a hash table.
    ${ServerGroupRuleGroup},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ServerGroupRuleMatch},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${ServerGroupType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IClientAssociationServerGroupContent[]]
    # .
    # To construct, see NOTES section for VIRTUALASSOCIATIONCLIENTASSOCIATION properties and create a hash table.
    ${VirtualAssociationClientAssociation},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${VirtualAssociationVirtualInstance},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for VIRTUALASSOCIATIONVIRTUALSERVERS properties and create a hash table.
    ${VirtualAssociationVirtualServers},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVServerGroupAssociation_UpdateExpanded';
            UpdateViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVServerGroupAssociation_UpdateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to associate specific plan to servergroup
.Description
API to associate specific plan to servergroup
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IIdName
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IIdName>: .
  [Id <Int64?>]: 
  [Name <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvservergroupdcplan
#>
function Set-CVServerGroupDcPlan {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='PutExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Put', Mandatory)]
    [Parameter(ParameterSetName='PutExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${ServerGroupId},

    [Parameter(ParameterSetName='PutViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='PutViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Put', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='PutViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName]
    # .
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PutExpanded')]
    [Parameter(ParameterSetName='PutViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${Id},

    [Parameter(ParameterSetName='PutExpanded')]
    [Parameter(ParameterSetName='PutViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${Name},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Put = 'CommvaultPowershell.private\Set-CVServerGroupDcPlan_Put';
            PutExpanded = 'CommvaultPowershell.private\Set-CVServerGroupDcPlan_PutExpanded';
            PutViaIdentity = 'CommvaultPowershell.private\Set-CVServerGroupDcPlan_PutViaIdentity';
            PutViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVServerGroupDcPlan_PutViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to modify RPO schedules on server plan
.Description
API to modify RPO schedules on server plan
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BACKUPFREQUENCYSCHEDULES <IPlanSchedule[]>: .
  BackupType <String>: Schedule Backup level
  SchedulePatternScheduleFrequencyType <String>: schedule frequency type
  [ForDatabasesOnly <Boolean?>]: Boolean to indicate if schedule is for database agents
  [IsRetentionBasedSyntheticFull <Boolean?>]: Boolean to indicate if synthetic full schedule is based on retention rules
  [PolicyId <Int64?>]: Schedule policy Id to which the schedule belongs
  [ScheduleId <Int64?>]: Id of the schedule if available, required for modifying, deleting schedule
  [ScheduleName <String>]: Name of the schedule, for modify
  [ScheduleOperation <String>]: Operation being performed on schedule
  [ScheduleOptionCommitFrequencyInHours <Int64?>]: Commit frequency in hours for disk cache backups from automatic schedules
  [ScheduleOptionDaysBetweenAutoConvert <Int64?>]: Number of days between auto conversion of backup level applicable for databases on incremental and differential schedules of server plan
  [ScheduleOptionJobRunningTimeInMins <Int64?>]: total job running time in minutes
  [ScheduleOptionLogFilesThreshold <Int64?>]: The min number of archived log files before a backup job should start
  [ScheduleOptionLogsDiskUtilizationPercent <Int64?>]: The min log destination disk threshold percentage
  [ScheduleOptionMinBackupIntervalInMins <Int64?>]: The min number of mins to check for file activity on automatic schedule.
  [ScheduleOptionO365ItemSelectionOption <String>]: item backup option for O365 V2 backup jobs
  [ScheduleOptionUseDiskCacheForLogBackups <Boolean?>]: Used to enable disk caching feature on databases for automatic schedules on server plan
  [SchedulePatternDayOfMonth <Int64?>]: Day on which to run the schedule, applicable for monthly, yearly
  [SchedulePatternDayOfWeek <String>]: 
  [SchedulePatternDaysBetweenSyntheticFulls <Int64?>]: No of days between two synthetic full jobs
  [SchedulePatternEndDate <Int64?>]: Schedule end date in epoch format
  [SchedulePatternExceptions <IScheduleRunException[]>]: Exceptions to when a schedule should not run, either in dates or week of month and days
    [OnDates <Int64[]>]: list of dates in a month. For ex: 1, 20
    [OnDayOfTheWeek <String[]>]: On which days, for ex: MONDAY, FRIDAY
    [OnWeekOfTheMonth <String[]>]: On which week of month, for ex: FIRST, LAST
  [SchedulePatternFrequency <Int64?>]: Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
  [SchedulePatternMaxBackupIntervalInMins <Int64?>]: The number of mins to force a backup on automatic schedule.
  [SchedulePatternMonthOfYear <String>]: 
  [SchedulePatternNoOfTimes <Int64?>]: The number of times you want the schedule to run.
  [SchedulePatternRepeatIntervalInMinutes <Int64?>]: How often in minutes in a day the schedule runs, applicable for daily, weekly, monthly and yearly frequency types.
  [SchedulePatternRepeatUntilTime <Int64?>]: Until what time to repeat the schedule in a day, requires repeatIntervalInMinutes
  [SchedulePatternStartDate <Int64?>]: start date of schedule in epoch format
  [SchedulePatternStartTime <Int64?>]: start time of schedule in seconds
  [SchedulePatternWeekOfMonth <String>]: Specific week of a month
  [SchedulePatternWeeklyDays <String[]>]: Days of the week for weekly frequency
  [TimezoneId <Int64?>]: 
  [TimezoneName <String>]: 
  [VMOperationType <String>]: Type of DR operation (only applicable for Failover groups)

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvserverplanrpo
#>
function Set-CVServerPlanRpo {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the Server Plan
    ${PlanId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Operation type for the list
    ${BackupFrequencyOperationType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IPlanSchedule[]]
    # .
    # To construct, see NOTES section for BACKUPFREQUENCYSCHEDULES properties and create a hash table.
    ${BackupFrequencySchedules},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVServerPlanRpo_UpdateExpanded';
            UpdateViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVServerPlanRpo_UpdateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Upgrade software for client and client group.
.Description
Upgrade software for client and client group.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IUpgradeSoftware
.Outputs
System.Int64
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpgradeSoftware>: Request body for server and server group upgrade software
  [Entities <IIdNameGuidType[]>]: List of all the client and client groups on which UpgradeSoftware should be run
    [Guid <String>]: 
    [Id <Int64?>]: 
    [Name <String>]: 
    [Type <String>]: 
  [InstallOSUpdates <Boolean?>]: Boolean which determines whether to install operating system updates.
  [InstallStorageUpdates <String>]: Enum which specifies the type of storage update
  [NotifyWhenJobCompletes <Boolean?>]: Boolean which determines whether to notify when software is upgraded.
  [RebootIfRequired <Boolean?>]: Boolean which determines whether to reboot if required.
  [RunDbMaintenance <Boolean?>]: Boolean which determines whether or not to run a database maintenance.
  [WaitForDownloadJobToComplete <Boolean?>]: Boolean which determines whether to wait for Download software job to complete before software is upgraded.

ENTITIES <IIdNameGuidType[]>: List of all the client and client groups on which UpgradeSoftware should be run
  [Guid <String>]: 
  [Id <Int64?>]: 
  [Name <String>]: 
  [Type <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvsoftware
#>
function Set-CVSoftware {
[OutputType([System.Int64])]
[CmdletBinding(DefaultParameterSetName='UpgradeExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Upgrade', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpgradeSoftware]
    # Request body for server and server group upgrade software
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='UpgradeExpanded')]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdNameGuidType[]]
    # List of all the client and client groups on which UpgradeSoftware should be run
    # To construct, see NOTES section for ENTITIES properties and create a hash table.
    ${Entities},

    [Parameter(ParameterSetName='UpgradeExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean which determines whether to install operating system updates.
    ${InstallOSUpdates},

    [Parameter(ParameterSetName='UpgradeExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Enum which specifies the type of storage update
    ${InstallStorageUpdates},

    [Parameter(ParameterSetName='UpgradeExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean which determines whether to notify when software is upgraded.
    ${NotifyWhenJobCompletes},

    [Parameter(ParameterSetName='UpgradeExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean which determines whether to reboot if required.
    ${RebootIfRequired},

    [Parameter(ParameterSetName='UpgradeExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean which determines whether or not to run a database maintenance.
    ${RunDbMaintenance},

    [Parameter(ParameterSetName='UpgradeExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean which determines whether to wait for Download software job to complete before software is upgraded.
    ${WaitForDownloadJobToComplete},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Upgrade = 'CommvaultPowershell.private\Set-CVSoftware_Upgrade';
            UpgradeExpanded = 'CommvaultPowershell.private\Set-CVSoftware_UpgradeExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
This endpoint configures a syslog server.
.Description
This endpoint configures a syslog server.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ISyslogConfigure
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISyslogConfigure>: This operation configures a syslog server.
  Hostname <String>: The hostname or the IP address of the syslog server.
  [CertificateAuthorityContent <String>]: Content of the uploaded certificate authority file. It should be base64 encoded. Accepted fileTypes are key,crt,pem.
  [CertificateAuthorityName <String>]: File name of the uploaded certificate authority file
  [Enabled <Boolean?>]: Specifies if the syslog server is enabled or disabled
  [ForwardToSyslogAlerts <Boolean?>]: Forward the system log for alerts to the server.
  [ForwardToSyslogAudit <Boolean?>]: Forward the system log for audit trails to the server.
  [ForwardToSyslogEvents <Boolean?>]: Forward the system log for events to the server.
  [Port <Int64?>]: The port on which the syslog server accepts the logs.
  [SecureMessaging <Boolean?>]: When false UDP port will be used, when true TLS encryption will be used to connect to Syslog Server. To upload Certificate Authority file it should be enabled.
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvsyslogstatus
#>
function Set-CVSyslogStatus {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='ConfigureExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Configure', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISyslogConfigure]
    # This operation configures a syslog server.
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='ConfigureExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The hostname or the IP address of the syslog server.
    ${Hostname},

    [Parameter(ParameterSetName='ConfigureExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Content of the uploaded certificate authority file.
    # It should be base64 encoded.
    # Accepted fileTypes are key,crt,pem.
    ${CertificateAuthorityContent},

    [Parameter(ParameterSetName='ConfigureExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # File name of the uploaded certificate authority file
    ${CertificateAuthorityName},

    [Parameter(ParameterSetName='ConfigureExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Specifies if the syslog server is enabled or disabled
    ${Enabled},

    [Parameter(ParameterSetName='ConfigureExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Forward the system log for alerts to the server.
    ${ForwardToSyslogAlerts},

    [Parameter(ParameterSetName='ConfigureExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Forward the system log for audit trails to the server.
    ${ForwardToSyslogAudit},

    [Parameter(ParameterSetName='ConfigureExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Forward the system log for events to the server.
    ${ForwardToSyslogEvents},

    [Parameter(ParameterSetName='ConfigureExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # The port on which the syslog server accepts the logs.
    ${Port},

    [Parameter(ParameterSetName='ConfigureExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # When false UDP port will be used, when true TLS encryption will be used to connect to Syslog Server.
    # To upload Certificate Authority file it should be enabled.
    ${SecureMessaging},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Configure = 'CommvaultPowershell.private\Set-CVSyslogStatus_Configure';
            ConfigureExpanded = 'CommvaultPowershell.private\Set-CVSyslogStatus_ConfigureExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Modify values for give tagId
.Description
Modify values for give tagId
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.IUpdateTagValueRequest
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IUpdateTagValueRequest>: Request body to update tag values
  [NewValue <String>]: 
  [OldValue <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvvalue
#>
function Set-CVValue {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='PutExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Put', Mandatory)]
    [Parameter(ParameterSetName='PutExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the tag name whose value is requested
    ${TagId},

    [Parameter(ParameterSetName='PutViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='PutViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Put', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='PutViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IUpdateTagValueRequest]
    # Request body to update tag values
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='PutExpanded')]
    [Parameter(ParameterSetName='PutViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${NewValue},

    [Parameter(ParameterSetName='PutExpanded')]
    [Parameter(ParameterSetName='PutViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OldValue},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Put = 'CommvaultPowershell.private\Set-CVValue_Put';
            PutExpanded = 'CommvaultPowershell.private\Set-CVValue_PutExpanded';
            PutViaIdentity = 'CommvaultPowershell.private\Set-CVValue_PutViaIdentity';
            PutViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVValue_PutViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Updates the VM Group
.Description
Updates the VM Group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IGenericRespWithWarning
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ACCESSNODE <IIdName[]>: .
  [Id <Int64?>]: 
  [Name <String>]: 

APPLICATIONVALIDATION <IVMAppValidation>: vmAppValidation
  [BackupDestinationId <Int64?>]: 
  [BackupDestinationName <String>]: 
  [CopyId <Int64?>]: Id of the source copy
  [CopyIsActive <Boolean?>]: Is this an active backup destination?
  [CopyIsSnapCopy <Boolean?>]: Is this a snap copy?
  [CopyName <String>]: Name of the source copy
  [CopyPrecedence <Int64?>]: Order of backup destinaion copy created in storage policy
  [CredentialsName <String>]: username to access the network path
  [CredentialsPassword <String>]: password to access the network path
  [KeepValidatedVMSRunning <Boolean?>]: If true then validated VMs will be available until expiration time set on the recovery target
  [MaximumNoOfThreads <Int64?>]: Number of backup Validation Threads
  [RecoveryTargetId <Int64?>]: 
  [RecoveryTargetName <String>]: 
  [SavedCredentialsId <Int64?>]: 
  [SavedCredentialsName <String>]: 
  [ScheduleDescription <String>]: Description for validation schedule
  [ScheduleId <Int64?>]: 
  [ScheduleIsScheduleEnabled <Boolean?>]: True if application validation schedule is enabled
  [ScheduleTaskId <Int64?>]: Job Id for the application validation task. 0 if schedule is disabled
  [UnixArguments <String>]: Arguments for the script
  [UnixIsDisabled <Boolean?>]: Is the script disabled
  [UnixIsLocal <Boolean?>]: True if the script is local
  [UnixPath <String>]: Path for the validation script
  [UnixUncCredentialsName <String>]: username to access the network path
  [UnixUncCredentialsPassword <String>]: password to access the network path
  [UnixUncSavedCredentialsId <Int64?>]: 
  [UnixUncSavedCredentialsName <String>]: 
  [UseSourceVMEsxToMount <Boolean?>]: Use Source VM ESX To Mount
  [ValidateVMBackups <Boolean?>]: True if VM Backup validation is enabled
  [WindowArguments <String>]: Arguments for the script
  [WindowIsDisabled <Boolean?>]: Is the script disabled
  [WindowIsLocal <Boolean?>]: True if the script is local
  [WindowPath <String>]: Path for the validation script
  [WindowsUncCredentialsName <String>]: username to access the network path
  [WindowsUncCredentialsPassword <String>]: password to access the network path
  [WindowsUncSavedCredentialsId <Int64?>]: 
  [WindowsUncSavedCredentialsName <String>]: 

CONTENTRULEGROUPS <IRuleGroupContent[]>: .
  [MatchRule <String>]: Enum which specifies the whether to match all rules or any of the rules
  [Rules <IRuleContent[]>]: 
    [Condition <String>]: Operation type for VM rules/filters
    [DisplayName <String>]: The display name of the entity to be added
    [Guid <String>]: GUID of the entity to be added as content
    [Name <String>]: name of the VM to be added as content
    [Type <String>]: 
    [Value <String>]: value for the few type of VM Content like powerstate

CONTENTVIRTUALMACHINES <IVirtualMachinecontent[]>: .
  [ExistingCredentialId <Int64?>]: 
  [ExistingCredentialName <String>]: 
  [GuestCredentialAssocId <Int64?>]: Credential association ID given to link entity with credential id.
  [GuestCredentialsPassword <String>]: 
  [GuestCredentialsUserName <String>]: 
  [Guid <String>]: GUID of the VM to be added as content
  [Name <String>]: name of the VM to be added as content
  [Type <String>]: 

DISKFILTERRULES <IVMDiskFilter[]>: .
  [Condition <String>]: Operation type for VM rules/filters
  [FilterType <String>]: 
  [Name <String>]: The string to be filtered
  [Overwrite <Boolean?>]: True if disk filter in vmgroup has to be overwritten, by default it will append the content
  [VMGuid <String>]: VM Guid of the Virtual Machine whose disk has to be filtered . This is optional. if not given, all disks of name and type from all Vms added in content will be filtered
  [VMName <String>]: VM Name of the Virtual Machine whose disk has to be filtered . This is optional. if not given, all disks of name and type from all Vms added in content will be filtered
  [Value <String>]: The value string to be filtered, in case of disk tag , value of tag to be filtered

FILTERRULEGROUPS <IRuleGroupContent[]>: .
  [MatchRule <String>]: Enum which specifies the whether to match all rules or any of the rules
  [Rules <IRuleContent[]>]: 
    [Condition <String>]: Operation type for VM rules/filters
    [DisplayName <String>]: The display name of the entity to be added
    [Guid <String>]: GUID of the entity to be added as content
    [Name <String>]: name of the VM to be added as content
    [Type <String>]: 
    [Value <String>]: value for the few type of VM Content like powerstate

FILTERVIRTUALMACHINES <IVirtualMachinecontent[]>: .
  [ExistingCredentialId <Int64?>]: 
  [ExistingCredentialName <String>]: 
  [GuestCredentialAssocId <Int64?>]: Credential association ID given to link entity with credential id.
  [GuestCredentialsPassword <String>]: 
  [GuestCredentialsUserName <String>]: 
  [Guid <String>]: GUID of the VM to be added as content
  [Name <String>]: name of the VM to be added as content
  [Type <String>]: 

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 

SECURITYASSOCIATIONS <ISecurityAssoc[]>: .
  [ExternalUserGroupId <Int64?>]: User Group Id
  [ExternalUserGroupName <String>]: External Group Name
  [ExternalUserGroupProviderId <Int64?>]: Provider id
  [ExternalUserGroupProviderName <String>]: Provider Name
  [IsCreatorAssociation <Boolean?>]: 
  [PermissionList <IPermissionResp[]>]: 
    [CategoryId <Int64?>]: 
    [CategoryName <String>]: 
    [Exclude <Boolean?>]: Flag to specify if this is included permission or excluded permission.
    [PermissionId <Int64?>]: 
    [PermissionName <String>]: 
    [Type <String>]: Returns the type of association.
  [RoleId <Int64?>]: 
  [RoleName <String>]: 
  [UserGroupId <Int64?>]: 
  [UserGroupName <String>]: 
  [UserId <Int64?>]: 
  [UserName <String>]: 

SETTINGS <IVMGroupSettings>: .
  [AllowEmptySubclient <Boolean?>]: True if empty subclient is allowed
  [AutoDetectVMOwner <Boolean?>]: True if auto detect VM Owner enabled
  [CollectFileDetailsFromSnapshotCopy <Boolean?>]: True if metadata collection is enabled for intellisnap jobs. Only applicable for Indexing v1
  [CollectFileDetailsforGranularRecovery <Boolean?>]: True if metadata collection is enabled. Only applicable for Indexing v1
  [CredentialsName <String>]: username to access the network path
  [CredentialsPassword <String>]: password to access the network path
  [CrossAccountFullCopy <Boolean?>]: True if full copy of amazon snapshot to different amazon account is enabled
  [CrossAccountShareOnly <Boolean?>]: True if replicate and copy or sharing of amazon snapshot to different amazon account in same or different geographic location is enabled
  [CustomSnapshotResourceGroup <String>]: Custom snapshot resource group name for Azure
  [CustomSnapshotTags <IResourceTag[]>]: represents custom tags to be set on snapshots
    [Name <String>]: represents name of the tag
    [Value <String>]: represents value of the tag
  [DatastoreFreespaceCheck <Boolean?>]: True if Datastore Free space check is enabled
  [DatastoreFreespaceRequired <Int64?>]: precentage of datastore free space check value
  [DestinationAccountId <Int64?>]: 
  [DestinationAccountName <String>]: 
  [IsApplicationAware <Boolean?>]: Is the VM App Aware
  [IsVMGroupDiskFiltersIncluded <Boolean?>]: Is VM group disk filters included in VM instance disk filters
  [JobStartTime <Int64?>]: Start Time for the VM Group Job
  [NoOfReaders <Int64?>]: Number of readers for backup
  [RegionalSnapshot <Boolean?>]: True when snapshot storage location is regional
  [SavedCredentialsId <Int64?>]: 
  [SavedCredentialsName <String>]: 
  [TransportMode <String>]: transport mode based on environment. Values are case sensitive
  [UseChangedBlockTrackingOnVM <Boolean?>]: True if Changed Block Tracking is enabled
  [UseVMCheckpointSetting <Boolean?>]: True if use VM CheckPoint setting is enabled
  [VMBackupType <String>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvvmgroup
#>
function Set-CVVMGroup {
[OutputType([Commvault.Powershell.Models.IGenericRespWithWarning], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the VMgroup to update
    ${VMGroupId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IIdName[]]
    # .
    # To construct, see NOTES section for ACCESSNODE properties and create a hash table.
    ${AccessNode},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # true if Backup is enabled
    ${ActivityControlEnableBackup},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # true if Restore is enabled
    ${ActivityControlEnableRestore},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVMAppValidation]
    # vmAppValidation
    # To construct, see NOTES section for APPLICATIONVALIDATION properties and create a hash table.
    ${ApplicationValidation},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # denotes the activity type being considered
    ${BackupActivityControlOptionActivityType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if the activity type is enabled
    ${BackupActivityControlOptionEnableActivityType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if the activity will be enabled after a delay time interval
    ${BackupActivityControlOptionEnableAfterADelay},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # delay time in unix timestamp
    ${BackupActivityControlOptionsDelayTime},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # actual delay time value in string format according to the timezone
    ${BackupActivityControlOptionsDelayTimeValue},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${BackupActivityControlOptionsDelayTimeZoneId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${BackupActivityControlOptionsDelayTimeZoneName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if content in vmgroup has to be overwritten, by default it will append the content
    ${ContentOverwrite},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRuleGroupContent[]]
    # .
    # To construct, see NOTES section for CONTENTRULEGROUPS properties and create a hash table.
    ${ContentRuleGroups},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVirtualMachinecontent[]]
    # .
    # To construct, see NOTES section for CONTENTVIRTUALMACHINES properties and create a hash table.
    ${ContentVirtualMachines},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if content in vmgroup has to be overwritten, by default it will append the content
    ${DiskFilterOverwrite},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVMDiskFilter[]]
    # .
    # To construct, see NOTES section for DISKFILTERRULES properties and create a hash table.
    ${DiskFilterRules},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if file indexing needs to be enabled
    ${EnableFileIndexing},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if content in vmgroup has to be overwritten, by default it will append the content
    ${FilterOverwrite},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IRuleGroupContent[]]
    # .
    # To construct, see NOTES section for FILTERRULEGROUPS properties and create a hash table.
    ${FilterRuleGroups},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVirtualMachinecontent[]]
    # .
    # To construct, see NOTES section for FILTERVIRTUALMACHINES properties and create a hash table.
    ${FilterVirtualMachines},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Meditech Listener IP of FQDN name
    ${MeditechSystemListenerIP},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Meditech Listener Port
    ${MeditechSystemListenerPort},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # MBF timeout (in seconds)
    ${MeditechSystemMbFtimeout},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Meditech system name
    ${MeditechSystemName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # subclient name
    ${NewName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${PlanName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # denotes the activity type being considered
    ${RestoreActivityControlOptionActivityType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if the activity type is enabled
    ${RestoreActivityControlOptionEnableActivityType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if the activity will be enabled after a delay time interval
    ${RestoreActivityControlOptionEnableAfterADelay},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # delay time in unix timestamp
    ${RestoreActivityControlOptionsDelayTime},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # actual delay time value in string format according to the timezone
    ${RestoreActivityControlOptionsDelayTimeValue},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${RestoreActivityControlOptionsDelayTimeZoneId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${RestoreActivityControlOptionsDelayTimeZoneName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ISecurityAssoc[]]
    # .
    # To construct, see NOTES section for SECURITYASSOCIATIONS properties and create a hash table.
    ${SecurityAssociations},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IVMGroupSettings]
    # .
    # To construct, see NOTES section for SETTINGS properties and create a hash table.
    ${Settings},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SnapEngineId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SnapEngineName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${SnapMountProxyId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SnapMountProxyName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${SnapshotManagementBackupCopyInterface},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if hardware snapshot is enabled
    ${SnapshotManagementEnableHardwareSnapshot},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if independent disk option is enabled
    ${SnapshotManagementIsIndependentDisksEnabled},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if raw device maps option is enabled
    ${SnapshotManagementIsRawDeviceMapsEnabled},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of ESX Host
    ${SnapshotManagementSnapMountEsxHost},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # True if separate proxy client is used for snap to tape
    ${SnapshotManagementUseSeparateProxyForSnapToTape},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Virtual machine application user name
    ${SnapshotManagementVMApplicationUserName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${StorageId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${StorageName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # .
    ${TimeZoneId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${TimeZoneName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # username to access the network path
    ${UserAccountName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # password to access the network path
    ${UserAccountPassword},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            UpdateExpanded = 'CommvaultPowershell.private\Set-CVVMGroup_UpdateExpanded';
            UpdateViaIdentityExpanded = 'CommvaultPowershell.private\Set-CVVMGroup_UpdateViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to run backup for an application
.Description
API to run backup for an application
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ICreateTaskRespforBackup
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/start-cvapplicationbackup
#>
function Start-CVApplicationBackup {
[OutputType([Commvault.Powershell.Models.ICreateTaskRespforBackup], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Run', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Run', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.String]
    # GUID of the Application to run backup for
    ${AppGuid},

    [Parameter(ParameterSetName='RunViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Backup level , Default :Incremental
    ${BackupLevel},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Run = 'CommvaultPowershell.private\Start-CVApplicationBackup_Run';
            RunViaIdentity = 'CommvaultPowershell.private\Start-CVApplicationBackup_RunViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to run backup for an application group
.Description
API to run backup for an application group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ICreateTaskRespforBackup
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/start-cvapplicationgroupbackup
#>
function Start-CVApplicationGroupBackup {
[OutputType([Commvault.Powershell.Models.ICreateTaskRespforBackup], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Run', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Run', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # applicationGroupId is the ID of the Kubernetes application group
    ${ApplicationGroupId},

    [Parameter(ParameterSetName='RunViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Commvault.Powershell.Category('Query')]
    [System.String]
    # Backup level , Default :Incremental
    ${BackupLevel},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Run = 'CommvaultPowershell.private\Start-CVApplicationGroupBackup_Run';
            RunViaIdentity = 'CommvaultPowershell.private\Start-CVApplicationGroupBackup_RunViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Run Backup copy job for a backupdestination
.Description
Run Backup copy job for a backupdestination
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Outputs
Commvault.Powershell.Models.ICreateTaskRespforBackup
.Outputs
Commvault.Powershell.Models.IGenericResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/start-cvbackupcopy
#>
function Start-CVBackupCopy {
[OutputType([Commvault.Powershell.Models.ICreateTaskRespforBackup], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='Run', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Run', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${BackupDestionationId},

    [Parameter(ParameterSetName='Run', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # .
    ${PlanId},

    [Parameter(ParameterSetName='RunViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Run = 'CommvaultPowershell.private\Start-CVBackupCopy_Run';
            RunViaIdentity = 'CommvaultPowershell.private\Start-CVBackupCopy_RunViaIdentity';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Run different job operations for a plan backup destination
.Description
Run different job operations for a plan backup destination
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.IJobOperationOnCopyReq
.Outputs
Commvault.Powershell.Models.IGenericResp
.Outputs
Commvault.Powershell.Models.IJobOperationOnCopyResp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IJobOperationOnCopyReq>: JobOperationOnCopyReq
  CommcellId <Int64>: ID for chosen commcell
  CopyId <Int64>: ID for chosen copy
  JobIds <Int64[]>: Comma separated Job IDs to run job operation on
  OpType <String>: 
  StoragePolicyId <Int64>: ID for chosen storage policy
  [LoadArchiverJobs <Boolean?>]: Defines whether archiver jobs need to be computed.
  [LoadDependentJobs <Boolean?>]: Defines whether dependent jobs need to be computed.
  [RetainUntilTime <Int64?>]: Job will be retained till specified time. The time is provided in unix time format.
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/start-cvjoboperationonplanbackupdestination
#>
function Start-CVJobOperationOnPlanBackupDestination {
[OutputType([Commvault.Powershell.Models.IJobOperationOnCopyResp], [Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='RunExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Run', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.IJobOperationOnCopyReq]
    # JobOperationOnCopyReq
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='RunExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # ID for chosen commcell
    ${CommcellId},

    [Parameter(ParameterSetName='RunExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # ID for chosen copy
    ${CopyId},

    [Parameter(ParameterSetName='RunExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64[]]
    # Comma separated Job IDs to run job operation on
    ${JobIds},

    [Parameter(ParameterSetName='RunExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # .
    ${OpType},

    [Parameter(ParameterSetName='RunExpanded', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # ID for chosen storage policy
    ${StoragePolicyId},

    [Parameter(ParameterSetName='RunExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Defines whether archiver jobs need to be computed.
    ${LoadArchiverJobs},

    [Parameter(ParameterSetName='RunExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Defines whether dependent jobs need to be computed.
    ${LoadDependentJobs},

    [Parameter(ParameterSetName='RunExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Job will be retained till specified time.
    # The time is provided in unix time format.
    ${RetainUntilTime},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Run = 'CommvaultPowershell.private\Start-CVJobOperationOnPlanBackupDestination_Run';
            RunExpanded = 'CommvaultPowershell.private\Start-CVJobOperationOnPlanBackupDestination_RunExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Test a Yaml paylod against a restore modfier
.Description
Test a Yaml paylod against a restore modfier
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
Commvault.Powershell.Models.ICommvaultPowerShellIdentity
.Inputs
Commvault.Powershell.Models.ITestK8SModifierReq
.Outputs
Commvault.Powershell.Models.IK8SRestoreModifierApiresp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ITestK8SModifierReq>: Request body for K8s Modifier Test Operation
  [ResourceYaml <String>]: Payload(Yaml) to test against the restore modifiers.
  [RestoreModifierListYaml <String>]: YAML of Restore Modifier(s) to be tested.

INPUTOBJECT <ICommvaultPowerShellIdentity>: Identity Parameter
  [AccessPathId <Int64?>]: Id of the mount path whose access path has to be deleted
  [AgentId <Int64?>]: Id of the agent to be modified
  [AppGuid <String>]: GUID of the Application to get details
  [AppId <Int64?>]: Commvault exchange app id
  [ApplicationGroupId <Int64?>]: applicationGroupId is the ID of the Kubernetes application group
  [ArrayId <Int64?>]: 
  [AssetId <String>]: FQDN of the asset
  [BackupDestinationId <Int64?>]: Id of the backupDestination to be modified
  [BackupDestionationId <Int64?>]: 
  [BackupLocationId <Int64?>]: Id of the backup location whose details have to be fetched
  [BlackoutWindowId <Int64?>]: Id of the Blackout Window whose details have to be fetched
  [BucketId <Int64?>]: Id of Bucket
  [ClientId <Int64?>]: 
  [CloneId <Int64?>]: ID of the cloned bucket
  [CloudStorageId <Int64?>]: Id of cloud Storage
  [ClusterId <Int64?>]: Id of the cluster whose modifier has to be listed.
  [CompanyId <Int64?>]: Id of the Company whose details have to be fetched
  [CopyId <Int64?>]: 
  [CredentialId <String>]: 
  [CredentialName <String>]: 
  [DomainId <Int64?>]: ID of the AD/LDAP domain
  [DrOperation <String>]: Name of DR operation. Case insensitive
  [DriveId <Int64?>]: Id of the Drive of which the drive details has to be displayed
  [EntityId <Int64?>]: Recovery entity Id
  [EntityType <String>]: Type of the entity
  [FailoverGroupId <Int64?>]: Id of the failover group
  [GlobalSearchEntity <String>]: name of global search entity
  [HfsShareId <Int64?>]: Id of the HFS Share to fetch its status
  [HyperScaleStorageId <Int64?>]: Id of hyperscale storage
  [HypervisorId <Int64?>]: Id of the HYpervisor to get
  [Id <Int64?>]: 
  [IndexServerClientId <Int64?>]: Pseudo client id of the index server
  [InstanceId <Int64?>]: Id of the instance to modify
  [InventoryId <Int64?>]: Inventory id
  [JobId <Int64?>]: 
  [KmsId <Int64?>]: Id of Key Management Server
  [LibraryId <Int64?>]: Id of the library to view the data
  [MediaAgentId <Int64?>]: Id of the Media Agent whose details have to be fetched
  [MetadataCacheId <Int64?>]: Id of metadata cache
  [ModifierName <String>]: Name of the modifier to be read.
  [Name <String>]: 
  [NameSpace <String>]: Name of the namespace to browse for content
  [NodeId <Int64?>]: Id of node
  [PairId <Int64?>]: 
  [PlanId <Int64?>]: Id of the object store plan to fetch details
  [RecoveryGroupId <Int64?>]: Recovery group Id
  [RecoveryTargetId <Int64?>]: id of recovery target
  [RegionId <Int64?>]: Region id to be deleted.
  [RegionList <String>]: List of region names/ids to be deleted. If region ids are passed, set isRegionIdList=true
  [ReplicationGroupId <Int64?>]: 
  [RequestId <Int64?>]: Unique identifier for the request
  [RoleId <Int64?>]: Role Id
  [RpsId <String>]: 
  [RuleId <Int64?>]: Id of the rule to update in Plan
  [ScheduleId <Int64?>]: ID of the DR operation schedule
  [SchedulePolicyId <Int64?>]: 
  [ServerGroupId <Int64?>]: Id of the serverGroupId whose details have to be fetched
  [ServerId <Int64?>]: Id of the server to modify
  [StoragePoolId <Int64?>]: Id of the storage pool whose associated copies have to be fetched
  [SubclientId <Int64?>]: Id of the subclient to modify
  [TagId <Int64?>]: Id of the tag to delete
  [TagValue <String>]: tag value to delete
  [TopologyId <String>]: 
  [UserGroupId <Int64?>]: Id of the user-group whose details have to be fetched
  [UserId <Int64?>]: Id of the User whose details have to be fetched
  [VMGroupId <Int64?>]: Id of the VMgroup to update
  [VMGuid <String>]: 
  [VMUuid <String>]: The vmUUID can be obtained from GET /virtualMachines UUID property
  [VendorId <Int64?>]: 
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/test-cvk8smodifierrestore
#>
function Test-CVK8SModifierRestore {
[OutputType([Commvault.Powershell.Models.IK8SRestoreModifierApiresp])]
[CmdletBinding(DefaultParameterSetName='TestExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Test', Mandatory)]
    [Parameter(ParameterSetName='TestExpanded', Mandatory)]
    [Commvault.Powershell.Category('Path')]
    [System.Int64]
    # Id of the cluster whose modifier needs to be tested
    ${ClusterId},

    [Parameter(ParameterSetName='TestViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='TestViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Path')]
    [Commvault.Powershell.Models.ICommvaultPowerShellIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Test', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='TestViaIdentity', Mandatory, ValueFromPipeline)]
    [Commvault.Powershell.Category('Body')]
    [Commvault.Powershell.Models.ITestK8SModifierReq]
    # Request body for K8s Modifier Test Operation
    # To construct, see NOTES section for BODY properties and create a hash table.
    ${Body},

    [Parameter(ParameterSetName='TestExpanded')]
    [Parameter(ParameterSetName='TestViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Payload(Yaml) to test against the restore modifiers.
    ${ResourceYaml},

    [Parameter(ParameterSetName='TestExpanded')]
    [Parameter(ParameterSetName='TestViaIdentityExpanded')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # YAML of Restore Modifier(s) to be tested.
    ${RestoreModifierListYaml},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Test = 'CommvaultPowershell.private\Test-CVK8SModifierRestore_Test';
            TestExpanded = 'CommvaultPowershell.private\Test-CVK8SModifierRestore_TestExpanded';
            TestViaIdentity = 'CommvaultPowershell.private\Test-CVK8SModifierRestore_TestViaIdentity';
            TestViaIdentityExpanded = 'CommvaultPowershell.private\Test-CVK8SModifierRestore_TestViaIdentityExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Add/Edit/Delete global execptions
.Description
Add/Edit/Delete global execptions
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
Commvault.Powershell.Models.IGenericResp
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/update-cvglobalexception
#>
function Update-CVGlobalException {
[OutputType([Commvault.Powershell.Models.IGenericResp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Array of exceptions which will be operated upon based on the operation type
    ${UnixGlobalExceptionExceptions},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The operations on global exceptions provided would be executed based on the operation type provided
    ${UnixGlobalExceptionOperationType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean value which updates the property useGlobalExceptionsOnAllSubclients
    ${UseGlobalExceptionsOnAllSubclients},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String[]]
    # Array of exceptions which will be operated upon based on the operation type
    ${WindowGlobalExceptionExceptions},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The operations on global exceptions provided would be executed based on the operation type provided
    ${WindowGlobalExceptionOperationType},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [Commvault.Powershell.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            UpdateExpanded = 'CommvaultPowershell.private\Update-CVGlobalException_UpdateExpanded';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to add/create an blackout window rule.
.Description
Method to add/create an blackout window rule.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/add-cvblackoutwindow
#>
function Add-CVBlackoutWindow {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Position=0, Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Piped-in Properties set.
    ${Properties},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Add-CVBlackoutWindow';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to add an entity to a schedule policy
.Description
Method to add an entity to a schedule policy
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://documentation.commvault.com/11.24/essential/48824_rest_api_post_schedule_policy_add_entity.html
#>
function Add-CVEntitytoSchedulePolicy {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='Default', PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Alias('RequestBody')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.PSObject]
    ${Body},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    ${Force},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    ${taskObject},

    [Parameter(ParameterSetName='ById', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Schedule policy ID
    ${taskId}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Default = 'CommvaultPowershell.custom\Add-CVEntitytoSchedulePolicy';
            ByObject = 'CommvaultPowershell.custom\Add-CVEntitytoSchedulePolicy';
            ById = 'CommvaultPowershell.custom\Add-CVEntitytoSchedulePolicy';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to add virtual server subclient content.
.Description
Method to add virtual server subclient content.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/add-cvvirtualmachine
#>
function Add-CVVirtualMachine {
[Alias('Add-CVVM')]
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Name of the Entity to be added.
    # Multiple entities can be added using a comma separated list.
    # Virtual machine Name, datastore name etc.
    ${Entity},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # ClientName of the client in which subclient resides.
    ${ClientName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # SubclientName to which content should be added.
    # If this parameter not passed, assumes default subclient.
    ${SubclientName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [CVVSAContentEntityType]
    # EntityType can be VMName (default), Host or Cluster etc.
    ${EntityType},

    [Parameter(DontShow)]
    [Commvault.Powershell.Category('Body')]
    [CVVSAContentOperationType]
    ${OperationType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Piped ClientObject of the client in which subclient resides.
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Add-CVVirtualMachine';
            ByObject = 'CommvaultPowershell.custom\Add-CVVirtualMachine';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to perform a virtual machine group content preview with option to create clients from result set.
.Description
Method to perform a virtual machine group content preview with option to create clients from result set.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/add-cvvirtualmachinegroupcontent
#>
function Add-CVVirtualMachineGroupContent {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByObject', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Virtual machine group for content preview.
    # Can be piped or passed as a parameter.
    ${SubclientObject},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [CVVMGroupContentEntityType]
    # Virtual server EntityType including: Host, Datastore, VMName, VMNamePattern, GuestOS, GuestDNSHostname, PoweredState, Notes, TemplateState, Tag, and TagCategory.
    ${EntityType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [CVVSAPowerState]
    # Paired with EntityType PoweredState: On, Off, Other.
    ${PoweredState},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Boolean]
    # Paired with EntityType TemplateState: $True or $False.
    ${TemplateState},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [CVMatchingPattern]
    # Matching pattern to be used for search on DisplayName can be: Contains, Equals, StartsWith, or EndsWith.
    ${MatchingPattern},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Search Term.
    ${DisplayName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # This is the VM GUID
    ${VMName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to create clients for discovered virtual machines.
    # 
    # Recommend running first without this switch to preview discovery results.
    ${CreateClientsForDiscoveredVms},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByObject = 'CommvaultPowershell.custom\Add-CVVirtualMachineGroupContent';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create backup task for specific or default subclient of client file system.
.Description
Create backup task for specific or default subclient of client file system.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/backup-cvclientfilesystem
#>
function Backup-CVClientFileSystem {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Create a file system backup task for client specified by Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Create a file system backup task for subclient specified by SubclientName.
    ${SubclientName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Create a file system backup task for subclient specified by SubclientId.
    ${SubclientId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [CVBackupType]
    # The BackupType: full, incremental (default), differential, synthFull.
    ${BackupType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ById', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Create a file system backup task for client specified by Id.
    ${Id},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Create a file system backup task for client specified by piped ClientObject.
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Backup-CVClientFileSystem';
            ById = 'CommvaultPowershell.custom\Backup-CVClientFileSystem';
            ByObject = 'CommvaultPowershell.custom\Backup-CVClientFileSystem';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Initiates the CommServe disaster recovery (DR) backup.
.Description
Initiates the CommServe disaster recovery (DR) backup.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/backup-cvdisasterrecovery
#>
function Backup-CVDisasterRecovery {
[Alias('Start-CVDRBackup')]
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Backup-CVDisasterRecovery';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to submit backup job for specific SQL database.
.Description
Method to submit backup job for specific SQL database.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/backup-cvsqldatabase
#>
function Backup-CVSQLDatabase {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify the database by Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [CVSQLBackupType]
    # The BackupType: full, incremental (default), differential.
    ${BackupType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ById', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify the database by Id.
    ${Id},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Specify the database by piped DatabaseObject.
    ${DatabaseObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Backup-CVSQLDatabase';
            ById = 'CommvaultPowershell.custom\Backup-CVSQLDatabase';
            ByObject = 'CommvaultPowershell.custom\Backup-CVSQLDatabase';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to submit backup job for SQL instance.
.Description
Method to submit backup job for SQL instance.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/backup-cvsqlinstance
#>
function Backup-CVSQLInstance {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The SQL instance Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [CVSQLBackupType]
    # The BackupType: full, incremental (default), differential.
    ${BackupType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # The SQL InstanceObject.
    ${InstanceObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Backup-CVSQLInstance';
            ByObject = 'CommvaultPowershell.custom\Backup-CVSQLInstance';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to submit backup job for specific SQL subclient.
.Description
Method to submit backup job for specific SQL subclient.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/backup-cvsqlsubclient
#>
function Backup-CVSQLSubclient {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The subclient Name.
    ${Name},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The ClientName hosting the SQL instance.
    ${ClientName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [CVSQLBackupType]
    # The BackupType: full, incremental (default), differential.
    ${BackupType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # The SQL SubclientObject.
    ${SubclientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Backup-CVSQLSubclient';
            ByObject = 'CommvaultPowershell.custom\Backup-CVSQLSubclient';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create backup task for specific subclient.
.Description
Create backup task for specific subclient.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.String
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/backup-cvsubclient
#>
function Backup-CVSubclient {
[Alias('Protect-CVSubclient')]
[OutputType([System.String])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Create backup task for subclient identified by Name.
    ${Name},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Parameter(ParameterSetName='ById', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Provide ClientName for subclient lookup.
    ${ClientName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [CVBackupType]
    # The BackupType: full, incremental (default), differential, synthFull.
    ${BackupType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ById', Mandatory)]
    [Alias('SubclientId')]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Create backup task for subclient identified by Id.
    ${Id},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Create backup task for subclient identified by SubclientObject.
    ${SubclientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Backup-CVSubclient';
            ById = 'CommvaultPowershell.custom\Backup-CVSubclient';
            ByObject = 'CommvaultPowershell.custom\Backup-CVSubclient';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to initiate backup of specified virtual machine.
.Description
Method to initiate backup of specified virtual machine.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/backup-cvvirtualmachine
#>
function Backup-CVVirtualMachine {
[Alias('Backup-CVVM')]
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Virtual machine Name.
    ${Name},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Virtual machine associated ClientName.
    ${ClientName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [CVBackupType]
    # Backup Type for the backup of Virtual Machine , default is INCREMENTAL .
    # Supported values are FULL, INCREMENTAL, DIFFERENTIAL, SYNTHETIC_FULL
    ${BackupType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Use this switch to filter legacy, unprotected virtual machines when specifed by Name.
    ${Protected},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ById', Mandatory)]
    [Alias('VMName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Virtual machine Id: this is the virtual machine GUID.
    ${Id},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Virtual machine associated client specified by piped ClientObject.
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Backup-CVVirtualMachine';
            ById = 'CommvaultPowershell.custom\Backup-CVVirtualMachine';
            ByObject = 'CommvaultPowershell.custom\Backup-CVVirtualMachine';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to disable 'ignore CommCell higher-level blackout window rules' by entity.
.Description
Method to disable 'ignore CommCell higher-level blackout window rules' by entity.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Int32
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvblackoutwindowignorehigherlevelrules
#>
function Disable-CVBlackoutWindowIgnoreHigherLevelRules {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify entity by ClientId.
    ${ClientId},

    [Parameter(Position=1, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify entity by AppTypeId.
    ${AppTypeId},

    [Parameter(Position=2, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify entity by InstanceId.
    ${InstanceId},

    [Parameter(Position=3, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify entity by BackupsetId.
    ${BackupsetId},

    [Parameter(Position=4, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify entity by SubclientId.
    ${SubclientId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Disable-CVBlackoutWindowIgnoreHigherLevelRules';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to disable a schedule policy on the CommServe.
.Description
Method to disable a schedule policy on the CommServe.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/disable-cvschedulepolicy
#>
function Disable-CVSchedulePolicy {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByPolicyName', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ByPolicyName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify the schedule policy to be disabled by Name.
    ${Name},

    [Parameter(ParameterSetName='ByPolicyId', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify the schedule policy to be disabled by Id (taskId).
    ${Id},

    [Parameter(ParameterSetName='ByPolicyObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Specify the schedule policy to be disabled by piping the PolicyObject.
    ${PolicyObject},

    [Parameter(ParameterSetName='BySubclient', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify the ClientName associated with SubclientName.
    ${ClientName},

    [Parameter(ParameterSetName='BySubclient', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify the SubclientName.
    ${SubclientName}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByPolicyName = 'CommvaultPowershell.custom\Disable-CVSchedulePolicy';
            ByPolicyId = 'CommvaultPowershell.custom\Disable-CVSchedulePolicy';
            ByPolicyObject = 'CommvaultPowershell.custom\Disable-CVSchedulePolicy';
            BySubclient = 'CommvaultPowershell.custom\Disable-CVSchedulePolicy';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to initiate dismount of live mounted virtual machine.
.Description
Method to initiate dismount of live mounted virtual machine.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/dismount-cvvirtualmachine
#>
function Dismount-CVVirtualMachine {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ById', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ById', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify Id representing live mounted virtual machine GUID.
    ${Id},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Specify ActiveMountObject containing live mounted virtual machine GUID.
    ${ActiveMountObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ById = 'CommvaultPowershell.custom\Dismount-CVVirtualMachine';
            ByObject = 'CommvaultPowershell.custom\Dismount-CVVirtualMachine';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to enable 'ignore CommCell higher-level blackout window rules' by entity.
.Description
Method to enable 'ignore CommCell higher-level blackout window rules' by entity.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Int32
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvblackoutwindowignorehigherlevelrules
#>
function Enable-CVBlackoutWindowIgnoreHigherLevelRules {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify entity by ClientId.
    ${ClientId},

    [Parameter(Position=1, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify entity by AppTypeId.
    ${AppTypeId},

    [Parameter(Position=2, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify entity by InstanceId.
    ${InstanceId},

    [Parameter(Position=3, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify entity by BackupsetId.
    ${BackupsetId},

    [Parameter(Position=4, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify entity by SubclientId.
    ${SubclientId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Enable-CVBlackoutWindowIgnoreHigherLevelRules';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to enable a schedule policy on the CommServe.
.Description
Method to enable a schedule policy on the CommServe.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/enable-cvschedulepolicy
#>
function Enable-CVSchedulePolicy {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByPolicyName', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ByPolicyName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify the schedule policy to be enabled by Name.
    ${Name},

    [Parameter(ParameterSetName='ByPolicyId', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify the schedule policy to be enabled by Id (taskId).
    ${Id},

    [Parameter(ParameterSetName='ByPolicyObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Specify the schedule policy to be enabled by piping the PolicyObject.
    ${PolicyObject},

    [Parameter(ParameterSetName='BySubclient', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify the ClientName associated with SubclientName.
    ${ClientName},

    [Parameter(ParameterSetName='BySubclient', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify the SubclientName.
    ${SubclientName}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByPolicyName = 'CommvaultPowershell.custom\Enable-CVSchedulePolicy';
            ByPolicyId = 'CommvaultPowershell.custom\Enable-CVSchedulePolicy';
            ByPolicyObject = 'CommvaultPowershell.custom\Enable-CVSchedulePolicy';
            BySubclient = 'CommvaultPowershell.custom\Enable-CVSchedulePolicy';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to submit restore-to-disk SQL database export job.
.Description
Method to submit restore-to-disk SQL database export job.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.String
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/export-cvsqldatabasertd
#>
function Export-CVSQLDatabaseRTD {
[OutputType([System.String])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Export the SQL database files to DestClientName.
    ${DestClientName},

    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Export the SQL database files to DestDiskPath.
    ${DestDiskPath},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify the database files to be exported by database Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Export the SQL database files for a given JobId.
    ${JobId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to control OverwriteExisting of the database files.
    ${OverwriteExisting},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Specify the database files to be exported by piping DatabaseObject.
    ${DatabaseObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Export-CVSQLDatabaseRTD';
            ByObject = 'CommvaultPowershell.custom\Export-CVSQLDatabaseRTD';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve the list of alerts from the CommServe.
.Description
Method to retrieve the list of alerts from the CommServe.
This method is implemented with Powershell paging support.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvalert
#>
function Get-CVAlert {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param()

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Get-CVAlert';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve client groups from the CommServe.
.Description
Method to retrieve client groups or a single specified group from the CommServe.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvclientgroup
#>
function Get-CVClientGroup {
[Alias('Get-CVClientGroupProps')]
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='Default', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Get detail properties for each client group.
    ${AllProperties},

    [Parameter(ParameterSetName='ByName')]
    [Alias('ClientGroupName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get a client group by Name.
    ${Name}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Default = 'CommvaultPowershell.custom\Get-CVClientGroup';
            ByName = 'CommvaultPowershell.custom\Get-CVClientGroup';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of the credential whose credential name is provided
.Description
Get details of the credential whose credential name is provided
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvcredentialdetail
#>
function Get-CVCredentialDetail {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get Credential Details by Name.
    ${Name}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Get-CVCredentialDetail';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve the available disk space of the library.
.Description
Method to retrieve the available disk space of the library.
Requires either the LibraryName or an associated MediaAgentName.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Inputs
System.String
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvdiskspace
#>
function Get-CVDiskSpace {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByLibraryName', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ByLibraryName', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Retrieve available disk space details for the library specified by LibraryName.
    ${LibraryName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Filter output for a specific MountPath.
    ${MountPath},

    [Parameter(ParameterSetName='ByMediaAgentName', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Alias('MAName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Retrieve available disk space details for libraries associated with MediaAgentName.
    ${MediaAgentName},

    [Parameter(ParameterSetName='ByLibraryObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    ${LibraryObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByLibraryName = 'CommvaultPowershell.custom\Get-CVDiskSpace';
            ByMediaAgentName = 'CommvaultPowershell.custom\Get-CVDiskSpace';
            ByLibraryObject = 'CommvaultPowershell.custom\Get-CVDiskSpace';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve the Id for a given Entity from the CommServe.
.Description
Method to retrieve the Id for a given Entity from the CommServe.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.String
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvid
.Link
All Agent Names: https://documentation.commvault.com/commvault/v11/article?p=45467.htm#o99081
#>
function Get-CVId {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get Client Id for ClientName.
    ${ClientName},

    [Parameter(Position=1, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get Application Id for AgentName.
    # Example 'File System', 'Active Directory Agent'
    ${AgentName},

    [Parameter(Position=2, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get BackupSet Id for BackupSetName.
    ${BackupSetName},

    [Parameter(Position=3, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get Instance Id for InstanceName.
    ${InstanceName},

    [Parameter(Position=4, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get Subclient Id for SubclientName.
    ${SubclientName}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Get-CVId';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve storage resource library instances from the CommServe.
.Description
Method to retrieve storage resource library instances from the CommServe.
Output can be filtered by both library Name and associated MediaAgentName.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.String
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvlibrary
#>
function Get-CVLibrary {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='Default', PositionalBinding=$false)]
param(
    [Parameter(ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Alias('LibraryName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Filter library instances to be output by Name.
    ${Name},

    [Parameter(ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Alias('MAName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Filter library instances to be output by associated MediaAgentName.
    ${MediaAgentName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Output library instances with full detail.
    ${AllProperties}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Default = 'CommvaultPowershell.custom\Get-CVLibrary';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of a replication group based on replicationGroupId
.Description
Get details of a replication group based on replicationGroupId
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvreplicationgroupdetail
#>
function Get-CVReplicationGroupDetail {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=2, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # ID of the replicationGroup
    ${ReplicationGroupId},

    [Parameter(Position=0)]
    [Commvault.Powershell.Category('Body')]
    [System.Boolean]
    # Set to true if you want to see override replication options for a periodic replication group
    ${OverrideReplicationOptions},

    [Parameter(Position=1)]
    [Commvault.Powershell.Category('Body')]
    [System.Boolean]
    # Set to true if want to show replication options for a continuous replication group
    ${viewReplicationOptions}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Get-CVReplicationGroupDetail';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis

.Description

.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Collections.Hashtable
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvrestheader
#>
function Get-CVRESTHeader {
[OutputType([System.Collections.Hashtable])]
[CmdletBinding(DefaultParameterSetName='Default', PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Collections.Hashtable]
    ${SessionObject},

    [Parameter(ParameterSetName='ByPagingInfo')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    ${PagingInfo},

    [Parameter(ParameterSetName='ByLimit')]
    [Commvault.Powershell.Category('Body')]
    [System.UInt64]
    ${Limit},

    [Parameter(ParameterSetName='ByLimit')]
    [Commvault.Powershell.Category('Body')]
    [System.UInt64]
    ${Offset}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Default = 'CommvaultPowershell.custom\Get-CVRESTHeader';
            ByPagingInfo = 'CommvaultPowershell.custom\Get-CVRESTHeader';
            ByLimit = 'CommvaultPowershell.custom\Get-CVRESTHeader';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve schedule policies from the CommServe.
.Description
Method to retrieve schedule policies from the CommServe.
Output can be filtered by client/subclient or by policy name or id.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvschedulepolicy
#>
function Get-CVSchedulePolicy {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='Default', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [CVSchedulePolicyType]
    # Filter by ScheduleType: All (default), DataProtection, AuxiliaryCopy, BackupCopy, OfflineContentIndexing, DDBVerification, ContentIndexing, or Workflow.
    ${ScheduleType},

    [Parameter(ParameterSetName='BySubclient', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Filter output by ClientName associated with SubclientName.
    ${ClientName},

    [Parameter(ParameterSetName='BySubclient', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Filter output by SubclientName.
    ${SubclientName},

    [Parameter(ParameterSetName='ByName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Filter output by policy Name.
    ${Name},

    [Parameter(ParameterSetName='ById')]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Filter output by policy Id.
    ${Id}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Default = 'CommvaultPowershell.custom\Get-CVSchedulePolicy';
            BySubclient = 'CommvaultPowershell.custom\Get-CVSchedulePolicy';
            ByName = 'CommvaultPowershell.custom\Get-CVSchedulePolicy';
            ById = 'CommvaultPowershell.custom\Get-CVSchedulePolicy';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis

.Description

.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Collections.Hashtable
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsessiondetail
#>
function Get-CVSessionDetail {
[Alias('Get-CVSessionDetails')]
[OutputType([System.Collections.Hashtable])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    ${MethodName}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Get-CVSessionDetail';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Gets SLA report for specific client or entire CommCell.
.Description
Gets SLA report for specific client or entire CommCell.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvslareport
#>
function Get-CVSLAReport {
[Alias('Get-CVSLA')]
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='Default', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # EmailAddr for notification purpose.
    ${EmailAddr},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Client = 1 (default), Agent = 2.
    ${Type},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Any = 0 (default), Protected = 1, Failed = 2, NoJobFound = 3, NoSchedule = 4.
    ${Category},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Any = 0 (default), Protected = 1, Unprotected = 2, Excluded = 3.
    ${Status},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Use this switch for extended detail.
    ${AllProperties},

    [Parameter(ParameterSetName='ByName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Filter SLA report by ClientName.
    ${ClientName},

    [Parameter(ParameterSetName='ById')]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Filter SLA report by ClientId.
    ${ClientId},

    [Parameter(ParameterSetName='ByObject', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Filter SLA report by piped ClientObject.
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Default = 'CommvaultPowershell.custom\Get-CVSLAReport';
            ByName = 'CommvaultPowershell.custom\Get-CVSLAReport';
            ById = 'CommvaultPowershell.custom\Get-CVSLAReport';
            ByObject = 'CommvaultPowershell.custom\Get-CVSLAReport';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve protected SQL client details.
.Description
Method to retrieve protected SQL client details.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsqlclientdetail
#>
function Get-CVSQLClientDetail {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get detail properties for SQL client by Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Filter output by SQL InstanceName.
    ${InstanceName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Filter output by SQL InstanceId.
    ${InstanceId},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Get detail properties for SQL client by piping ClientObject.
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Get-CVSQLClientDetail';
            ByObject = 'CommvaultPowershell.custom\Get-CVSQLClientDetail';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve SQL clone information.
.Description
Method to retrieve SQL clone information.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsqlclone
#>
function Get-CVSQLClone {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='Default', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ByName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get clone information filtered by ClientName.
    ${ClientName},

    [Parameter(ParameterSetName='ByName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get clone information filtered by InstanceName.
    ${InstanceName},

    [Parameter(ParameterSetName='ById')]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Get clone information filtered by ClientId.
    ${ClientId},

    [Parameter(ParameterSetName='ById')]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Get clone information filtered by InstanceId.
    ${InstanceId},

    [Parameter(ParameterSetName='ByObject', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Get clone information filtered by piping ClientObject.
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Default = 'CommvaultPowershell.custom\Get-CVSQLClone';
            ByName = 'CommvaultPowershell.custom\Get-CVSQLClone';
            ById = 'CommvaultPowershell.custom\Get-CVSQLClone';
            ByObject = 'CommvaultPowershell.custom\Get-CVSQLClone';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve SQL clone detail information.
.Description
Method to retrieve SQL clone detail information.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsqlclonedetail
#>
function Get-CVSQLCloneDetail {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ById', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ById', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Get clone detail information for clone Id.
    ${Id},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    ${CloneObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ById = 'CommvaultPowershell.custom\Get-CVSQLCloneDetail';
            ByObject = 'CommvaultPowershell.custom\Get-CVSQLCloneDetail';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve SQL databases protected within the CommServe.
.Description
This method is implemented with Powershell paging support.
If the Name parameter is not provided, this method will output all protected SQL databases.
If the Name parameter is provided, SQL databases matching the name will be output.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsqldatabase
#>
function Get-CVSQLDatabase {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='Default', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [CVSQLDatabaseSortColumn]
    # Sort SQL databases by: bkpTime, bkpSize, insName, dbName, cName, planName.
    ${SortColumn},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Sort SQL databases by specified column in descending order; Default is ascending order.
    ${SortDescending},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Get only SQL databases with missed SLAs.
    ${OnlySLA},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Get SQL databases including system databases.
    ${ShowSysDB},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Get SQL databases with all properties.
    ${AllProperties},

    [Parameter(ParameterSetName='ByName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get SQL database specified by Name.
    ${Name},

    [Parameter(ParameterSetName='ByName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get SQL databases associated with ClientName.
    ${ClientName},

    [Parameter(ParameterSetName='ByName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get SQL databases associated with InstanceName.
    ${InstanceName},

    [Parameter(ParameterSetName='ById')]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Get SQL database specified by database Id.
    ${Id},

    [Parameter(ParameterSetName='ById')]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Get SQL databases associated with InstanceId.
    ${InstanceId},

    [Parameter(ParameterSetName='ByObject', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Get SQL databases associated with piped InstanceObject.
    ${InstanceObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Default = 'CommvaultPowershell.custom\Get-CVSQLDatabase';
            ByName = 'CommvaultPowershell.custom\Get-CVSQLDatabase';
            ById = 'CommvaultPowershell.custom\Get-CVSQLDatabase';
            ByObject = 'CommvaultPowershell.custom\Get-CVSQLDatabase';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve SQL database backup history information.
.Description
Method to retrieve SQL database backup history information.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsqldatabasebackuphistory
#>
function Get-CVSQLDatabaseBackupHistory {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The database Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Include full job details.
    ${JobDetail},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # The SQL DatabaseObject.
    ${DatabaseObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Get-CVSQLDatabaseBackupHistory';
            ByObject = 'CommvaultPowershell.custom\Get-CVSQLDatabaseBackupHistory';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve SQL database details.
.Description
Method to retrieve SQL database details specified by database name or pipeline input of an SQL database object.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsqldatabasedetail
#>
function Get-CVSQLDatabaseDetail {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get SQL database details for the database specified by Name.
    ${Name},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Get SQL database details for the database specified by DatabaseObject.
    ${DatabaseObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Get-CVSQLDatabaseDetail';
            ByObject = 'CommvaultPowershell.custom\Get-CVSQLDatabaseDetail';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve SQL instances protected within the CommServe.
.Description
This method is implemented with Powershell paging support.
If the Name parameter is not provided, this method will output all protected SQL instances.
If the Name parameter is provided, SQL instances matching the name will be output.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsqlinstance
#>
function Get-CVSQLInstance {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='Default', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [CVSQLInstanceSortColumn]
    # Sort SQL instances by: insId, insName, version, cName, noDBs, or planName.
    ${SortColumn},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Sort SQL instances by specified column in descending order; default is ascending order.
    ${SortDescending},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Get only SQL instances with missed SLAs.
    ${OnlySLA},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Get SQL instances with all properties.
    ${AllProperties},

    [Parameter(ParameterSetName='ByName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get SQL instance specified by Name.
    ${Name},

    [Parameter(ParameterSetName='ByName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get SQL instances associated with ClientName.
    ${ClientName},

    [Parameter(ParameterSetName='ByObject', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Get SQL instances associated with piped ClientObject.
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Default = 'CommvaultPowershell.custom\Get-CVSQLInstance';
            ByName = 'CommvaultPowershell.custom\Get-CVSQLInstance';
            ByObject = 'CommvaultPowershell.custom\Get-CVSQLInstance';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve backup history data for specific SQL instance.
.Description
Method to retrieve backup history data for specific SQL instance.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsqlinstancebackuphistory
#>
function Get-CVSQLInstanceBackupHistory {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # The SQL instance Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Include full job details.
    ${JobDetail},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # The SQL InstanceObject.
    ${InstanceObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Get-CVSQLInstanceBackupHistory';
            ByObject = 'CommvaultPowershell.custom\Get-CVSQLInstanceBackupHistory';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve SQL instance details.
.Description
Method to retrieve SQL instance details specified by instance name or pipeline input of an SQL instance object.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsqlinstancedetail
#>
function Get-CVSQLInstanceDetail {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get SQL instance details for the instance specified by Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Get all properties for the specified SQL instance.
    ${AllProperties},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Get SQL instance details for the instance object input from the pipeline.
    ${InstanceObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Get-CVSQLInstanceDetail';
            ByObject = 'CommvaultPowershell.custom\Get-CVSQLInstanceDetail';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve storage policies from the CommServe.
.Description
Method to retrieve storage policies from the CommServe.
Output can be filtered by media agent and policy Name.
Note: detail information is
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvstoragepolicy
#>
function Get-CVStoragePolicy {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='Default', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify storage policy instances to be output by Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Output AllProperties for each schedule policy.
    ${AllProperties},

    [Parameter(ParameterSetName='ByName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify storage policy instances to be output by MediaAgentName.
    ${MediaAgentName},

    [Parameter(ParameterSetName='ByObject', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Specify storage policy instances to be output pipeline input of MediaAgentObject.
    ${MediaAgentObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Default = 'CommvaultPowershell.custom\Get-CVStoragePolicy';
            ByName = 'CommvaultPowershell.custom\Get-CVStoragePolicy';
            ByObject = 'CommvaultPowershell.custom\Get-CVStoragePolicy';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve the list of subclients or a named subclient for a given client from the CommServe.
.Description
Method to retrieve the list of subclients or a named subclient for a given client from the CommServe.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsubclient
#>
function Get-CVSubclient {
[Alias('Get-CVSubclientProps')]
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByClientName', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ByClientName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get list of subclient properties for ClientName.
    ${ClientName},

    [Parameter()]
    [Alias('SubclientName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get properties for the subclient specified by Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    ${Id},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Retrieves all properties for subclients.
    ${AllProperties},

    [Parameter(ParameterSetName='ByClientObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByClientName = 'CommvaultPowershell.custom\Get-CVSubclient';
            ByClientObject = 'CommvaultPowershell.custom\Get-CVSubclient';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve subclient media agent instances from the CommServe.
.Description
Method to retrieve subclient media agent instances from the CommServe.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvsubclientmediaagent
#>
function Get-CVSubclientMediaAgent {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Retrieve media agent instances for subclient identified by Name.
    ${Name},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Parameter(ParameterSetName='ById', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Provide ClientName for subclient lookup.
    ${ClientName},

    [Parameter(ParameterSetName='ById', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Retrieve media agent instances for subclient identified by Id.
    ${Id},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Retrieve media agent instances by piped SubclientObject.
    ${SubclientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Get-CVSubclientMediaAgent';
            ById = 'CommvaultPowershell.custom\Get-CVSubclientMediaAgent';
            ByObject = 'CommvaultPowershell.custom\Get-CVSubclientMediaAgent';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve the current version, service pack level, and time zone settings on the CommServe.
.Description
Method to retrieve the current version, service pack level, and time zone settings on the CommServe.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvversioninfo
#>
function Get-CVVersionInfo {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param()

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Get-CVVersionInfo';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve the last backup details of virtual machines in the CommCell.
.Description
Method to retrieve the last backup details of virtual machines in the CommCell.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
Outputs [PSCustomObject] representing virtual machine last backup details.
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvvirtualmachinebackuptime
#>
function Get-CVVirtualMachineBackupTime {
[Alias('Get-CVLastBackup')]
[CmdletBinding(DefaultParameterSetName='Default', PositionalBinding=$false)]
param(
    [Parameter()]
    [Alias('VMName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Filter output to virtual machine Name.
    ${Name},

    [Parameter(ParameterSetName='ByClient')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Filter output by active subclients of ClientName.
    ${ClientName},

    [Parameter(ParameterSetName='ByClient', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Filter output by active subclients of ClientObject.
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Default = 'CommvaultPowershell.custom\Get-CVVirtualMachineBackupTime';
            ByClient = 'CommvaultPowershell.custom\Get-CVVirtualMachineBackupTime';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve list of active mounts for specified source virtual machine.
.Description
Method to retrieve list of active mounts for specified source virtual machine.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvvirtualmachinelivemount
#>
function Get-CVVirtualMachineLiveMount {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Source virtual machine Name.
    ${Name},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Source virtual machine associated ClientName.
    ${ClientName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify SubclientName to override the default behavior.
    ${SubclientName},

    [Parameter(ParameterSetName='ById', Mandatory)]
    [Alias('VMName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify Id representing source virtual machine GUID.
    ${Id},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Get-CVVirtualMachineLiveMount';
            ById = 'CommvaultPowershell.custom\Get-CVVirtualMachineLiveMount';
            ByObject = 'CommvaultPowershell.custom\Get-CVVirtualMachineLiveMount';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to retrieve workflows from the CommServe.
.Description
Method to retrieve workflows from the CommServe.
Output can be filtered by workflow Name or Id.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Int32
.Inputs
System.String
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/get-cvworkflow
#>
function Get-CVWorkflow {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByList', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ByName', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify the workflow to be output by Name.
    ${Name},

    [Parameter(ParameterSetName='ById', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify the workflow to be output by Id.
    ${Id}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByList = 'CommvaultPowershell.custom\Get-CVWorkflow';
            ByName = 'CommvaultPowershell.custom\Get-CVWorkflow';
            ById = 'CommvaultPowershell.custom\Get-CVWorkflow';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to submit SQL database mount job.
.Description
Method to submit SQL database mount job.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.String
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/mount-cvsqldatabase
#>
function Mount-CVSQLDatabase {
[OutputType([System.String])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Mount the SQL database identified by Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Mount the SQL database with DestDatabaseName.
    ${DestDatabaseName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Mount the SQL database with ExpireDays.
    # Default: 30
    ${ExpireDays},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to control OverwriteDatabase.
    ${OverwriteDatabase},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Mount the SQL database identified by DatabaseObject.
    ${DatabaseObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Mount-CVSQLDatabase';
            ByObject = 'CommvaultPowershell.custom\Mount-CVSQLDatabase';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to initiate live mount of specified virtual machine.
.Description
Method to initiate live mount of specified virtual machine from specified media.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/mount-cvvirtualmachine
#>
function Mount-CVVirtualMachine {
[Alias('Mount-CVVM')]
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Source virtual machine Name.
    ${Name},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Source virtual machine associated ClientName.
    ${ClientName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify SubclientName to override the default behaviour.
    ${SubclientName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify NetworkName for live mount operation.
    ${NetworkName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify PolicyName for live mount operation.
    ${PolicyName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify JobId to live mount from particular backup job.
    ${JobId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify LiveMountVMName to override default naming behavior.
    ${LiveMountVMName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify ExpirationInHours for in-place live mount.
    ${ExpirationInHours},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ById', Mandatory)]
    [Alias('VMName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify Id representing source virtual machine GUID.
    ${Id},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Mount-CVVirtualMachine';
            ById = 'CommvaultPowershell.custom\Mount-CVVirtualMachine';
            ByObject = 'CommvaultPowershell.custom\Mount-CVVirtualMachine';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create new Bucket for Cloud storage
.Description
Create new Bucket for Cloud storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvbucketforcloudstorage
#>
function New-CVBucketforCloudStorage {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Collections.Hashtable]
    # Hashtable containing the properties of the Cloud Storage.
    # Please refer to the swagger documentation for the payload structure : URL /V4/Storage/Cloud/{cloudStorageId}/Bucket
    ${Properties},

    [Parameter(Position=1, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Id of the cloud storage
    ${cloudStorageId}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\New-CVBucketforCloudStorage';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create new Cloud storage
.Description
Create new Cloud storage
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvcloudstorage
#>
function New-CVCloudStorage {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Collections.Hashtable]
    # Hashtable containing the properties of the Cloud Storage.
    # Please refer to the swagger documentation for the payload structure : URL /v4/CloudStorage
    ${Properties}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\New-CVCloudStorage';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create new credential
.Description
Create new credential
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvcredentials
#>
function New-CVCredentials {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Collections.Hashtable]
    # Hashtable containing the properties of the Credentails to be created.
    # Please refer to the swagger documentation for the payload structure : URL /v4/Credential
    ${Properties}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\New-CVCredentials';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a New Hypervisor
.Description
Create a New Hypervisor
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvhypervisor
#>
function New-CVHypervisor {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Collections.Hashtable]
    # Hashtable containing the properties of the credential.
    # Use Get-CVCredentialDetail to get the PSObject of an existing creds.
    ${Properties}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\New-CVHypervisor';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create LDAP/Active directory for user authentication
.Description
Create LDAP/Active directory for user authentication
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvldap
#>
function New-CVLdap {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Collections.Hashtable]
    # Hashtable containing the properties of the Ldap server.
    # Please refer to the swagger documentation for the payload structure
    ${Properties}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\New-CVLdap';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a replication group
.Description
Create a replication group
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/new-cvreplicationgroup
#>
function New-CVReplicationGroup {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Collections.Hashtable]
    # Hashtable containing the properties of the Replication Group .
    # Please refer to the swagger documentation for the payload structure PATH /V4/ReplicationGroup
    ${Properties}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\New-CVReplicationGroup';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis

.Description

.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/processblackoutwindowignorehigherlevelrules
#>
function ProcessBlackoutWindowIgnoreHigherLevelRules {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Position=0)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    ${Session},

    [Parameter(Position=1)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    ${ClientId},

    [Parameter(Position=2)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    ${AppTypeId},

    [Parameter(Position=3)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    ${InstanceId},

    [Parameter(Position=4)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    ${BackupsetId},

    [Parameter(Position=5)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    ${SubclientId},

    [Parameter(Position=6)]
    [Commvault.Powershell.Category('Body')]
    [System.Boolean]
    ${Force}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\ProcessBlackoutWindowIgnoreHigherLevelRules';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis

.Description

.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.String
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/remove-cvsqlclone
#>
function Remove-CVSQLClone {
[OutputType([System.String])]
[CmdletBinding(DefaultParameterSetName='ById', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ById', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    ${InstanceId},

    [Parameter(ParameterSetName='ById', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    ${CloneId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    ${Force},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    ${InstanceName},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    ${CloneObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ById = 'CommvaultPowershell.custom\Remove-CVSQLClone';
            ByName = 'CommvaultPowershell.custom\Remove-CVSQLClone';
            ByObject = 'CommvaultPowershell.custom\Remove-CVSQLClone';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Restart the job specified by job Id.
.Description
Restart the job specified by job Id.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/restart-cvjob
#>
function Restart-CVJob {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Restart the job specified by JobId.
    ${JobId}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Restart-CVJob';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create restore task for specific or default subclient of client file system.
.Description
Create restore task for specific or default subclient of client file system.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/restore-cvclientfilesystem
#>
function Restore-CVClientFileSystem {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Create a file system restore task for client specified by Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Create a file system restore task for subclient specified by SubclientName.
    ${SubclientName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Create a file system restore task for subclient specified by SubclientId.
    ${SubclientId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ById', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Create a file system restore task for client specified by Id.
    ${Id},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Create a file system restore task for client specified by piped ClientObject.
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Restore-CVClientFileSystem';
            ById = 'CommvaultPowershell.custom\Restore-CVClientFileSystem';
            ByObject = 'CommvaultPowershell.custom\Restore-CVClientFileSystem';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to submit SQL database in-place or out-of-place restore job.
.Description
Method to submit SQL database in-place or out-of-place restore job.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.String
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/restore-cvsqldatabase
#>
function Restore-CVSQLDatabase {
[OutputType([System.String])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify the database files to be restored by database Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify the database files to be restored by PointInTime.
    ${PointInTime},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify the database files to be restored by the CopyPrecedence applicable to your environment.
    ${CopyPrecedence},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to initiate an out-of-place restore.
    ${OutofPlace},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to control OverwriteExisting of the database files.
    ${OverwriteExisting},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Specify the database files to be restored by piping DatabaseObject.
    ${DatabaseObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Restore-CVSQLDatabase';
            ByObject = 'CommvaultPowershell.custom\Restore-CVSQLDatabase';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to initiate restore/recovery of specified virtual machine.
.Description
Method to initiate restore/recovery of specified virtual machine.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/restore-cvvirtualmachine
#>
function Restore-CVVirtualMachine {
[Alias('Restore-CVVM', 'Restore-CVVMOut')]
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify the virtual machine to be restored by Name.
    ${Name},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Source virtual machine associated ClientName
    ${ClientName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify SubclientName to override the default behaviour.
    ${SubclientName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify JobId from which to restore.
    ${JobId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify CopyPrecedence from which the restore should occur: Primary, secondary or cloud.
    ${CopyPrecedence},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [CVVSARestoreType]
    # Specify RestoreType: FullVirtualMachine or VirtualMachineFiles.
    ${RestoreType},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to create an out-of-place virtual machine restore.
    ${OutofPlace},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to PowerOnAfterRestore.
    ${PowerOnAfterRestore},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to OverwriteExisting.
    ${OverwriteExisting},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # PSCustom object with request body which contains destination client and destination info or vmFileLevelRestoreOptions for out-of-place restore
    ${Requestbody},

    [Parameter(ParameterSetName='ById', Mandatory)]
    [Alias('VMName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify the virtual machine to be restored by GUID.
    ${Id},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Restore-CVVirtualMachine';
            ById = 'CommvaultPowershell.custom\Restore-CVVirtualMachine';
            ByObject = 'CommvaultPowershell.custom\Restore-CVVirtualMachine';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Resumes the job specified by job Id.
.Description
Resumes the job specified by job Id.
If the job cannot be resumed, this command has no effect.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/resume-cvjob
#>
function Resume-CVJob {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Resume the job specified by JobId.
    ${JobId}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Resume-CVJob';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to create a client file system browse query.
.Description
Method to create a client file system browse query.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/search-cvclientfilesystem
#>
function Search-CVClientFileSystem {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Create a browse query for client specified by Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify SubclientName for browse query.
    ${SubclientName},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify Path for browse query.
    ${Path},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify BackupSetId for browse query.
    ${BackupSetId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify CopyPrecedence for browse query: Primary (default), Secondary, Cloud.
    ${CopyPrecedence},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify JobId for browse query.
    ${JobId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify Proxy for browse query.
    ${Proxy},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify MediaAgent for browse query.
    ${MediaAgent},

    [Parameter(ParameterSetName='ById', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Create a browse query for client specified by Id.
    ${Id},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Create a browse query for client specified by piped ClientObject.
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Search-CVClientFileSystem';
            ById = 'CommvaultPowershell.custom\Search-CVClientFileSystem';
            ByObject = 'CommvaultPowershell.custom\Search-CVClientFileSystem';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Retrieve list of protected files in client file system by search pattern.
.Description
Retrieve list of protected files in client file system by search pattern.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/select-cvclientfilesystem
#>
function Select-CVClientFileSystem {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Provide file pattern for search e.g.
    # '*.txt'.
    ${FilePattern},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Retrieve file list for client specified by Name.
    ${Name},

    [Parameter(ParameterSetName='ById', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Retrieve file list for client specified by Id.
    ${Id},

    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Retrieve file list for client specified by piped ClientObject.
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Select-CVClientFileSystem';
            ById = 'CommvaultPowershell.custom\Select-CVClientFileSystem';
            ByObject = 'CommvaultPowershell.custom\Select-CVClientFileSystem';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create Send Log Files task for client or specific job.
.Description
Create Send Log Files task for client or specific job.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.String
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/send-cvlogfile
#>
function Send-CVLogFile {
[Alias('Start-CVSendLogFiles')]
[OutputType([System.String])]
[CmdletBinding(DefaultParameterSetName='ById', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ById', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Create Send Log Files task for job identified by JobId.
    ${JobId},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify EmailAddr for notification purpose.
    ${EmailAddr},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Create Send Log Files task for client identified by ClientName.
    ${ClientName}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ById = 'CommvaultPowershell.custom\Send-CVLogFile';
            ByName = 'CommvaultPowershell.custom\Send-CVLogFile';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to set client properties.
.Description
Method to set client properties.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvclient
#>
function Set-CVClient {
[Alias('Set-CVClientProps')]
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='ByName', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Alias('ClientProps')]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Piped-in Properties set.
    ${Properties},

    [Parameter(ParameterSetName='ByName', Mandatory)]
    [Alias('ClientName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Set properties on client specified by Name.
    ${Name},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ById', Mandatory)]
    [Alias('ClientId')]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Set properties on client specified by Id.
    ${Id}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByName = 'CommvaultPowershell.custom\Set-CVClient';
            ById = 'CommvaultPowershell.custom\Set-CVClient';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to set client group properties.
.Description
Method to set client group properties.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
Outputs [PSCustomObject] containing job submission result.
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvclientgroup
#>
function Set-CVClientGroup {
[CmdletBinding(PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Position=0, Mandatory)]
    [Alias('ClientGroupName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Set properties on client group specified by Name.
    ${Name},

    [Parameter(Position=1, Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Alias('ClientGroupProps')]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Piped Properties set.
    ${Properties},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Set-CVClientGroup';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Edit credential whose name has been provided by credential owner
.Description
Edit credential whose name has been provided by credential owner
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvcredential
#>
function Set-CVCredential {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Get Credential Details by Name.
    ${Name},

    [Parameter(Position=1, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.PSObject]
    # PSObject containing the properties of the credential.
    # Use Get-CVCredentialDetail to get the PSObject of an existing creds.
    ${Properties}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Set-CVCredential';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Update the hypervisor
.Description
Update the hypervisor
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvhypervisor
#>
function Set-CVHypervisor {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Id of the hypervisor entity
    ${hypervisorId},

    [Parameter(Position=1, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Collections.Hashtable]
    # Hashtable containing the properties of the credential.
    # Use Get-CVCredentialDetail to get the PSObject of an existing creds.
    ${Properties}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Set-CVHypervisor';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to create a new subclient.
.Description
Method to create a new subclient.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/set-cvsubclient
#>
function Set-CVSubclient {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(DefaultParameterSetName='Default', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Position=0, Mandatory)]
    [Alias('RequestBody')]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.PSObject]
    # Request body for the subclient creation : Refer to https://documentation.commvault.com/11.24/essential/49174_rest_api_post_subclient.html.
    ${Body},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    ${Force}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Default = 'CommvaultPowershell.custom\Set-CVSubclient';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Method to start/execute a workflow on the CommServe.
.Description
Method to start/execute a workflow on the CommServe.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Int32
.Inputs
System.Object
.Inputs
System.String
.Outputs
Outputs [PSCustomObject] containing start workflow result.
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/start-cvworkflow
#>
function Start-CVWorkflow {
[CmdletBinding(DefaultParameterSetName='ByObject', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ByObject', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Specify workflow to be started by WorkflowObject.
    ${WorkflowObject},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Switch to Force override of default 'WhatIf' confirmation behavior.
    ${Force},

    [Parameter(ParameterSetName='ByName', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Specify workflow to be started by Name.
    ${Name},

    [Parameter(ParameterSetName='ById', Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Specify workflow to be started by Id.
    ${Id}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            ByObject = 'CommvaultPowershell.custom\Start-CVWorkflow';
            ByName = 'CommvaultPowershell.custom\Start-CVWorkflow';
            ById = 'CommvaultPowershell.custom\Start-CVWorkflow';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Stops/kills the job specified by job Id.
.Description
Stops/kills the job specified by job Id.
If the job cannot be killed, this command has no effect.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/stop-cvjob
#>
function Stop-CVJob {
[Alias('Kill-CVJob')]
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Stop/kill the job specified by JobId.
    ${JobId}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Stop-CVJob';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis

.Description

.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/submit-cvrestrequest
#>
function Submit-CVRESTRequest {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Collections.Hashtable]
    ${Payload},

    [Parameter(Position=1)]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    ${ValidateProperty},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    ${DryRun}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Submit-CVRESTRequest';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Update the hypervisor credentials
.Description
Update the hypervisor credentials
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Outputs
System.Management.Automation.PSObject
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/update-cvhypervisorcredentials
#>
function Update-CVHyperVisorCredentials {
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Position=0, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Collections.Hashtable]
    # Hashtable containing the properties of the credentials.
    # Please refer to the swagger documentation for the payload structure
    ${Properties},

    [Parameter(Position=1, Mandatory)]
    [Commvault.Powershell.Category('Body')]
    [System.Int64]
    # Id of the Hypervisor
    ${HypervisorId}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            __AllParameterSets = 'CommvaultPowershell.custom\Update-CVHyperVisorCredentials';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}

# ----------------------------------------------------------------------------------
#
# Copyright Microsoft Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Initiates backup job for subclients with missed SLA.
.Description
Initiates backup job for subclients with missed SLA.
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}
.Example
PS C:\> {{ Add code here }}

{{ Add output here }}

.Inputs
System.Object
.Outputs
Outputs [PSCustomObject] for each subclient with missed SLA, containing job submission result.
.Link
https://docs.microsoft.com/en-us/powershell/module/commvaultpowershell/update-cvmissedsla
#>
function Update-CVMissedSLA {
[Alias('Protect-CVMissedSLA')]
[CmdletBinding(DefaultParameterSetName='Default', PositionalBinding=$false)]
param(
    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # EmailAddr for notification purpose.
    ${EmailAddr},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Client = 1 (default), Agent = 2.
    ${Type},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Any = 0, Protected = 1, Failed = 2 (default), NoJobFound = 3, NoSchedule = 4.
    ${Category},

    [Parameter()]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Any = 0, Protected = 1, Unprotected = 2 (default), Excluded = 3.
    ${Status},

    [Parameter(ParameterSetName='ByName')]
    [Commvault.Powershell.Category('Body')]
    [System.String]
    # Filter SLA report by ClientName.
    ${ClientName},

    [Parameter(ParameterSetName='ById')]
    [Commvault.Powershell.Category('Body')]
    [System.Int32]
    # Filter SLA report by ClientId.
    ${ClientId},

    [Parameter(ParameterSetName='ByObject', ValueFromPipeline, ValueFromPipelineByPropertyName)]
    [Commvault.Powershell.Category('Body')]
    [System.Object]
    # Filter SLA report by piped ClientObject.
    ${ClientObject}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        $mapping = @{
            Default = 'CommvaultPowershell.custom\Update-CVMissedSLA';
            ByName = 'CommvaultPowershell.custom\Update-CVMissedSLA';
            ById = 'CommvaultPowershell.custom\Update-CVMissedSLA';
            ByObject = 'CommvaultPowershell.custom\Update-CVMissedSLA';
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        throw
    }
}

end {
    try {
        $steppablePipeline.End()
    } catch {
        throw
    }
}
}
